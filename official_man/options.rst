选项
====

轨道选择
--------

``--alang=<languagecode[,languagecode,...]>``
    指定一个优先使用的音频语言列表，作为IETF语言标签。ISO 639-1的两个字母和ISO 639-2的三个字母代码被相似同等的对待。列表中第一个语言与文件中的音轨相匹配的标签将被使用。匹配较多子标签的轨道将比匹配较少的轨道优先，靠前的子标签比靠后的子标签优先。另参见 ``--aid``

    特殊值 "auto" 可以包含在列表内，相当于用户的操作系统级的首选语言列表。

    这是一个字符串列表选项。详见 `列表选项`_

    .. admonition:: 示例

        - ``mpv dvd://1 --alang=hu,en`` 在DVD上选择匈牙利语的轨道，如不可获取该语言，则回到英语
        - ``mpv --alang=jpn example.mkv`` 播放带有日语音频的Matroska文件

``--slang=<languagecode[,languagecode,...]>``
    近似 ``--alang``，但用于字幕轨（默认值： auto ）。

    这是一个字符串列表选项。详见 `列表选项`_

    .. admonition:: 示例

        - ``mpv dvd://1 --slang=hu,en`` 选择DVD上选择匈牙利文字幕轨，如不可获取该语言，则回退到英文
        - ``mpv --slang=jpn example.mkv`` 播放带有日文字幕的Matroska文件
        - ``mpv --slang=pt-BR example.mkv`` 播放带有巴西葡萄牙语字幕（如果可用）的Matroska文件，否则播放任何葡萄牙语字幕

``--vlang=<...>``
    相当于 ``--alang`` 和 ``--slang`` ，用于视频轨道。

    这是一个字符串列表选项。详见 `列表选项`_

``--aid=<ID|auto|no>``
    选择音轨。 ``auto`` 选择默认轨， ``no`` 禁用音频。另参见 ``--alang`` 。mpv通常在开始播放文件时在终端输出可用的音轨。

    ``--audio`` 是 ``--aid`` 的别名。

    ``--aid=no`` 或 ``--audio=no`` 或 ``--no-audio`` 禁用音频播放（后一种变体在client API中不起作用）。

    .. note::

        轨道选择的选项（ ``--aid`` 但也包括 ``--sid`` 和其它选项）有时可能会出现奇怪的行为。并且，这种行为往往随着每个mpv版本的发布而改变。

        轨道选择的属性将返回播放之外的选项值（符合预期），但在播放过程中，受影响的轨道选择会被返回。例如，在 ``--aid=auto`` 的情况下， ``aid`` 属性会在播放初始化后突然返回 ``2`` （假设文件至少有2个音轨，而且第二个是默认轨）。

        在mpv0.32.0（和一些之前的版本）中，如果传递的轨道值不存在对应的实际轨道（例如 ``--aid=2`` 但只有1个音轨）， ``aid`` 属性会返回 ``no`` 。然而，如果在播放过程中增加了另一个音轨，再尝试将 ``aid`` 属性设置为 ``2`` ，什么也不会发生，因为 ``aid`` 选项的值仍然是 ``2`` ，而写入相同的值是没有效果的。

        在mpv0.33.0中，这个行为被改变。现在如果轨道选择的选项尝试选择一个不存在的轨道，它在播放初始化时会被重置为 ``auto`` 。如果轨道实际存在，但未能初始化，也会这样做。其后果是，与mpv0.33.0之前的版本不同，用户的轨道选择的参数在某些情况下被影响了。

        另外，从mpv0.33.0开始，尝试通过数字来选择一个轨道将严格特执行选择这个轨道。在此变化前，尝试选择一个不存在的轨道，会在播放初始化时回退到选择默认轨道。新的行为更具一致性。

        在运行时设置一个轨道选择的属性，然后播放一个新文件，如果新文件的轨道列表的fingerprint不同，可能会重置轨道选择为默认值。

        注意上述所有的微妙组合：例如， ``mpv --aid=2 file_with_2_audio_tracks.mkv file_with_1_audio_track.mkv`` 会先播放第一个文件的正确轨道，而后第二个文件不播放音频。如果你再返回第一个文件，它的第一个音轨将被播放，而第二个文件则播放音频。如果再执行同样的操作，但不是使用 ``--aid=2`` ，而是在文件播放时运行 ``set aid 2`` ，那么换到第二个文件将播放它的音轨。这是因为运行时的轨道选择会启用启发式fingerprint。

        最有可能的是这不会结束。

``--sid=<ID|auto|no>``
    显示由 ``<ID>`` 指定的字幕流。 ``auto`` 选择默认的字幕， ``no`` 禁用字幕。

    ``--sub`` 是 ``--sid`` 的别名。

    ``--sid=no`` 或 ``--sub=no`` 或 ``--no-sub`` 禁用字幕解码（后一种变体在client API中不起作用）。

``--vid=<ID|auto|no>``
    选择视频频道。 ``auto`` 选择默认的轨道， ``no`` 禁用视频。

    ``--video`` 是 ``--vid`` 的别名。

    ``--vid=no`` 或 ``--video=no`` 或 ``--no-video`` 禁用视频播放（后一种变体在client API中不起作用）。

    如果视频被禁用，mpv将尝试下载音频，只有当媒体是用youtube-dl串流时，因为这样可以节省带宽。这是通过在ytdl_hook.lua脚本中将ytdl_format设置为 "bestaudio/best" 来实现的。

``--edition=<ID|auto>``
    （Matroska文件独占）指定要使用的edition（章节集），其中0是第一个。如果设置为 ``auto`` （默认），mpv将选择被注明为默认的第一个edition，如果没有注明的默认，则选择定义中的第一个edition。

``--track-auto-selection=<yes|no>``
    启用默认轨道的自动选择（默认： yes）。启用它将使播放器根据 ``--aid``, ``--alang`` 和其它项目来选择流。如果禁用，则不选择任何轨道。此外，如果没有选择轨道，播放器将不会退出，而是等待（这种等待模式类似暂停，但实际没有设置pause选项）。

    这对 ``--lavfi-complex`` 很有用：你可以在该模式下开始播放，然后在运行时通过设置graph滤镜来设置选择轨道。注意，如果 ``--lavfi-complex`` 在播放开始前被设置，被引入的轨道始终会被选中。

``--subs-with-matching-audio=<yes|no>``
    当自动选择字幕轨时，即使所选的音频流与优先的字幕语言相匹配，也会选择一个完全/非强制的字幕轨（默认： no）。

``--subs-fallback=<yes|default|no>``
    当自动选择字幕轨道时，如果没有轨道符合你的优先语言，则选择一个完整的轨道，即使它不符合你的优先字幕语言（默认： no）。将此设置为 ``default`` 表示只有标记为 ``default`` 的流才会被选中。

``--subs-fallback-forced=<yes|no>``
    当自动选择字幕轨道时，如果没有轨道符合你的优先语言，则选择一个匹配你当前音轨语言的强制轨道（默认： yes）。


播放控制
--------

``--start=<relative time>``
    跳转到给定的时间位置。

    时间的一般格式是 ``[+|-][[hh:]mm:]ss[.ms]`` 。如果时间的前缀是 ``-`` ，则该时间被认为是相对于文件末尾的位置（解复用其/文件的标记）。 ``+`` 通常会被忽略（但是请见下文）。

    以下是可识别的可替代的时间规格：

    ``pp%`` 跳转到百分比位置 pp (0-100)

    ``#c`` 跳转到章节编号 c (章节从1开始)

    ``none`` 重置任何之前设置的选项（对libmpv有用）

    如果给出 ``--rebase-start-time=no`` ，那么在时间前加上 ``+`` ，使时间是相对于文件的起始时间。没有前缀的时间戳被认为是绝对时间，例如，应该跳转到文件中包含该时间戳的帧。作为一个错误，但也却是一个隐藏功能，在 ``+`` 或 ``-`` 前放1个或多个空格，总是会将该时间解释为绝对时间，这可以用来跳转到负的时间戳（最多用于调试）。

    .. admonition:: 示例

        ``--start=+56``, ``--start=00:56``
            跳转到开始时间+56秒
        ``--start=-56``, ``--start=-00:56``
            跳转到结束时间-56秒
        ``--start=01:10:00``
            跳转到1小时10分
        ``--start=50%``
            跳转到文件的中间部分
        ``--start=30 --end=40``
            跳转到30秒，播放10秒，然后退出
        ``--start=-3:20 --length=10``
            跳转到文件结束前的3分20秒，播放10秒，然后退出
        ``--start='#2' --end='#4'``
            播放第2章和第3章，然后退出

``--end=<relative time>``
    在给定的时间停止。如果时间是相对于 ``--start`` 的，则使用 ``--length`` 。有效的选项值和示例，参见 ``--start``

``--length=<relative time>``
    在相对于开始时间的一个给定时间后停止。有效的选项值和示例，参见 ``--start``

    如果同时提供了 ``--end`` 和 ``--length`` ，播放将在到达两个结束点中的其中一个时停止。

    隐性注意点：如果设置了 ``--rebase-start-time=no`` ，并且指定的时间不是“绝对”时间，正如 ``--start`` 选项描述中定义的那样，则不能生效。

``--rebase-start-time=<yes|no>``
    是否将文件的开始时间移动到 ``00:00:00`` （默认： yes）。这对于以随机时间戳开始的文件来说不那么突兀，比如传输流。另一方面，如果有时间戳重置，产生的行为可能相当奇怪。出于这个原因，如果你真的对真实的时间戳感兴趣，可以用 ``no`` 来禁用这种行为。

``--speed=<0.01-100>``
    按参数给定的系数减慢或加快播放速度。

    如果使用了 ``--audio-pitch-correction`` （默认： yes），以高于正常速度播放会自动插入 ``scaletempo2`` 音频滤镜。

``--pause``
    以暂停状态启动播放器。

``--shuffle``
    以随机顺序播放文件。

``--playlist-start=<auto|index>``
    设置从内部播放列表的哪个文件开始播放。索引是一个整数，0表示第一个文件。值 ``auto`` 表示选择要播放的条目是留给播放恢复机制的（默认）。如果一个具有给定索引的条目不存在，行为是未指定的，在未来的mpv版本中可能会改变。如果播放列表包含更多的播放列表，也是同样的情况（不要期待任何合理的行为）。不过，把播放列表文件传递给mpv应该可以使这个选项起作用。例如， ``mpv playlist.m3u --playlist-start=123`` 将按预期工作，只要 ``playlist.m3u`` 不链接到其它的播放列表。

    值 ``no`` 是 ``auto`` 的过时的别名。

``--playlist=<filename>``
    根据一个播放列表文件播放文件。支持一些常见的格式。如果没有检测到格式，它将被视为一系列文件，用换行符分隔。可能需要这个选项来加载纯文本文件作为播放列表。注意，不支持XML播放列表格式。

    这个选项强制 ``--demuxer=playlist`` 来解析播放列表文件。一些播放列表格式，特别是CUE和光盘格式，需要使用不同的解复用器，使用该选项将无法工作。不使用这个选项仍然可以直接播放它们。

    你可以不带这个选项而直接播放播放列表。在mpv0.31.0版本之前，这个选项禁用了任何可能存在的安全机制，但从0.31.0开始，它使用与直接播放播放列表文件相同的安全机制。如果信任播放列表文件，可以用 ``--load-unsafe-playlists`` 禁用任何安全检查。因为播放列表可以加载其它播放列表的条目，考虑只对播放列表本身而不是其条目，应用这个选项，使用这样类似的方法：

        ``mpv --{ --playlist=filename --load-unsafe-playlists --}``

    .. warning::

        旧版本的mpv通过 ``--playlist`` 播放播放列表文件的方式对恶意构建的文件而言是不安全的。这样的文件可能引发有害行为。在0.31.0之前的所有mpv和所有MPlayer版本都是如此，但不幸的是，这个事实在早期没有被很好的记录，有些人甚至误导性的推荐使用 ``--playlist`` 和不值得信任的文件来源。如果不确定你的mpv版本至少是0.31.0，请不要用 ``--playlist`` 链接随机的互联网来源或不信任的文件。

        特别是，播放列表可以包含使用除本地文件以外的协议的条目，例如像 ``avdevice://`` 这样的特殊协议（它本质上就不安全）。

``--chapter-merge-threshold=<number>``
    合并几乎连续的有序章节部分的阈值，以毫秒为单位（默认： 100）。一些带有有序章节的Matroska文件有不准确的章节结束时间戳，导致一个章节的结束和下一个章节的开始之间有一个小间隙，但它们应该是匹配的。如果一个播放部分的结束与下一个部分的开始之间的距离小于给定的阈值，那么就在章节的变更期间继续正常播放视频，而不是做一个跳转。

``--chapter-seek-threshold=<seconds>``
    以秒为单位，从章节开始到上一章的距离，在该长度内，后退一章将进入前一章（默认： 5.0）。超过这个阈值，向前跳转章节将前往当前章节的开头。一个负的值意味着始终返回到前一章。

``--hr-seek=<no|absolute|yes|default>``
    选择何时使用不限于关键帧的精确跳转。这种跳转需要解码视频从上一个关键帧到目标位置，因此可能需要一些时间，取决于解码性能。对于某些视频格式，精确跳转被禁用。这个选项选择了用于跳转的默认选择；在定义按键绑定和输入命令时，可以明确地覆盖该默认值。

    :no:       从不使用精确跳转
    :absolute: 如果在文件中寻找一个绝对位置，如章节跳转，使用精确跳转，但对相对位置，例如方向键的默认行为，则不使用
    :default:  类似 ``absolute`` ，但在仅有音频的情况下启用。具体的行为视具体情况而定，可能会随着新版本的发布而改变（默认）
    :yes:      尽可能使用精确跳转
    :always:   与 ``yes`` 相同（为了兼容性）

``--hr-seek-demuxer-offset=<seconds>``
    这个选项的存在是为了解决由于某些文件格式的解复用器的错误或限制而导致的精确跳转失败（正如 ``--hr-seek`` 里的描述）。有些解复用器不能在给定的目标位置之前寻找关键帧，而只能跳转一个靠后的位置。这个选项的值将从被给定的解复用器的时间戳中减去。因此，如果把这个选项设置为1.5，并尝试做精确跳转到60秒，解复用器会被告知要跳转到时间58.5，这有希望能减少它错误的跳转到比60秒晚的某个时间的机会。设置这个选项的坏处是，精确跳转的速度会更慢，因为目标的靠前位置和真正的目标之间的视频可能被解复用器不必要的解码。

``--hr-seek-framedrop=<yes|no>``
    允许视频解码器在跳转过程中丢帧，如果这些帧在跳转的目标之前。如果启用这个功能，精确跳转会加快，但如果使用修改时间戳或添加新帧的视频滤镜，会导致精确跳转略过目标帧。例如，当启用去隔行扫描时，这可能会破坏帧的backstepping。

    默认： ``yes``

``--index=<mode>``
    控制如何在文件中跳转。请注意，如果文件中缺少索引，默认情况下将在运行中建立，所以不需要改变。但它可能对一些损坏的文件有帮助。

    :default:   如果文件存在索引就使用它，如果缺失就建立索引
    :recreate:  不读取或使用该文件的索引

    .. note::

        这个选项只有在底层媒体支持跳转的情况下才有效（例如不使用stdin、pipe等）。

``--load-unsafe-playlists``
    从播放列表中加载被认为不安全的URL（默认： no）。这包括特殊协议和任何不指向普通文件的东西。另一方面，本地文件和HTTP链接始终被认为是安全的。

    此外，如果当设置该选项后时加载了一个播放列表，添加的播放列表条目不会被标记为来自网络或潜在的不安全位置（相反，其行为就像是，播放列表条目好像被直接提供给mpv命令行或 ``loadfile`` 命令）。

``--access-references=<yes|no>``
    遵循被打开的文件中的任何引入（默认： yes）。如果文件被自动扫描（如缩略图生成），禁用这个功能是有帮助的。例如，如果缩略图扫描器遇到一个包含网络URL的播放列表文件，而扫描器不应该打开这些文件，启用这个选项就可以阻止这个动作。该选项还可以禁用有序章节，mov参考文件，加载压缩档，以及一些其它的功能。

    在旧版的FFmpeg中，这在某些情况下将无法工作。一些FFmpeg解复用器可能不遵循这个选项。

    这个选项并不防止加载成对的字幕文件等。使用 ``--autoload-files=no`` 来阻止这种情况。

    如果你打开的是非文件（例如，使用 ``dvd://directory`` 会加载指定目录下的一大堆文件），该选项并不总是有效。如果文件名不是以 ``/`` 开头，就用 ``./`` 作为前缀，可以避免这种情况。

``--loop-playlist=<N|inf|force|no>``, ``--loop-playlist``
    循环播放 ``N`` 次。值为 ``1`` 时播放一次（默认）， ``2`` 播放两次，等等。 ``inf`` 表示永远。 ``no`` 与 ``1`` 相同，禁止循环播放。如果在命令行指定了多个文件，整个播放列表将被循环播放。 ``--loop-playlist`` 与 ``--loop-playlist=inf`` 相同。

   ``force`` 模式与 ``inf`` 相似，但不会跳过已被标记为失败的播放列表条目。这表示播放器可能会浪费CPU时间，尝试循环播放一个不存在的文件。但在非常糟糕的网络条件下，它可能对播放网络广播有用。

``--loop-file=<N|inf|no>``, ``--loop=<N|inf|no>``
    循环一个文件N次。 ``inf`` 表示永远， ``no`` 表示正常播放。为了兼容性， ``--loop-file`` 和 ``--loop-file=yes`` 也被接受，并且与 ``--loop-file=inf`` 相同。

    与 ``--loop-playlist`` 的不同是，它不循环播放列表，而只是文件本身。如果播放列表只包含一个文件，这两个选项的区别是，这个选项在循环中执行跳转，而不是重新加载文件。

    .. note::

        ``--loop-file`` 计算的是使播放器跳转到文件开头的次数，而不是完全播完的次数。这表示 ``--loop-file=1`` 最终会播放该文件两次。 ``--loop-playlist`` 则不同，它计算完全播完的次数。

    ``--loop`` 是这个选项的别名。

``--ab-loop-a=<time>``, ``--ab-loop-b=<time>``
    设置循环点。如果播放中通过了 ``b`` 的时间戳，它将跳转到 ``a`` 的时间戳。跳转超过 ``b`` 点时不再循环（这是有意设计的）。

    如果 ``a`` 在 ``b`` 之后，行为正如按正确顺序给出的点一样，播放器将在通过 ``a`` 后跳转到 ``b`` 。这与旧版的行为不同，旧版的行为是禁止循环的（并且是一个错误，在文件的末端循环跳转回到 ``a`` ）。

    如果任一选项被设置为 ``no`` （或未设置），循环被禁用。这与旧版的行为不同，以前未设置的 ``a`` 表示文件的开头，而未设置的 ``b`` 表示文件的结尾。

    循环点可以在运行时通过相应的属性来调整。另参见 ``ab-loop`` 命令。

``--ab-loop-count=<N|inf>``
    只运行A-B循环N次，然后忽略A-B循环点（默认： inf）。每完成一次循环迭代，该选项将递减1（除非它被设置为 ``inf`` 或0）。 ``inf`` 表示循环会永远进行下去。如果这个选项被设置为0，A-B循环将被忽略，甚至 ``ab-loop`` 命令也不会再次启用循环（如果两个循环点都已被设置，但 ``ab-loop-count`` 为0，该命令将在OSD信息中显示 ``(disabled)`` ）。

``--ordered-chapters``, ``--no-ordered-chapters``
    默认启用。禁用对Matroska有序章节的支持。mpv不会加载或搜索其它文件的视频片段，也会忽略为主文件指定的任何章节顺序。

``--ordered-chapters-files=<playlist-file>``
    将给定的文件作为播放列表加载，并在打开带有序章节的Matroska文件时，尝试使用其中包含的文件作为参考文件。这覆盖了通过扫描主文件所在的同一目录加载参考文件的正常机制。

    对于加载不在本地文件系统上的有序章节文件，或如果被引入的文件在不同的目录中，这很有用。

    注意：播放列表可以是一个简单的文本文件，内含用换行符分隔的文件名。

``--chapters-file=<filename>``
    从这个文件加载章节，而不使用主文件中的章节元数据。

    这可以接受一个媒体文件（如mkv）或甚至一个如ffmetadata的伪格式，并使用其章节来替换当前文件的章节。这不能直接与OGM或XML章节一起工作。

``--sstep=<sec>``
    在每一帧后跳过<sec>秒。

    .. note::

        如果没有 ``--hr-seek`` ，跳过的时间将扣在关键帧上。

``--stop-playback-on-init-failure=<yes|no>``
    如果音频或视频初始化失败，停止播放（默认： no）。如果使用 ``no`` ，在其中一个失败时，将继续以纯视频或纯音频模式播放。这不影响纯音频或纯视频文件的播放。

``--play-dir=<forward|+|backward|->``
    控制播放方向（默认： forward）。设置 ``backward`` 将尝试以反向播放文件，伴随着播放时间递减。如果在播放开始时设置，播放将从文件的末端开始。如果在播放过程中改变它，将发出一个hr-seek来改变方向。

    ``+`` 和 ``-`` 是 ``forward`` 和 ``backward`` 的别名。

    这个选项的其它描述与 ``backward`` 模式有关。

    .. note::

        向前播放是非常脆弱的。它不一定能工作，比正向播放慢得多，而且会破坏某些其它功能。它的工作效果如何主要取决于正在播放的文件。一般来说，只有在众星捧月的情况下，它才能显示出良好的效果（或结果良好）。

    mpv，以及大多数媒体格式，被设计成只用于向后播放。向前播放被固定在mpv顶层，并尝试做出中等程度的努力来使向前播放工作。根据你的使用情况决定，其它工具可能工作得更好。

    向前播放并不完全是一个一流的功能。在实现上做了一些取舍，这些取舍对向前播放不利，但反过来又不会对正常播放造成不利影响。为了降低复杂性，各种可能的优化都没有实现。通常情况下，一个媒体播放器是高度管线化的（未来的数据是在独立的线程中准备的，所以当下一阶段需要它时，它是实时可用的），但向前播放基本上会在各种随机的点上使管线停滞。

    例如，对于只有i帧编码的向前播放是微不足道的，围绕它们建立的工具可能会有效地利用它们（考虑视频编辑器或相片查看器）。在这种情况下mpv不是有效率的，因为它使用其通用的向后播放的算法，在这上面没有特别优化。

    如果你只是想快速倒退视频并只显示“关键帧”，那么就使用向前播放，按住左箭头键（在默认设置的CLI上会发送许多小的相对跳转的命令）。

    该实现主要由3部分组成：

    - 向前解复用。这依赖于解复用器的缓存，所以解复用器的缓存应该（或必须，没有测试）被启用，它的大小会影响性能。如果缓存过小或过大，可能会导致二次运行时的行为。

    - 向前解码。使用的解码器库（libavcodec）不支持这个。它是通过提前输入几比特的数据，将结果放入队列，反向返回队列数据给视频输出驱动，然后在较早的位置重新开始来模拟的。这可能需要缓存超大量的解码数据，也会完全破坏管线。

    - 向前输出。这相对简单，因为解码器按需要的顺序返回帧。然而，这可能会引起各种问题，因为滤镜会观察到音频和视频向前移动。

    已知问题：

    - 它很脆弱。如果有任何东西不工作，可能会出现随机的无用的行为。在简单的情况下，播放器将只是播放无意义的东西和伪影。在其它情况下，它可能会卡住或加热CPU（不过，内存使用量远远超过用户设置的限制将是一个错误）。

    - 性能和资源的使用情况并不理想。这在一定程度上是普通媒体格式向前播放所固有的，这在一定程度上是由于实现的抉择和权衡。

    - 这极其依赖于良好的解复用器行为。尽管向前解复用不需要特殊的解复用器支持，但需要解复用器可靠地执行跳转，能满足一些关于packet元数据的特殊需求，并具有确定性的行为。

    - 准确地从结尾开始播放可能会也可能不会工作，这取决于跳转行为和文件持续时间检测。

    - 一些容器格式、音频和视频编码由于其行为而不被支持。没有列表，而且播放器通常不检测它们。某些直播流（包括电视捕获）可能会表现出特别的问题，以及一些有损的音频编码。已知h264 intra-refresh由于libavcodec的问题而无法工作。WAV和其他一些raw音频格式往往有问题 —— 有一些处理它们的hacks，可能有效也可能无效。

    - 不支持字幕的向前解复用。字幕显示仍然适用于一些外部文本字幕格式（这些是完全读取入内存的，只需要向前显示）。缓存在字幕渲染器中的文本字幕也有机会被正确显示。

    - 一些处理播放损坏的或难以处理的文件的功能将不能完全工作（如时间戳修正）。

    - 如果通过向前播放执行解复用器的低级跳转（例如，跳转实际的解复用器，而不仅仅是在解复用器的缓存内），创建的跳转范围可能无法连接，因为没有达到足够的重叠度。

    - 尝试硬件视频解码可能会耗尽所有的GPU内存，然后崩溃一两样东西。或者会失败，因为 ``--hwdec-extra-frames`` 会肯定的被设置的太低。

    - 流记录被破坏了。如果只在缓存区域内倒退播放， ``--stream-record`` 可能会继续工作。

    - 相对跳转可能表现得很奇怪。小规模的向前跳转（短的时间段，即 ``seek -1`` ）可能不会真正的正确跳转，音频将保持静音一段时间。建议使用hr-seek，它应该不会有这些问题。

    - 有些事情就是很奇怪。例如，虽然跳转命令以预期的方式操纵播放时间（只要它们能正常工作），但framestep命令是换位的。backstepping将开销巨大的性能代价来向后移动1帧。

    调试：

    - 移除所有已设置的 ``--vf`` / ``--af`` 滤镜。禁用硬件解码。禁用像SPDIF直通这样愚蠢的无意义行为。

    - 增加 ``--video-reversal-buffer`` 可能有助于逆转队列的溢出，这可能发生在高比特率视频或大GOP的视频。硬件解码大多会忽略这一点，你需要增加 ``--hwdec-extra-frames`` ，而不是（直到得到没有错误记录的播放）。

    - 解复用器缓存对向前解码至关重要。确保设置 ``--cache=yes`` 。缓存的大小可能很重要。如果它太小，队列溢出将被记录，向前播放不能继续，或者它执行了太多的低级跳转。如果太大，实现的权衡可能会导致一般的性能问题。使用 ``--demuxer-max-bytes`` 可能会增加解复用层可以排队进行反向解复用的packets的数量（基本上是相当于解复用层的 ``--video-reversal-buffer`` ）。

    - 设置 ``--vd-queue-enable=yes`` 可以使播放更加流畅（一旦成功）。

    - ``--demuxer-backward-playback-step`` 也是影响可进行多少次跳转的因素，以及向前解复用是否会因队列溢出而中断。如果它设置得太高，即使缓存足够大，backstep操作也需要一直搜索更多的packets。

    - 设置 ``--demuxer-cache-wait`` 可能有助于将整个文件缓存到解复用器缓存中。设置 ``--demuxer-max-bytes`` 到一个大的尺寸，以确保它能读取整个缓存； ``--demuxer-max-back-bytes`` 也应该设置到一个大的尺寸，以防止尝试裁剪缓存的行为。

    - 如果在即使音频输出驱动不劣质的情况下，可以听到音频瑕疵，增加 ``--audio-backward-overlap`` 可能有帮助。

``--video-reversal-buffer=<bytesize>``, ``--audio-reversal-buffer=<bytesize>``
    用于向前解码。向前解码是按step向前进行解码，然后反转解码器的输出。这些选项控制了可以缓冲的最大字节数的近似值。它的主要用途是避免无限制的资源使用；在正常的向前播放过程中，它不应该达到极限，如果它达到了，它就会丢帧并报告。

    如果在倒放过程中得到反转队列溢出的错误，请使用这个选项。增加尺寸，直到警告消失。通常，视频缓冲区会首先溢出，尤其是高分辨率的视频。

    如果使用视频硬解码，这就没有效果。视频帧的大小将不包括引入的GPU和驱动内存。一些硬件解码器也可能受到 ``--hwdec-extra-frames`` 的限制。

    队列大小需要多大，完全取决于媒体的编码方式。音频通常需要一个非常小的缓冲区，而视频可能需要过大的缓冲区。

    （技术上讲，这允许最后一帧超过限制。另外，这还没有考虑到其它缓冲帧，例如解码器内部或视频输出。）

    这完全不影响解复用器缓存的行为。

    默认值和取值范围，参见 ``--list-options`` 。 ``<bytesize>`` 选项接受后缀，如 ``KiB`` 和 ``MiB`` 。

``--video-backward-overlap=<auto|number>``, ``--audio-backward-overlap=<auto|number>``
    用于向前解码的重叠关键帧范围的数量（默认： auto）（“关键帧”应理解为mpv/ffmpeg的特定含义）。向前解码是通过小step向前解码来进行的。一些编码不能从任何packet重新开始解码（即使它被标记为跳转点），这在向前解码中变得很明显（理论上这也是跳转的问题，但 ``--hr-seek-demuxer-offset`` 可以解决跳转的问题）。特别是，基于MDCT的音频编码受到影响。

    解决办法是每次给解码器送入一个前一个的packet，然后discard输出。这个选项控制要送多少个packet。 ``auto`` 的选择目前对视频来说硬编码为0，对有损音频使用1，对无损音频使用0。对于一些特定的有损音频编码，这被设置为2。

    ``--video-backward-overlap`` 有可能处理intra-refresh视频，这取决于具体条件。可能还需要使用 ``--vd-lavc-show-all`` 选项。

``--video-backward-batch=<number>``, ``--audio-backward-batch=<number>``
    向前解码时一次解码的关键帧范围的数量（默认：视频为1，音频为10）。是另一个没有意义的调整参数，没有人应该使用。这应该只影响性能。理论上，为音频设置一个高于1的数字将减少开销，因为减少了频繁的backstep操作，以及减少了因解码重叠帧而产生的冗余解码工作（参见 ``--audio-backward-overlap`` ）。另一方面，它需要一个更大的反转缓冲区，并可能由于破坏管线而使播放不顺畅（例如，通过解码很多，然后有一段时间什么都不做）。

    设置 ``--video-backward-batch`` 可能没有意义。但在理论上，它可以通过减少backstep操作来帮助intra-only编码。

``--demuxer-backward-playback-step=<seconds>``
    在回放过程中，解复用器应该跳转回的获得新数据包的秒数（默认：60）。这对调整向前播放是很有用的，详见 ``--play-dir``

    设置为一个非常低的值或0，可能会使播放器认为跳转被损坏，或可能使它执行多次跳转。

    将其设置为较高值可能会导致二次运行时的行为。

程序行为
--------

``--help``, ``--h``
    显示选项的简短摘要。

    也可以传递给该选项一个字符串，它将列出所有名称中包含该字符串的顶级选项，例如， ``--h=scale`` 代表所有包含 ``scale`` 的选项。特殊字符串 ``*`` 列出所有顶级选项。

``-v``
    增加详细级别，在命令行上每多一个 ``-v`` 就增加一个级别。

``--version, -V``
    输出版本号的字符串并退出。

``--no-config``
    不加载默认的设置文件。这将阻止加载用户级和系统级的 ``mpv.conf`` 和 ``input.conf`` 文件。其他的设置文件也会被屏蔽，例如恢复播放的设置文件。

    .. note::

        由命令行选项明确请求的文件，如 ``--include`` 或 ``--use-filedir-conf`` ，仍将被加载。

    另参见： ``--config-dir``

``--list-options``
    输出所有可用的选项。

``--list-properties``
    输出一系列可用的属性列表。

``--list-protocols``
    输出一系列受支持的协议列表。

``--log-file=<path>``
    打开给定的路径进行写入，并输出日志信息到其中。已存在的文件将被替换。日志级别至少是 ``-v -v`` ，但可以通过 ``--msg-level`` 提高（该选项不能降低到强制的最低日志级别以下）。

    一个特殊情况是macOS bundle，它将默认在 ``~/Library/Logs/mpv.log`` 创建一个日志文件。

``--config-dir=<path>``
    强制使用一个不同的设置目录。如果设置了这个，给定的目录将被用来加载设置文件，而所有其它的设置目录都会被忽略。这表示全局的mpv设置目录以及每个用户的目录都被忽略，通过环境变量（ ``MPV_HOME`` ）覆盖的内容也被忽略。

    注意， ``--no-config`` 选项优先于该选项。

``--dump-stats=<filename>``
    将某些统计数据写入给定的文件。该文件在打开时被截断。该文件将包含原始样本，每个样本都有一个时间戳。为了使这个文件变成可读的，可以使用脚本 ``TOOLS/stats-conv.py`` （目前它以图表形式显示）。

    这个选项只在调试时有用。

``--idle=<no|yes|once>``
    让mpv在没有文件可以播放时空闲等待而不是退出。主要在输入模式下有用，mpv可以通过输入命令来控制。（默认： ``no`` )

    ``once`` 将只在启动时空闲，一旦第一个播放列表播放完毕，就让播放器关闭。

``--include=<configuration-file>``
    指定设置文件，在默认设置文件之后进行解析。

``--load-scripts=<yes|no>``
    如果设置为 "no"，则不自动加载设置子目录 ``scripts`` （通常是 ``~/.config/mpv/scripts/`` ）中的脚本。（默认： ``yes`` ）

``--script=<filename>``, ``--scripts=file1.lua:file2.lua:...``
    加载一个Lua脚本。第二个选项允许你加载多个脚本，用路径分隔符（Unix下为 ``:`` ，Windows下为 ``;`` ）将它们分开。

    ``--scripts`` 是一个路径列表选项。详见 `列表选项`_

``--script-opts=key1=value1,key2=value2,...``
    为脚本设置选项。脚本可以通过按键来查询一个选项。如果一个选项被使用，以及该选项值具有什么样的语义，完全取决于所加载的脚本。没有被任何脚本声明的值会被忽略。

    这是一个按键/值列表选项。详见 `列表选项`_

``--merge-files``
    假装所有传递给mpv的文件都被串联成一个单一的大文件。这使用内部的时间轴/EDL支持。

``--profile=<profile1,profile2,...>``
    使用给定的配置预设， ``--profile=help`` 显示已定义的配置预设的列表。

``--reset-on-next-file=<all|option1,option2,...>``
    通常情况下，mpv在播放播放列表上的下一个文件时，会尝试保留所有的设置，即使用户在播放时改变了这些设置（这种行为与MPlayer相反，MPlayer在开始播放下一个文件时尝试重置所有设置）。

    默认：不重置任何东西。

    这可以通过这个选项来改变。它接受一个选项列表，mpv将在播放开始时把这些选项的值重置为初始值。初始值要么是默认值，要么是由设置文件或命令行设置的。

    在某些情况下，这可能不会入预期的那样工作。例如， ``--volume`` 只有在设置文件或命令行中明确设置时才会被重置。

    特殊名称 ``all`` 会重置尽可能多的选项。

    这是一个字符串列表选项。详见 `列表选项`_

    .. admonition:: 示例

        - ``--reset-on-next-file=pause``
          在切换到下一个文件时重置暂停模式
        - ``--reset-on-next-file=fullscreen,speed``
          重置全屏和播放速度设置，如果它们在播放过程中被改变
        - ``--reset-on-next-file=all``
          尝试重置所有在播放过程中被改变的设置

``--show-profile=<profile>``
    显示一个配置预设的描述和内容。如果没有提供参数，则列出所有的配置预设。

``--use-filedir-conf``
    在将要播放的文件的同一目录下查找针对该文件的设置文件。参见 `特定文件的设置文件`_

    .. warning::

        如果从不受信任的媒体中播放可能会有风险。

``--ytdl``, ``--no-ytdl``
    启用youtube-dl hook脚本。它将查看输入的URL，并播放位于该网站上的视频。这适用于许多流媒体网站，而不仅仅是该脚本所命名的网站。这需要在系统上安装一个较新版本的youtube-dl。（默认启用）

    如果该脚本不能处理某个URL，它将不执行任何操作。

    它接受一组选项，可以通过 ``--script-opts`` 选项（使用 ``ytdl_hook-`` 作为前缀）传递给它：

    ``try_ytdl_first=<yes|no>``
        如果 "yes"，将首先尝试用youtube-dl解析URL，而不是默认的在mpv加载失败后才解析。这主要取决于你的大部分URL是否需要youtube-dl解析。

    ``exclude=<URL1|URL2|...``
        一个用 ``|`` 分隔的不使用youtube-dl的URL模式列表。这些模式在URL的 ``http(s)://`` 部分之后被匹配。

        ``^`` 匹配URL的开头， ``$`` 匹配其结尾，你应该在任何 ``^$()%|,.[]*+-?`` 字符之前使用 ``%`` 来匹配该字符。

        .. admonition:: 示例

            - ``--script-opts=ytdl_hook-exclude='^youtube%.com'``
              将排除任何以 ``http://youtube.com`` 或 ``https://youtube.com`` 开头的URL。
            - ``--script-opts=ytdl_hook-exclude='%.mkv$|%.mp4$'``
              将排除任何以 ``.mkv`` 或 ``.mp4`` 结尾的URL。

        在这里可以看到更多的lua模式：https://www.lua.org/manual/5.1/manual.html#5.4.1

    ``all_formats=<yes|no>``
        如果 "yes"，将尝试添加所有由youtube-dl报告的格式（默认： no）。每种格式都作为一个单独的轨道被添加。此外，它们被延迟加载，且实际上只有在选择轨道时才会打开（这应该能使加载时间和没有这个设置选项时一样短）。

        它增加了平均比特率的元数据，如果可获得的话，这表示可以使用 ``--hls-bitrate`` 来决定选择哪条轨道（HLS过去是唯一一种以类似方式公开替代质量流的格式，因此这是选项的名称）。

        代表youtube-dl默认选择的格式的音轨将被设置为dedfault标志。这表示mpv通常仍应选择用 ``--ytdl-format`` 默认选择的格式。

        尽管这种机制使得在运行时切换流成为可能，但由于各种技术原因，它并不适合该目的（它很慢，这无法真正解决）。一般而言，这个选项无用，只是为了显示它的可能性而添加的。

        在做质量/带宽选择时，有两种情况必须考虑：

            1. 完全独立的音频和视频流（类似DASH）。这些流中的每一个都只包含音频或视频，所以可以不受限制地混合和组合音频/视频带宽。这在直觉上与按音轨选择质量的概念最匹配（ ``all_formats`` 的存在缘由）。

            2. 独立的混合音频和视频流的集合。每个版本的媒体都包含音频和视频流，而且它们是交错的。为了不浪费带宽，应该只选择这些版本中的一个（例如，如果选择了一个音频流，那么对应的视频将被下载，即使选择了不同流的视频）。

               mpv仍然将它们表示为单独的轨道，但会将每个轨道的标题设置为 ``muxed-N`` ，其中 ``N`` 被替换为原流的youtube-dl格式的ID。

        有些网站会混合使用1.和2.，但我们假定他们这样做是出于兼容性的考虑，但根本没有理由使用它们。

    ``force_all_formats=<yes|no>``
        如果设置为 "yes"，并且 ``all_formats`` 也设置为 "yes"，这将尝试将所有youtube-dl报告的格式表示为轨道，即使mpv通常会使用它报告的direct URL（默认： yes）。

        如果youtube-dl在一个master HLS播放列表上工作，这通常会有区别。

        如果设置为 "no"，这种特定的流会被当作好像 ``all_formats`` 设置为 "no"，并使用youtube-dl（通过 ``-ytdl-format`` ）进行流的选择。

    ``use_manifests=<yes|no>``
        使mpv使用如HLS和DASH等格式的master manifest URL，如果可获得的话，允许在运行时选择视频/音频（默认： no）。由于性能原因，默认禁用（"no"）。

    ``ytdl_path=youtube-dl``
        设置youtube-dl的可执行文件或兼容的fork文件的路径。路径应该用分隔符，Unix是 ":" 而Windows是 ";" 。mpv在PATH和mpv的设置目录中依次寻找设置的路径。默认的是 "yt-dlp"，"yt-dlp_x86" 和 "youtube-dl"。在Windows上，后缀 ".exe" 总是被追加的。

    .. admonition:: 为什么选项名称混合了 ``_`` 和 ``-`` ？

        我不知道。

``--ytdl-format=<ytdl|best|worst|mp4|webm|...>``
    直接传递给youtube-dl的视频格式/质量。可能的值是针对网站和视频的，对于一个给定的URL，可用的格式可以通过命令 ``youtube-dl --list-formats URL`` 找到。关于可用的别名，参见youtube-dl的文档。（默认： ``bestvideo+bestaudio/best`` )

    ``ytdl`` 的值根本没有向youtube-dl传递 `--format`` 选项，因此没有覆盖其默认值。注意，有时youtube-dl返回的格式是mpv无法使用的，在这种情况下，mpv的默认值可能会更好工作。

``--ytdl-raw-options=<key>=<value>[,<key>=<value>[,...]]``
    传递任意的选项给youtube-dl。参数应该以按键-值成对的形式传递。没有参数的选项必须包括 ``=`` 。

    没有安全检查，所以有可能破坏某些事情（例如，将无效的参数传递给youtube-dl）。

    可以传递一个代理URL，让youtube-dl在解析网站时使用它。这对于有地理限制的URL很有用。在youtube-dl解析后，一些URL也需要代理来播放，所以这可以把代理信息传递给mpv。请注意，SOCKS代理不被支持，https的URL也会绕过代理。这是FFmpeg的一个限制。

    这是一个按键/值列表选项。详见 `列表选项`_

    .. admonition:: 示例

        - ``--ytdl-raw-options=username=user,password=pass``
        - ``--ytdl-raw-options=force-ipv6=``
        - ``--ytdl-raw-options=proxy=[http://127.0.0.1:3128]``
        - ``--ytdl-raw-options-append=proxy=http://127.0.0.1:3128``

``--load-stats-overlay=<yes|no>``
    启用内置脚本，在一个按键绑定上显示有用的播放信息（默认： yes）。默认情况下，使用 ``i`` 键（ ``I`` 键使覆盖层永久化）。

``--load-osd-console=<yes|no>``
    启用内置脚本，在一个按键绑定上显示控制台，可让你输入命令（默认： yes）。在默认情况下， ````` 键用于显示控制台， ``ESC`` 键用于再次隐藏它。

``--load-auto-profiles=<yes|no|auto>``
    启用内置脚本，进行自动配置预设（默认： ``auto`` ）。详见 `附带条件的自动配置预设`_ 。 ``auto`` 将加载脚本，但如果不存在附带条件的自动配置预设，则立即卸载它。

``--player-operation-mode=<cplayer|pseudo-gui>``
    用于启用“伪GUI模式”，这表示一些选项的默认值被改变。这个选项通常不应该直接使用，而应该由mpv内部使用，或者由mpv提供的脚本、设置文件或.desktop文件。详见 `伪GUI模式`_

稍后观看
--------

``--save-position-on-quit``
    在退出时总是保存当前的播放位置。当以后再次播放该文件时，播放器会在开始时跳转到之前的播放位置。如果以任何其他方式停止一个文件的播放而不是退出，这种情况不会发生。例如，前往播放列表中的下一个文件不会保存位置，而是在下次播放该文件时从头开始播放。

    这种行为默认是禁用的，但当用Shift+Q退出播放器时，总是可用的。

``--watch-later-directory=<path>``
    存储“稍后观看”临时文件的目录。

    如果不设置该选项，临时文件将被存储在本地的状态目录（通常是 ``~/.local/state/mpv/`` ）下的一个名为 "watch_later "的子文件夹中。

``--no-resume-playback``
    不要从设置子目录 ``watch_later`` （通常是 ``~/.config/mpv/watch_later/`` ）恢复播放位置。参见 ``quit-watch-later`` 输入命令。

``--resume-playback-check-mtime``
    如果文件的修改时间与保存时间相同，只恢复设置子目录 ``watch_later`` （通常是 ``~/.config/mpv/watch_later/`` ）中的播放位置。这可以阻止同名但内容不同的文件向后跳过。（默认： ``no`` ）

``--watch-later-options=option1,option2,...``
    如果选项在mpv启动后被改变，它们将被保存在 "watch_later" 里的文件中。这些值将在下次播放文件时被恢复。注意，播放位置是通过 ``start`` 项保存的。

    当移除选项时，已有的稍后观看的数据不会被修改，仍然会被完全应用，但是新的稍后观看的数据将不包含这些选项。

    这是一个字符串列表选项。详见 `列表选项`_

    .. admonition:: 示例

        - ``--watch-later-options-remove=fullscreen``
          全屏状态不会被保存到稍后观看的文件中
        - ``--watch-later-options-remove=volume``
          ``--watch-later-options-remove=mute``
          音量和静音状态不会被保存到稍后观看的文件中
        - ``--watch-later-options-clr``
          没有项目将被保存到稍后观看的文件中

``--write-filename-in-watch-later-config``
    在稍后观看的设置文件前加上它们所指的文件名。这只是作为注释简单的写入在文件的顶部。

    .. warning::

        这个选项可能会暴露隐私敏感信息，因此默认禁用。

``--ignore-path-in-watch-later-config``
    在使用稍后观看功能时忽略路径（即只使用文件名）。（默认： no）

视频
----

``--vo=<driver>``
    指定要使用的视频输出后端。详见 `视频输出驱动`_ 以了解可用驱动程序的描述。

``--vd=<...>``
    根据视频解码器的族和名称，指定要使用的视频解码器的优先列表。详见 ``--ad`` 。这两个选项使用相同的语法和语义；唯一的区别是它们对不同的解码列表进行操作。

    .. note::

        参见 ``--vd=help`` 了解可用解码器的完整列表。

``--vf=<filter1[=parameter1:parameter2:...],filter2,...>``
    指定一个视频滤镜的列表，应用于视频流。详见 `视频滤镜`_ 了解可用滤镜的描述。选项变体 ``--vf-add``, ``--vf-pre``, ``--vf-del`` 和 ``--vf-clr`` 的存在是为了修改先前指定的列表，但在典型使用中应该不需要这些。

``--untimed``
    在输出视频帧时不休眠。当与 ``--no-audio`` 一起使用时，对基准测试有用。

``--framedrop=<mode>``
    在速度慢的系统上，或者在有帧数上限的视频输出上播放高帧率的视频时，跳过显示一些帧来维持A/V同步。

    该参数选择丢帧的方式，可以是下列之一：

    <no>
        禁用任何丢帧。不推荐，仅用于测试。
    <vo>
        在视频输出中丢弃落后的帧（默认）。这仍然对所有帧进行解码和过滤，但不在视频输出中渲染它们。丢弃的帧在终端状态行中显示在 ``Dropped:`` 字段。

        在音频同步的模式下，这将丢弃在显示时已经过期的帧。如果解码器太慢，理论上所有的帧都会被丢弃（因为所有的帧都太晚） —— 为了避免这种情况，如果有效帧率低于10FPS，则停止丢帧。

        在显示同步模式下（参见 ``--video-sync`` ），这只影响A/V丢帧或帧重复的方式。如果该模式被禁用，A/V不同步理论上不会再影响视频调度（很像 ``display-resample-desync`` 模式）。然而，即使禁用，帧仍然会根据视频和显示频率之间的比例被跳过（即丢帧）。

        这是推荐的模式，也是默认的模式。
    <decoder>
        旧的、基于解码器的丢帧模式（这与mpv0.5.x及之前版本中的 ``--framedrop=yes`` 相同）。这告诉解码器跳过帧（除非需要它们来解码未来的帧）。可能对慢速系统有帮助，但可能产生无法观看的不稳定输出，甚至完全冻结显示。

        这使用了一种可能没有意义的启发式方法，而且一般来说不能获得良好的结果，因为解码器的丢帧不能以一种可预测的方式控制。不推荐。

        即使你想使用这个，也最好选择 ``decoder+vo`` 以获得更好的结果。

        ``--vd-lavc-framedrop`` 选项控制要丢掉哪些帧。
    <decoder+vo>
        启用两种模式。不推荐。但比只有 ``decoder`` 的模式好。

    .. note::

        ``--vo=vdpau`` 有自己的代码用于 ``vo`` 丢帧的模式。与其它的视频输出驱动可能有轻微的不同。

``--video-latency-hacks=<yes|no>``
    启用一些倾向于减少1或2帧视频延迟的东西（默认： no）。请注意，一旦播放器的计时代码不再需要做这些事情，这个选项可能会被移除而不另行通知。

    它的操作：

    - 使用解复用器报告的FPS进行丢帧。这避免了播放器需要提前解码1帧，有效地降低了总延迟。这也表示，如果解复用器报告的FPS是错误的，或者视频滤镜链改变了FPS（例如去隔行扫描），那么它就可能丢弃太多或不够的帧数。
    - 禁用等待第一个视频帧。通常情况下，播放器会等待第一个视频帧被完全渲染后再开始正常播放。一些视频输出驱动会在渲染第一帧时懒散地初始化一些东西，所以如果不这样做，如果渲染第一帧的时间太长超过需求，视频输出就不得不丢弃一些帧。

``--override-display-fps=<fps>``
    设置与 ``--video-sync=display-*`` 模式一起使用的显示FPS。默认情况下，使用一个检测值。请记住，设置一个不正确的值（即使是轻微的错误）可能会破坏视频播放。在多显示器系统中，有可能检测到的值来自错误的显示器。

    只有在你有理由相信自动检测的数值是错误的情况下才设置这个选项。

``--display-fps=<fps>``
    过时的 ``--overrid-display-fps`` 的别名。

``--hwdec=<api1,api2,...|no|auto|auto-safe|auto-copy>``
    如果可能的话，指定应该使用的视频硬件解码API。硬解码是否实际完成取决于视频编码。如果硬件解码不可能，mpv将回退到软件解码。

    硬件解码在默认情况下是不启用的，目的是保持开箱即用的设置尽可能的可靠。然而，当使用现代硬件时，硬解码应该能正常工作，提供更低的CPU使用率，并可能减少功耗。在老旧系统上，由于CPU资源不足，可能有必要使用硬解码；即使在现代系统上，足够复杂的内容（例如4K60 AV1）也可能需要它。

    .. note::

        使用 ``Ctrl+h`` 快捷键来在运行时切换硬解码。它在 ``auto`` 和 ``no`` 之间切换这个选项。

        如果你决定默认使用硬件解码，一般的建议是用命令行选项尝试解码，并向自己证明它对你关注的内容有理想的效果。在此之后，你可以把它添加到你的设置文件中。

        在测试时，你应该先使用 ``hwdec=auto-safe`` ，因为它将限制自己从开发团队积极支持的hwdec中选择。如果这并没有产生有效的硬解码，你可以尝试 ``hwdec=auto`` 让它尝试加载所有可能的hwdec，但是如果 ``auto-safe`` 无法工作，你可能需要知道哪种hwdec与你的硬件匹配，并阅读下方的条目。

        如果 ``auto-safe`` 或 ``auto`` 产生了期待的结果，我们建议只需坚持使用它，如果确实有必要，只在你的设置文件中设定一个特定的hwdec。

        如果你使用Ubuntu软件包，请记住他们的 ``/etc/mpv/mpv.conf`` 包含 ``hwdec=vaapi`` ，这不是很理想，因为它对你的系统来说可能不是正确的选择，而且它可能最终使用一个低效的wrapper来掩饰。我们建议删除这一行或完全删除该文件。

    .. note::

        即使启用，硬解码仍然只对某些编码开放白名单。在更多的情况下启用硬解码，参见 ``--hwdec-codecs``

    .. admonition:: 选择哪种方式？

        - 如果只想在运行时启用硬件解码，不要设置参数，或者在 ``mpv.conf`` 中加入 ``hwdec=no`` （与某些在默认情况下强制启用的发行版相关，比如Ubuntu）。使用默认绑定 ``Ctrl+h`` 在运行时启用它。
        - 如果不确定，但希望硬件解码在默认情况下被启用，可以在 ``mpv.conf`` 中加入 ``hwdec=auto-safe`` ，并认识到可能会导致问题。
        - 如果想测试可用的硬件解码方式，传递 ``--hwdec=auto --hwdec-codecs=all`` ，查看终端的输出。
        - 如果你是一个开发者，或者想进行详细的测试，可能需要其它任何可能的选项值。

    该选项接受一个以逗号分隔的 ``api`` 类型的列表，以及某些特殊值：

    :no:                始终使用软件解码（默认）
    :auto:              强制启用任何已找到的hw解码器（见下文）
    :yes:               与 ``auto`` 完全相同
    :auto-safe:         启用任何白名单中的hw解码器（见下文）
    :auto-copy:         启用最佳的带copy-back的hw解码器（见下文）

    .. note::

        特殊值可以与api名称混合。例如： ``vaapi,auto`` 将尝试使用 ``vaapi`` ，如果失败，再运行一般的 ``auto`` 逻辑。

    受到积极支持的hwdec：

    :d3d11va:           需要 ``--vo=gpu`` 与 ``--gpu-context=d3d11`` 或 ``--gpu-context=angle`` （Windows 8以上独占）
    :d3d11va-copy:      将视频复制回到系统RAM（Windows 8以上独占）
    :videotoolbox:      需要 ``--vo=gpu`` （macOS 10.8及以上）或 ``--vo=libmpv`` （iOS 9.0及以上）
    :videotoolbox-copy: 将视频复制回到系统RAM（macOS 10.8或iOS 9.0及以上版本）
    :vaapi:             需要 ``--vo=gpu`` 或 ``--vo=vaapi`` 或 ``--vo=dmabuf-wayland`` （Linux独占）
    :vaapi-copy:        将视频复制回到系统RAM（Linux独占，且仅某些GPU可用）
    :nvdec:             需要 ``--vo=gpu`` （任何可用CUDA的平台）
    :nvdec-copy:        将视频复制回到系统RAM（任何可用CUDA的平台）
    :drm:               需要 ``--vo=gpu`` （Linux独占）
    :drm-copy:          将视频复制回到系统RAM（Linux独占）
    :vulkan:            需要 ``--vo=gpu-next`` （任何带有Vulkan视频解码的平台）
    :vulkan-copy:       将视频复制回到系统RAM（任何带有Vulkan视频解码的平台）

    其它的hwdec（只有当你了解不得不做时才使用）：

    :dxva2:             需要 ``--vo=gpu`` 与 ``--gpu-context=d3d11`` 或 ``--gpu-context=angle`` 或 ``--gpu-context=dxinterop`` （Windows独占）
    :dxva2-copy:        将视频复制回到系统RAM（Windows独占）
    :vdpau:             需要 ``--vo=gpu`` 和X11，或 ``--vo=vdpau`` （Linux独占）
    :vdpau-copy:        将视频复制回到系统RAM（Linux独占，且仅某些GPU可用）
    :mediacodec:        需要 ``--vo=gpu`` 与 ``--gpu-context=android`` ，或 ``--vo=mediacodec_embed`` （Android独占）
    :mediacodec-copy:   将视频复制回到系统RAM（Android独占）
    :mmal:              需要 ``--vo=gpu`` （树莓派独占 —— 如果可用则默认）
    :mmal-copy:         将视频复制回到系统RAM（树莓派独占）
    :cuda:              需要 ``--vo=gpu`` （任何可用CUDA的平台）
    :cuda-copy:         将视频复制回到系统RAM（任何可用CUDA的平台）
    :crystalhd:         将视频复制回到系统RAM（任何受硬件支持的平台）
    :rkmpp:             需要 ``--vo=gpu`` （部分RockChip设备独占）

    ``auto`` 尝试使用第一个可用的方式来自动启用硬解码。这仍然取决于所使用的是什么视频输出驱动。例如，如果没有使用 ``--vo=gpu`` 或 ``--vo=vdpau`` ，vdpau解码将永不会被启用。还要注意的是，如果第一个找到的方式在实际情况中无法工作，它将总是回退到软解，而不是尝试下一个方式（在一些Linux系统上可能很重要）。

    ``auto-safe`` 与 ``auto`` 类似，但只允许白名单中的被认为是“安全”的方式。这应该是在设置文件中默认启用硬解的一种合理方式（尽管你不应该这样做；最好在运行时用 ``Ctrl+h`` 启用）。不像 ``auto`` ，它不会尝试启用未知或已知的损坏的方式。此外，在其它已知会导致问题的情况下，这可能会禁用硬解，但目前这个机制是相当原始的（作为一个仍然会引发问题的例子：Windows上HEVC和Intel芯片的某些组合往往会导致mpv崩溃，很可能是由于驱动的错误）。

    ``auto-copy-safe`` 选择了联合 ``auto-safe`` 和 ``auto-copy`` 的方式。

    ``auto-copy`` 只选择在解码后将视频数据复制回到系统内存的模式。这就选择了像  ``vaapi-copy`` （等等）这样的模式。如果这些都无效，硬解就会被禁用。这种模式通常保证，与软解相比不会产生额外的质量损失（假定视频流是现代的编码且无错误），并将允许由CPU处理的视频滤镜。这种模式适用于所有视频滤镜和视频输出驱动。

    因为这些模式把解码后的视频复制回到系统RAM，它们的效率往往不如直接模式，如果你的CPU资源不足，可能对软解没有太大帮助。

    .. note::

       大多数non-copy的方式只在OpenGL GPU后端工作。目前，只有 ``vaapi`` 、 ``nvdec`` 和 ``cuda`` 方式能在Vulkan上工作。

    ``vaapi`` 模式，如果与 ``--vo=gpu`` 一起使用，需要Mesa 11，并且很可能只适用于Intel和AMD的GPU。它还需要opengl EGL后端。

    ``nvdec`` 和 ``nvdec-copy`` 是最新的方式，建议在Nvidia GPU上进行硬解。

    ``cuda`` 和 ``cuda-copy`` 是在Nvidia GPU上进行硬解的老旧实现，使用Nvidia的比特流解析器，而不是FFmpeg的。这可能导致功能上的缺失，比如HDR内容的错误播放， ``nvdec`` / ``nvdec-copy`` 应始终是首选，除非特别需要Nvidia的去隔行扫描算法。要使用这种反交错，必须传递选项： ``vd-lavc-o=deint=[weave|bob|adaptive]`` 。传递 ``weave`` （或不设置该选项）来不尝试任何反交错。

    .. admonition:: 硬件解码的质量降级

        理论上，硬解不会降低视频质量（至少对于h264和HEVC编码是这样）。然而，由于视频输出API的限制，以及实际硬件解码器的错误，可能会有一些损失，甚至是非常不正确的结果。这在很大程度上已经不再是现代硬件的问题，但仍有很多硬件不在此范围内，所以要注意。下面讨论了已知的问题，但不能认为这个清单是详尽的，因为即使是在某一代硬件上运行良好的hwdec，在其它型号上也可能有问题。

        在某些情况下，RGB转换是强制的，这表示RGB转换是由硬件解码API执行的，而不是由 ``--vo=gpu`` 使用的着色器。这意味着某些色彩空间可能无法正确显示，而且某些过滤（比如去色带）不能以理想的方式应用。这通常也会迫使用低质量的色度缩放器，而不是由 ``--cscale`` 指定的。在其它情况下，硬解也会降低解码后图像的位深，对于10-bit的文件来说，会引入色带或精度损失。

        ``vdpau`` 始终在硬件中进行RGB转换，它不能正确支持较新的色彩空间，如BT.2020。然而， ``vdpau`` 不支持10比特或HDR编码，所以这些限制不太可能是相关的。

        ``dxva2`` 是不安全的。它似乎总是使用BT.601进行强制RGB转换，但实际行为取决于GPU驱动程序。一些驱动程序似乎会转换为有限范围的RGB，这给人一种褪色的感觉。除了特定驱动程序的行为外，全局系统设置可能也会影响到这一点。即使是完全普通的视频源，这也可能会给出不正确的结果。

        ``rpi`` 始终使用硬件叠加层渲染器，即使使用 ``--vo=gpu`` 。

        ``mediacodec`` 是不安全的。 它强制进行RGB转换（非 ``-copy`` ），它对非标准色彩空间的处理效果如何还不清楚。在极少数支持10位的情况下，输出的位深度将被降低到8。

        ``cuda`` 通常是安全的，但取决于文件/流的混合方式，据报告它会破坏时间戳，导致帧闪烁。它有时也会因不明原因而引起大量的丢帧。建议谨慎使用， ``nvdec`` 应该始终是优选。

        ``crystalhd`` 不安全。它总是转换为4:2:2 YUV，这可能是有损的，取决于转换过程中如何进行色度抽样。出于某种原因，它还会丢弃每一帧的左上角像素。

        如果你遇到任何奇怪的解码问题，帧故障或变色，并且你启用了 ``--hwdec`` ，你应该首先尝试禁用它。

``--gpu-hwdec-interop=<auto|all|no|name>``
    这个选项是用来排除硬解interop问题的。由于它是一个调试选项，它的语义可能在任何时候改变。

    这对 ``gpu`` 和 ``libmpv`` 视频输出驱动很有用，可以准确选择使用哪个硬解interop context。它也可以用来有效的阻止某些后端的加载。

    如果设置为 ``auto`` （默认），其行为取决于视频输出驱动：对于 ``gpu`` ，它不做任何事情，interop context在有需求时被加载（当解码器探测到 ``--hwdec`` 支持时）。对于没有按需加载的 ``libmpv`` ，这相当于 ``all`` 。

    空字符串等同于 ``auto`` 。

    如果设置为 ``all`` ，它尝试在GL context创建时加载所有的interop contexts。

    除此以外，可以设置特定的后端，且可以用 ``help`` 查询它们的列表（仅mpv CLI可用）。

    在运行时对此的更改会被忽略（每当渲染器被创建时都会使用当前的选项值）。

    旧的别名 ``--opengl-hwdec-interop`` 和 ``--hwdec-preload`` 与此几乎没有关系了，但在某些情况下将会有一定的兼容性。

``--hwdec-extra-frames=<N>``
    硬件解码应该预分配的GPU帧数（默认：参见 ``--list-options`` 的输出）。如果这个数值太低，在解码过程中帧分配可能会失败，视频帧可能会被丢弃或破坏。设置太高则只是浪费显存，没有任何好处。

    这个值只用于需要预先分配surfaces的硬解API（已知的例子包括 ``d3d11va`` 和 ``vaapi`` ）。对于其它API，帧是按需分配的。细节取决于硬件解码器的libavcodec实现。

    所需的surfaces数取决于动态运行时的状况。默认值是一个固定值，被认为对大多数用途来说是足够的。但在某些情况下，它可能是不够的。

``--hwdec-image-format=<name>``
    通过 ``--hwdec`` 设置硬解使用的内部像素格式（默认： ``no`` ）。特殊值  ``no`` 选择一个特定于实现的标准格式。大多数解码器实现只支持一种格式，如果不支持某格式，将初始化失败。

    有些实现可能支持多种格式。特别的是，已知videotoolbox需要 ``uyvy422`` 以便在一些旧的硬件上获得良好的性能。d3d11va可能始终使用 ``yuv420p`` ，这使用不透明的格式，可能没有优势。

``--cuda-decode-device=<auto|0..>``
    在使用OpenGL GPU后端的 ``cuda`` 或 ``nvdec`` 硬解时选择用于解码的GPU设备，在使用 ``cuda-copy`` 或 ``nvdec-copy`` 硬解时的所有情况也是如此。

    对于OpenGL GPU后端，用于解码的默认设备是被用来提供 ``gpu`` 输出的设备（在绝大多数情况下，只有一个GPU会呈现）。

    对于 ``copy`` 硬解，默认设备将是CUDA库所枚举的第一个设备 —— 无论如何都是如此。

    对于Vulkan GPU后端，解码必须始终发生在显示设备上，这个选项没有影响。

``--vaapi-device=<device file>``
    为 ``vaapi-copy`` 选择DRM设备。这应该是一个DRM设备文件的路径。（默认： ``/dev/dri/renderD128`` ）

``--panscan=<0.0-1.0>``
    启用平移和扫描功能（例如，裁剪16:9视频的两侧，使其适合4:3的显示器而没有黑边）。范围控制图像被裁剪的程度。可能不适用于所有的视频输出驱动。

    如果使用了选项 ``--video-unscaled`` ，这个选项就没有作用。

``--video-aspect-override=<ratio|no>``
    覆盖视频长宽比，以防播放的文件中长宽比信息不正确或缺失。

    这些值有特殊含义：

    :0:  禁用长宽比处理，假设视频是方形像素
    :no: 与 ``0`` 相同
    :-1: 使用视频流或容器的长宽（默认）

    但请注意，对这些特殊值的处理在未来可能会改变。

    .. admonition:: 示例

        - ``--video-aspect-override=4:3`` 或 ``--video-aspect-override=1.3333``
        - ``--video-aspect-override=16:9`` 或 ``--video-aspect-override=1.7777``
        - ``--no-video-aspect-override`` 或 ``--video-aspect-override=no``

``--video-aspect-method=<bitstream|container>``
    这设置了默认的视频长宽决定方法（如果长宽 _没有_ 被用户用 ``--video-aspect-override`` 或其它方式覆盖）。

    :container: 严格倾向于容器的长宽比。这显然是VLC的默认行为，至少在Matroska中是如此。请注意，如果容器没有设置长宽比，其行为与比特流相同
    :bitstream: 严格倾向于比特流长宽比，除非没有设置比特流长宽比。这显然是XBMC/kodi的默认行为，至少对Matroska是这样

    目前mpv的默认值是 ``container``

    通常情况下，你不应该设置这个。如果遇到的视频在mpv里有错误的长宽比，但在其它播放器里似乎是正确的，请尝试各种选择。

``--video-unscaled=<no|yes|downscale-big>``
    禁用视频的缩放功能。如果窗口比视频大，就会添加黑条。否则，视频将被裁切，除非该选项被设置为 ``downscale-big`` ，在这种情况下，视频将匹配窗口。视频仍然可以受到其他 ``--video-...`` 选项的影响。该选项禁用了 ``--panscan`` 的效果。

    请注意，即使视频没有被缩放，缩放器的算法仍然可能被使用。例如，这可能影响色度转换。如果视频源使用非正方形像素（例如变形宽屏DVD），视频也将在一个通道上被缩放。

    如果使用 ``--no-keepaspect`` 选项，该选项将被禁用。

``--video-pan-x=<value>``, ``--video-pan-y=<value>``
    将显示的视频矩形在X或Y方向移动给定的值。单位是缩放后的视频尺寸的分数（全尺寸，即使视频的部分内容由于panscan或其它选项不可见）。

    例如，在1680x1050的屏幕上全屏显示1280x720的视频，使用 ``--video-pan-x=-0.1`` 会将视频向左移动168像素（使源视频的128像素不可见）。

    如果使用 ``--no-keepaspect`` 选项，该选项将被禁用。

``--video-rotate=<0-359|no>``
    顺时针旋转视频，单位是度。如果给了 ``no`` ，视频就永远不会旋转，即使文件有旋转元数据（旋转值被添加到旋转元数据中，这意味着 ``0`` 值将根据旋转元数据旋转视频）。

    当使用没有copy-back的硬件解码时，只有90°的步幅可以工作，而软解和将视频复制回到系统内存的硬解方式支持0和359之间的所有值。

``--video-zoom=<value>``
    按给定值调整视频显示缩放。该参数是给定的对数2。例如， ``--video-zoom=0`` 是不缩放， ``--video-zoom=1`` 是两倍尺寸， ``--video-zoom=-2`` 是四分之一，以此类推。

    如果使用了 ``--no-keepaspect`` 选项，该选项将被禁用。

``--video-scale-x=<value>``, ``--video-scale-y=<value>``
    将视频显示尺寸与给定值相乘（默认： 1.0）。如果使用非默认值，这将与窗口尺寸不同，所以视频将被切断，或加入黑条。

    这个值与从 ``--video-zoom`` 得出的值和正常的视频宽高比相乘。如果使用 ``--no-keepaspect`` 选项，该选项将被禁用。

``--video-align-x=<-1-1>``, ``--video-align-y=<-1-1>``
    在黑色边框内移动视频矩形，如果视频和屏幕的长宽比不同，通常会添加黑色边来填充视频到屏幕。 ``--video-align-y=-1`` 会将视频移到屏幕顶部（只在底部留有边框），数值为 ``0`` 会将其居中（默认），数值为 ``1`` 会将视频放在屏幕底部。

    如果视频和屏幕的长宽比完全匹配，这些选项没有任何作用。

    如果使用了 ``--no-keepaspect`` 选项，该选项将被禁用。

``--video-margin-ratio-left=<val>``, ``--video-margin-ratio-right=<val>``, ``--video-margin-ratio-top=<val>``, ``--video-margin-ratio-bottom=<val>``
    在每条边上设置额外的视频边距（默认： 0）。每个值是窗口大小的比率，使用的范围是0.0-1.0。例如，在窗口大小为1000像素时，设置选项 ``--video-margin-ratio-right=0.2`` ，将在窗口的右边增加200像素的边框。

    视频会被这些边距“框住”。窗口的大小不改变。特别是它不会放大窗口，而且边距会引起视频默认被缩小。这在将来可能会也可能不会改变。

    边距是在视频旋转90°后应用的，但在任何其它视频转换之前。

    如果使用了 ``--no-keepaspect`` 选项，该选项将被禁用。

    字幕仍然可以使用这些边距，取决于 ``--sub-use-margins`` 及类似的选项。

    这些选项是为OSC创建的。一些奇怪的决定是为了OSC而作出的，例如使边距值成为一个比率（而不是像素）。这些选项有可能被那些更普遍有用的选项所取代。这些选项的行为也可能改变，以更好的适应OSC的要求。

``--correct-pts``, ``--no-correct-pts``
    ``--no-correct-pts`` 将mpv切换到使用固定帧率值（使用 ``--fps`` 选项，或使用文件信息）来确定视频计时的模式。有时，在这种模式下，具有非常破碎的时间戳的文件可以得到一定程度的播放。请注意，在这种模式下，视频滤镜、字幕渲染、跳转（包括精确跳转和帧步退）和音频同步可能完全被破坏。

``--fps=<float>``
    覆盖视频帧速率。如果原始值是错误的或缺失的，则很有用。

    .. note::

        只在 ``--no-correct-pts`` 模式下工作。

``--deinterlace=<yes|no>``
    启用或禁用隔行扫描（默认： no）。隔行扫描的视频会出现丑陋的梳状伪影，在快速移动时可见。启用这个功能通常会插入yadif视频滤镜，以便对视频进行去隔行扫描，或者如果支持的话，让视频输出应用去隔行扫描。

    这和 ``deinterlace`` 输入属性（通常映射到 ``d`` ）的行为完全一样。

    请记住，这 **会** 与手动插入的反交错滤镜冲突，除非你注意使用（从mpv0.27.0开始，即使是硬件去交错滤镜也会发生冲突。也是从那个版本开始， ``--deinterlace=auto`` 被移除了，这表示可能插入的视频滤镜的默认隔行扫描选项被使用）。

    请注意，如果视频实际上不是隔行扫描，这将使视频看起来更糟。

``--frames=<number>``
    只播放/转换视频的前 ``<number>`` 帧，然后退出。

    ``--frames=0`` 表示加载文件，但在初始化播放前立即退出（可能对那些只想确定一些文件属性的脚本很有用）。

    对于纯音频的播放，任何大于0的值都会在初始化后立即退出播放。值0的行为和视频一样。

``--video-output-levels=<outputlevels>``
    用于YUV到RGB转换的RGB动态范围。通常情况下，输出设备比如PC显示器使用全范围的动态范围。然而，一些电视和视频监视器希望使用studio RGB范围。向期望studio级别输入的设备提供全范围输出，会导致黑点和白点的破坏，反之则会导致黑色和白色的发灰。

    并非所有的视频输出驱动都支持这个选项。有些会无声的忽略它。

    可用的颜色范围是：

    :auto:      自动选择（等于全范围）（默认）
    :limited:   有限范围（每个分量16-235），studio 级别
    :full:      全范围（每个分量0-255），PC级别

    .. note::

        建议使用你图形驱动的动态范围的选项，如果可用的话。

``--hwdec-codecs=<codec1,codec2,...|all>``
    只允许对一个给定的编码列表进行硬件解码。特殊值 ``all`` 总是允许所有的编码。

    可以用 ``mpv --vd=help`` 获得允许的编码列表。移除前缀，例如，用 ``h264`` 代替 ``lavc:h264`` 

    默认情况下，这被设置为 ``h264,vc1,hevc,vp8,vp9,av1,prores`` 。请注意，像 ``h264_vdpau`` 这样的硬件加速的特殊编码已经没有意义了，事实上已经从Libav中移除了这种形式。

    通常只有在损坏的GPU上才需要这样做，在这种情况下，一个编码被报告为支持，但解码导致的问题比它解决的问题更多。

    .. admonition:: 示例

        ``mpv --hwdec=vdpau --vo=vdpau --hwdec-codecs=h264,mpeg2video``
            只对h264和mpeg2启用vdpau解码。

``--vd-lavc-check-hw-profile=<yes|no>``
    检查硬件解码器的profile（默认： yes）。如果设置了 ``no`` ，就会无条件地选择硬件解码器的最高profile，即使视频的profile高于此，也会强制解码。其结果很可能是解码错误，但如果检测到的或报告的profile在某种程度上不正确，也可能有帮助。

``--vd-lavc-software-fallback=<yes|no|N>``
    如果硬件加速解码器失败，退回到软件解码（默认：3）。如果这是一个数字，那么如果连续N个帧解码失败，就会触发回退。1相当于 ``yes``

    设置为更高的数字可能会破坏播放开始时的回退：如果回退发生，文件的部分内容将被跳过，这大约是无法解码的packets的数量。低于一个未指定计数的值不会有这个问题，因为mpv保留了这些packets。

``--vd-lavc-film-grain=<auto|cpu|gpu>``
    启用GPU上的胶片颗粒应用。如果视频解码是在CPU上完成的，在GPU上做胶片颗粒应用可以加速解码。该选项也有助于硬件解码，因为它可以减少帧拷贝的数量。

    默认情况下，它被设置为 ``auto`` ，所以如果VO支持胶片颗粒应用，那么它将被视为 ``gpu`` 。如果VO不支持这个，那么不论设置的值是什么，它将被视为 ``cpu`` 。当前，只有 ``gpu-next`` 支持胶片颗粒应用。

``--vd-lavc-dr=<auto|yes|no>``
    启用直接渲染（默认： auto）。如果设置为 ``yes`` ，视频将被直接解码到GPU video memory（或暂存缓冲区）。这可以加快视频上传速度，对高分辨率或慢速硬件可能有帮助。这只适用于以下的视频输出驱动：

        - ``gpu`` : 需要至少OpenGL 4.4或Vulkan
        - ``libmpv`` : libmpv渲染API有可选的支持

    ``auto`` 项将尝试猜测DR是否能在你的特定硬件上提高性能。当前，如果使用OpenGL，它会对AMD或NVIDIA启用，如果使用Vulkan，则无条件地启用。

    使用任何类型的写入到图像数据（或输出新分配的帧）的视频滤镜都会默默的禁用DR代码路径。

``--vd-lavc-bitexact``
    在所有解码步骤中只使用bit-exact的算法（用于测试编码）。

``--vd-lavc-fast`` （MPEG-1/2和H.264独占）
    启用不符合格式规范并可能导致问题的优化，比如简化的dequantization，简化的 motion compensation，假设使用默认的quantization matrix，假设为YUV 4:2:0，跳过一些检查来检测损坏的比特流。

``--vd-lavc-o=<key>=<value>[,<key>=<value>[,...]]``
    向libavcodec解码器传递AVOptions。注意，欢迎打一个补丁，使 ``o=`` 不需要通过AVOption系统传递所有未知的选项。AVOptions的完整列表可以在FFmpeg手册中找到。

    一些曾经是直接选项的选项可以通过这个机制来设置，比如 ``bug``, ``gray``, ``idct``, ``ec``, ``vismv``, ``skip_top`` （原 ``st`` ）, ``skip_bottom`` （原 ``sb`` ）, ``debug``

    这是一个按键/值列表选项。详见 `列表选项`_

    .. admonition:: 示例

        ``--vd-lavc-o=debug=pict``

``--vd-lavc-show-all=<yes|no>``
    显示即使是破损/毁坏的帧（默认： no）。如果这个选项被设置为no，libavcodec将不会输出在初始关键帧被解码之前的被解码的帧，或者被识别为损坏的帧。

``--vd-lavc-skiploopfilter=<skipvalue>`` （H.264和HEVC独占）
    在解码期间跳过loop滤镜（又名deblocking）。由于过滤后的帧应该被用作解码附属帧的参考，这对质量的影响比不对MPEG-2视频进行deblocking更糟糕。但至少对于高比特率的HDTV来说，这提供了一个很大的加速，而几乎没有明显的质量损失。H.264或HEVC以外的编解码器可能部分支持这个选项 (通常只有 ``all`` 和 ``none`` )。

    ``<skipvalue>`` 可以是以下的一种：

    :none:    从不跳过
    :default: 跳过无用的处理步骤（例如AVI中的0尺寸的packets）
    :nonref:  跳过没有参考的帧（例如不用于解码其他帧，错误不能“累积”）
    :bidir:   跳过B帧
    :nonkey:  跳过所有帧，除了关键帧
    :all:     跳过所有帧

``--vd-lavc-skipidct=<skipvalue>`` （MPEG-1/2/4独占）
    跳过IDCT步骤。这在几乎所有情况下都会使质量下降很多。（可用的skip值参见skiploopfilter）

``--vd-lavc-skipframe=<skipvalue>``
    完全跳过帧的解码。加速很大，但动作生硬，有时会出现不良伪影。（可用的skip值参见skiploopfilter）

``--vd-lavc-framedrop=<skipvalue>``
    设置与 ``--framedrop`` 一起使用的成帧掠夺模式。（可用的skip值参见skiploopfilter）

``--vd-lavc-threads=<N>``
    解码时使用的线程数。实际是否支持线程取决于编码（默认： 0）。0表示自动检测机器上的核心数并使用该数，最多为16。你可以手动设置16个以上的线程。

``--vd-lavc-assume-old-x264=<yes|no>``
    假定视频是由一个旧的、有问题的x264版本压制的（默认： no）。通常情况下，这是由libavcodec自动检测的。但是如果比特流不包含x264版本信息（或者以某种方式被跳过），并且该流实际上是由旧的x264（build 150或更早的）版本压制的，并且如果该流使用 4:4:4 色度，那么libavcodec将默认显示损坏的视频。这个选项将libavcodec的 ``x264_build`` 选项设置为 ``150`` ，这表示如果流不包含版本信息，或者根本不是由x264压制的，它就会假定它是由旧版本压制的。如果你想让你损坏的文件正常工作，启用这个选项是非常安全的，但是理论上这可能会破坏不是由x264压制的流，或者如果由较新的x264版本压制的流不包含版本信息。

``--swapchain-depth=<N>``
    允许最多N个in-flight的帧。这实质上控制了帧的延迟。增加交换链深度可以改善管线并防止错过垂直同步，但会增加可见的延迟。这个选项只规定了一个上限，该实现可以使用比内部请求更低的延迟。设置为1表示视频输出驱动将等待每一帧变为可见，再开始渲染下一帧。（默认： 3）

音频
----

``--audio-pitch-correction=<yes|no>``
    如果启用这个功能（默认），以不同于正常的速度播放时会自动插入 ``scaletempo2`` 音频滤镜。详见音频滤镜部分。

``--audio-device=<name>``
    使用给定的音频设备。这由音频输出的名称组成，例如 ``alsa`` ，后面接 ``/`` ，然后接音频输出的具体设备名称。这个选项的默认值是 ``auto`` ，它以默认设备的优先顺序尝试每个音频输出。

    你可以用``--audio-device=help`` 列出音频设备。这将输出带引号的设备名称，后面接描述。设备名称是你必须传递给 ``--audio-device`` 选项的东西。音频设备的列表可以通过API使用 ``audio-device-list`` 属性来检索。

    虽然该选项通常采取上述方法所显示的字符串之一，但你也可以通过手动构建它来强制大多数音频输出驱动的设备。例如 ``name/foobar`` 强制音频输出驱动的 ``name`` 使用设备 ``foobar`` 。然而， ``--ao`` 选项将严格强制一个特定的音频输出。为了避免混淆，不要同时使用 ``--ao`` 和 ``--audio-device``

    .. admonition:: ALSA的示例

        MPlayer和mplayer2要求你将ALSA设备名称中的任何 ',' 替换为 '.' ，任何 ':' 替换为 '=' 。例如，要使用名为 ``dmix:default`` 的设备，你必须这样做：

            ``-ao alsa:device=dmix=default``

        在mpv中，你可以改用：

            ``--audio-device=alsa/dmix:default``


``--audio-exclusive=<yes|no>``
    启用独占输出模式。在这种模式下，系统通常被锁定，只有mpv能够输出音频。

    这只对某些音频输出有效，比如 ``wasapi`` ``coreaudio`` 和 ``pipewire`` 。其它音频输出会默默的忽略这个选项。它们要么没有独占模式的概念，要么就是缺少mpv方面的实现。

``--audio-fallback-to-null=<yes|no>``
    如果没有音频设备被打开，它的行为就像给出了 ``--ao=null`` 一样。这和 ``--audio-device`` 结合起来很有用：如果选择的设备不存在，client API用户（或Lua脚本）可以让播放正常进行，并检查 ``current-ao`` 和 ``audio-device-list`` 属性，来做出关于如何继续的高级决策。

``--ao=<driver>``
    指定要使用的音频输出驱动。详见 `音频输出驱动`_ 以了解可用驱动的描述。

``--af=<filter1[=parameter1:parameter2:...],filter2,...>``
    指定一个应用于音频流的音频滤镜列表。详见 `音频滤镜`_ 以了解可用滤镜的描述。选项变体 ``--af-add``, ``--af-pre``, ``--af-del`` 和 ``--af-clr`` 的存在可用于修改先前指定的列表，但在典型使用中不需要这些。

``--audio-spdif=<codecs>``
    应该使用的压缩音频直通的编解码器的列表。这对传统的S/PDIF和HDMI都有效。

    可能的编码有 ``ac3``, ``dts``, ``dts-hd``, ``eac3``, ``truehd`` 。可以用 ``,`` 分隔多个编码来指定。 ``dts`` 指的是低码率的DTS core，而 ``dts-hd`` 指的是DTS MA（接收器和操作系统支持的不同）。如果同时指定 ``dts`` 和 ``dts-hd`` ，它的作用等同于只指定 ``dts-hd``

    在早期的mpv版本中，你可以使用 ``--ad`` 来强制使用spdif wrapper。现在这不再有效。

    .. admonition:: 警告

        没有什么理由要使用这个。HDMI支持未压缩的多声道PCM，mpv支持通过FFmpeg的新DCA解码器（基于libdcadec）进行无损的DTS-HD解码。

``--ad=<decoder1,decoder2,...[-]>``
    根据解码器的名称指定一个要使用的音频解码器的优先列表。当确定使用哪个解码器时，会选择首个与音频格式匹配的解码器。如果该解码器不可用，则使用下一个解码器。最后，它尝试所有其它没有被选项明确选择或拒绝的解码器。

    列表末尾的 ``-`` 抑制了回退到不在 ``--ad`` 列表中的其它可用解码器。 ``+`` 在一个条目前面，强制使用解码器。这两种方法通常都不应该使用，因为它们破坏了正常的解码器自动选择。这两种方法都已被废弃。

    .. admonition:: 示例

        ``--ad=mp3float``
            优先使用FFmpeg/Libav的 ``mp3float`` 解码器，而不是所有其它的MP3解码器。

        ``--ad=help``
            列出所有可用的解码器。

    .. admonition:: 警告

        不可能使用该选项时启用压缩音频的直通（通过SPDIF/HDMI的AC3和DTS）。请使用 ``--audio-spdif`` 代替。

``--volume=<value>``
    设置启动时的音量。0表示无声，100表示没有音量缩小或放大。为了兼容性，可以传递负值，但会被当作0处理。

    从mpv0.18.1开始，它始终控制内部混音器（又名“软件音量”）。

``--replaygain=<no|track|album>``
    根据存储在文件元数据中的回放增益值来调整音量增益。使用 ``--replaygain=no`` （默认），不进行调整。用 ``--replaygain=track`` ，应用于轨道增益。用 ``--replaygain=album`` ，如果有专辑，就应用于专辑增益，否则就回退到轨道增益。

``--replaygain-preamp=<db>``
    预放大增益，单位为dB，应用于选定的回放增益（默认： 0）。

``--replaygain-clip=<yes|no>``
    通过自动降低增益来防止由回放引起的clipping（默认）。使用 ``--replaygain-clip=no`` 来禁用它。

``--replaygain-fallback=<db>``
    如果文件没有回放增益标签，以dB为单位应用增益。如果回放增益逻辑在某种程度上未激活，这个选项总是被应用。如果这个选项被应用，其它回放增益选项就不会被应用。

``--audio-delay=<sec>``
    音频延迟，以秒为单位（正或负的浮点值）。正值是延迟音频，负值是延迟视频。

``--mute=<yes|no|auto>``
    设置启动时的音频静音状态（默认： no）。

    ``auto`` 是一个过时的可能值，相当于 ``no``

    另参见： ``--volume``

``--softvol=<no|yes|auto>``
    已过时/无法使用。在mpv0.18.1之前，它用来控制是否使用音频输出驱动的音量控制还是mpv内部的音量滤镜。

    目前的行为是软件音量始终被启用，也就是说，就像这个选项被设置为 ``yes`` 一样。其它行为不再可用，尽管在大多数情况下 ``auto`` 几乎与当前行为一致。

    ``no`` 行为仍然可以通过 ``ao-volume`` 和 ``ao-mute`` 属性来部分使用。但是没有选项可以重置这些。

``--audio-demuxer=<[+]name>``
    当使用 ``--audio-file`` 时，使用这种音频解复用器类型。在名称前使用 ``+`` 来强制它；这将跳过一些检查。通过 ``--audio-demuxer=help`` 输出解复用器的名称。

``--ad-lavc-ac3drc=<level>``
    选择AC-3音频流的动态范围压缩级别。 ``<level>`` 是一个从0到1的浮点值，0表示不压缩（这是默认的），1表示完全压缩（使响亮的片段更安静，反之亦然）。也可以接受高达6的值，但纯粹是实验性的。这个选项只有在AC-3流包含所需的范围压缩信息时才会显示效果。

    标准规定DRC在默认情况下被启用，但mpv（和其它一些播放器）为了更好的音频质量而忽略这一点。

``--ad-lavc-downmix=<yes|no>``
    是否要求解码器对音频声道进行下混处理（默认： no）。一些解码器，如AC-3、AAC和DTS，可以在解码时重混音频。请求的输出声道数是用 ``--audio-channels`` 选项设置的。对于在立体声系统上播放环绕声音频很有用。

``--ad-lavc-threads=<0-16>``
    解码时使用的线程数量。线程是否真正支持取决于编码。截至撰写本文时，它只支持一些无损编码。0表示自动检测机器的核心数，并使用该数，最大为16（默认： 1）。

``--ad-lavc-o=<key>=<value>[,<key>=<value>[,...]]``
    将AVOptions传递给libavcodec解码器。注意，欢迎打一个补丁，使o=不需要，并通过AVOption系统传递所有未知的选项。AVOptions的完整列表可以在FFmpeg手册中找到。

    这是一个按键/值列表选项。详见 `列表选项`_

``--ad-spdif-dtshd=<yes|no>``, ``--dtshd``, ``--no-dtshd``
    如果DTS是直通的，则使用DTS-HD。

    .. admonition:: 警告

        该选项和通过 ``--ad`` 启用直通的做法已过时，改用 ``--audio-spdif=dts-hd``

``--audio-channels=<auto-safe|auto|layouts>``
    控制哪些音频声道被输出（例如，环绕声或立体声）。有以下几种可选：

    - ``--audio-channels=auto-safe``
        使用系统的首选声道布局。如果没有（比如连接硬件设备而不是系统混音器时），就强制使用立体声。有些音频输出可能简单的接受任何布局，并自行进行降频处理。

        这是默认的。
    - ``--audio-channels=auto``
        向音频设备发送它所接受的任何内容，倾向于音频的原始声道布局。可能引起HDMI的问题（参见下方的警告）。
    - ``--audio-channels=layout1,layout2,...``
        应该允许的用 ``,`` 分隔的声道布局列表。技术上来说，这只是把滤镜链的输出调整到列表中最匹配的布局，并把结果传递给音频API。音频API有可能会选择一个不同的声道布局。

        对于直接的硬件输出，特别是通过HDMI（参见下方的HDMI警告），建议使用这种模式。
    - ``--audio-channels=<stereo|mono>``
        强制下混到立体声或单声道。这是前一项的特例。（参见下面几段的含义。）

    如果给出了一个布局列表，每一项目可以是一个明确的声道布局名称（如 ``5.1`` ），或一个声道数。声道数指的是默认的布局，例如2声道指的是立体声，6指的是5.1。

    参见 ``---audio-channels=help`` 输出，了解定义好的默认布局。这也列出了扬声器的名称，可以用来表达任意的声道布局（例如 ``fl-fr-lfe`` 是2.1）。

    如果声道布局列表中只有1项，解码器将被要求产生相应的输出。这有时会触发解码器下混，这可能与正常的mpv下混不同（只有一些解码器支持重混音频，如AC-3、AAC或DTS。你可以使用 ``--ad-lavc-downmix=no`` 来使解码器始终输出其原生布局）。一个后果是， ``--audio-channels=stereo`` 会触发解码器下混，而 ``auto`` 或 ``auto-safe`` 永远不会，即使他们最终选择立体声。发生这种情况是因为，是否使用解码器下混的决定发生在音频设备被打开之前。

    如果媒体文件（即解码器）的声道布局和音频输出驱动的不匹配，mpv将尝试插入一个转换滤镜。你可能需要改变系统混音器的声道布局，来达到你想要的输出，因为mpv无法控制它。在一些音频输出驱动上的另一个解决方法是使用 ``--audio-exclusive=yes`` 来完全规避系统混音器。

    .. admonition:: 警告

        当通过HDMI使用音频时，使用 ``auto`` 会导致问题。操作系统通常会报告所有可以通过HDMI的声道布局，即使接收器不支持它们。如果接收器得到一个不支持的声道布局，就会发生一些随机的事情，比如丢弃额外的声道，或添加噪音。

        建议你设置一个你想要的布局的明确白名单。例如，大多数通过HDMI连接的A/V接收机，如果确实可以7.1，就可以通过这方式实现： ``--audio-channels=7.1,5.1,stereo``

``--audio-display=<no|embedded-first|external-first>``
    决定在播放音频文件时是否显示封面图片，以及优先级。它将显示找到的第一张图片，其它图片可作为视频轨道。

    :no:             在播放音频文件时完全禁用视频显示
    :embedded-first: 显示嵌入式图像和外部封面图片，优先显示内嵌图像（默认）
    :external-first: 显示嵌入式图像和外部封面图片，优先显示外部文件

    这个选项对一般的有视频轨道的文件没有影响。

``--audio-files=<files>``
    在观看视频时播放外部文件的音频。

    这是一个路径列表选项。详见 `列表选项`_

``--audio-file=<file>``
    CLI/设置文件只是 ``--audio-files-append`` 的别名。每次使用这个选项将添加一个新的音轨。细节类似于 ``--sub-file`` 的工作方式。

``--audio-format=<format>``
    选择用于从音频滤镜层输出到声卡的采样格式。 ``<format>`` 的可用值在下方的 ``format`` 音频滤镜的描述中列出。

``--audio-samplerate=<Hz>``
    选择要使用的输出采样率（当然声卡在这方面有限制）。如果选择的采样频率与当前媒体的不同，lavrresample音频滤镜将被插入音频滤镜层来补偿差异。

``--gapless-audio=<no|yes|weak>``
    尝试播放连续的音频文件，在文件切换的地方没有静默或中断。默认： ``weak``

    :no:    禁用无间隔音频
    :yes:   音频设备使用为第一个播放的文件选择的参数打开，然后为无间隔播放保持开放。这表示，如果第一个文件的采样率很低，那么后面的文件可能会被重采样到相同的低采样率，导致声音质量下降。如果你播放不同参数的文件，考虑使用比如 ``--audio-samplerate`` 和 ``--audio-format`` 的选项来明确选择共享的输出格式。
    :weak:  通常情况下，音频设备会保持开放（使用它首次初始化的格式）。如果解码器输出的音频格式改变了，音频设备会被关闭并重新打开。这表示通常情况下，使用相同设置编码的文件将获得无间隔音频，但在其它情况下可能不会无间隔。音频设备保持开放的确切条件是一个实现细节，可以在不同版本之间更改。目前，即使采样格式改变，设备也会被保留，但采样格式是可转换的。如果在还有音频的情况下，视频还在进行，尝试使用无间隔也是明确放弃的。

    .. note::

        这个功能是以一种简单的方式实现的，在从一个文件转到另一个文件时，依靠音频输出设备的缓冲来继续播放。如果新文件的播放开始得很慢，例如因为它是从远程网络位置播放的，或者因为你指定的缓冲设置需要时间进行初始缓冲填充，那么在新文件的播放开始之前，缓冲的音频可能会用完。

``--initial-audio-sync``, ``--no-initial-audio-sync``
    当开始一个视频文件或在事件发生后，比如跳转，mpv默认会修改音频流，使其与视频从相同的时间戳开始，在开始时插入静音或切掉第一个样本。禁用这个选项会使播放器表现得像旧版mpv一样：视频和音频都立即开始，即使它们的开始时间戳不同，然后如果有必要，视频时间会逐渐调整，来达到正确的同步。

``--volume-max=<100.0-1000.0>``, ``--softvol-max=<...>``
    设置最大的放大级别，单位是百分比（默认： 130）。130的值将允许你将音量调整到正常水平的两倍左右。

    ``--softvol-max`` 是一个过时的别名且不应该使用。

``--audio-file-auto=<no|exact|fuzzy|all>``, ``--no-audio-file-auto``
    加载与视频文件名匹配的额外音频文件。参数指定了外部音频文件的匹配模式。

    :no:    不自动加载外部音频文件（默认）
    :exact: 加载带有音频文件扩展名的媒体文件名
    :fuzzy: 加载所有包含媒体文件名的音频文件
    :all:   加载当前目录和 ``--audio-file-paths`` 目录中的所有音频文件

``--audio-file-paths=<path1:path2:...>``
    相当于 ``--sub-file-paths`` 选项，但用于自动加载的音频文件。

    这是一个路径列表选项。详见 `列表选项`_

``--audio-client-name=<name>``
    播放器报告给音频API的应用程序名称。如果你想强制使用不同的音频profile（例如使用PulseAudio），或者在使用libmpv时设置你自己的应用程序名称，就很有用。

``--audio-buffer=<seconds>``
    设置音频输出的最小缓冲区。如果音频设备可行的话，它实际上可能会创建一个更大的缓冲区。如果设备创建了一个较小的缓冲区，额外的音频将被缓存在一个额外的软件缓冲区中。

    把缓冲区变大会使软件音量和其它滤镜的反应变慢，在播放速度变化时引入额外的问题，并在音频格式变化时屏蔽播放器。较小的缓冲区可能会导致音频丢失。

    这个选项应该只用于测试。如果一个非默认值有明显的帮助，应该联系mpv的开发者。

    默认： 0.2（即200ms）

``--audio-stream-silence=<yes|no>``
    烧钱的消费级音频硬件（比如A/V接收机）经常忽略通过HDMI发送的初始音频。这可能发生在每次通过HDMI停止和恢复音频的时候。为了弥补这一点，你可以启用这个选项，在跳转时不停止和重启音频，用静默来填补空隙。同样，当暂停播放时，音频也不会停止，暂停时播放的是静音。注意，如果没有选择音轨，音频设备仍然会被立即关闭。

    不是所有的音频输出驱动都支持这个。

    .. admonition:: 警告

        这修改了某些微妙的播放器行为，如A/V同步和负载处理。强烈建议不要启用这个选项。

``--audio-wait-open=<secs>``
    这对与`--audio-stream-silence=yes`` 一起的使用有意义。如果给出了这个选项，播放器将在打开音频设备后等待给定的秒数，然后再发送实际的音频数据给它。如果你的昂贵的硬件会丢弃前1或2秒的音频数据，那就很有用。如果没有设置 ``--audio-stream-silence=yes`` ，这个选项很可能只是浪费时间。

字幕
----

.. note::

    更改样式和位置不会对所有的字幕都起作用。基于图像的字幕（DVD, Bluray/PGS, DVB）由于基础性的原因不能改变。ASS格式的字幕通常不会被故意改变，但可以用 ``--sub-ass-override`` 来控制覆盖它们。

    以前一些处理文本字幕的选项被称为 ``--sub-text-*`` ，现在它们被命名为 ``--sub-*`` ，而那些专门针对ASS的选项已经从 ``--ass-*`` 改名为 ``--sub-ass-*`` 。它们现在都在这个部分。

``--sub-demuxer=<[+]name>``
    为 ``---sub-file`` 强制使用的字幕解复用器类型。通过 ``--sub-demuxer=help`` 输出解复用器的名称。

``--sub-delay=<sec>``
    延迟字幕 ``<sec>`` 秒。可以是负数。

``--sub-files=<file-list>``, ``--sub-file=<filename>``
    添加一个字幕文件到外部字幕列表中。

    如果你只使用一次 ``--sub-file`` ，该字幕文件就会默认显示。

    如果 ``--sub-file`` 被多次使用，可以在运行时通过循环字幕轨道来切换到要使用的字幕。可以同时显示两个字幕：使用 ``--sid`` 选择第一个字幕索引， ``--secondary-sid`` 选择第二个索引（索引输出在终端输出的流列表里的 ``--sid=`` 之后）。

    ``--sub-files`` 是一个路径列表选项（详见 `列表选项`_ ），可以接受多个文件名，用 ``:`` (Unix) 或 ``;`` (Windows)分隔，而 ``--sub-file`` 只接受一个文件名，但可以多次使用来添加多个文件。技术上， ``--sub-file`` 是 ``--sub-files-append`` 的CLI/设置文件的别名。

``--secondary-sid=<ID|auto|no>``
    选择一个次级字幕流。这与 ``--sid`` 相似。如果选择了次字幕，它将作为顶部字幕（即在屏幕的顶部）与普通字幕一起呈现，并提供一种同时呈现双字幕的方法。

    这个功能有一些相关的注意事项。例如，位图字幕将总是在其通常的位置呈现，所以选择位图字幕作为次字幕将导致字幕重叠。如果视频被禁用，次字幕永远不会在终端上显示。

    .. note::

        次字幕的样式和对任何格式化标签的解析都是禁用的。在内部，与 ``--no-sub-ass`` 相同的机制被用来剥离样式。

    .. note::

        如果主字幕流包含格式化标签，将部分字幕显示在屏幕的顶部，它将与副字幕重叠。为了防止这种情况，你可以使用 ``--no-sub-ass`` 来禁用主字幕流中的样式。

``--sub-scale=<0-100>``
    文本字幕的字体大小系数（默认： 1）。

    .. note::

        这也影响ASS字幕，并可能导致不正确的字幕渲染。小心使用，或用 ``--sub-font-size`` 代替。

``--sub-scale-by-window=<yes|no>``
    是否随窗口大小缩放字幕（默认： yes）。如果禁用这个功能，改变窗口尺寸不会更改字幕字体大小。

    和 ``--sub-scale`` 一样，这可能会破坏ASS字幕。

``--sub-scale-with-window=<yes|no>``
    使字幕的字体大小与窗口关联，而不是与视频关联。如果你总是想要相同的字体大小，这很有用，即使视频没有完全覆盖窗口，例如，因为屏幕和窗口的长宽不匹配（而且播放器会添加黑条）。

    默认： yes

    这个选项被错误的命名。与听起来令人困惑的类似选项 ``--sub-scale-by-window`` 的区别是， ``--sub-scale-with-window`` 仍然是根据窗口的近似大小进行缩放，而另一个选项则是禁用这种缩放。

    只影响纯文本字幕（或者ASS，前提是如果 ``--sub-ass-override`` 设置得足够高）。

``--sub-ass-scale-with-window=<yes|no>``
    类似 ``--sub-scale-with-window`` ，但只影响ASS格式的字幕。和 ``--sub-scale`` 一样，这可能会破坏ASS字幕。

    默认： no

``--embeddedfonts=<yes|no>``
    使用内嵌在Matroska容器文件和ASS脚本中的字体（默认： yes）。这些字体可以用于SSA/ASS字幕的渲染。

``--sub-pos=<0-150>``
    指定字幕在屏幕上的位置。该值是字幕的垂直位置，单位是屏幕高度的%。100是原始位置，通常不是屏幕的绝对底部，而是在底部和字幕之间有一些留空。高于100的数值会使字幕进一步向下移动。

    .. admonition:: 警告

        如果该选项的值高于100，文本字幕（相对于图像字幕）可能会被切断。这是一个libass的限制。

        这也影响ASS字幕，除了上述问题外，还可能导致不正确的字幕渲染。

        使用 ``--sub-margin-y`` 可以用更好的方式来达成这个目的。

``--sub-speed=<0.1-10.0>``
    将字幕event的时间戳与给定值相乘。可以修复基于帧的字幕格式的播放速度。只影响文本字幕。

    .. admonition:: 示例

        ``--sub-speed=25/23.976`` 播放以帧为基础的字幕，假定帧率为23.976，速度为25FPS。

``--sub-ass-force-style=<[Style.]Param=Value[,...]>``
    覆盖一些样式或脚本信息参数。

    这是一个字符串列表选项。详见 `列表选项`_

    .. admonition:: 示例

        - ``--sub-ass-force-style=FontName=Arial,Default.Bold=1``
        - ``--sub-ass-force-style=PlayResY=768``

    .. note::

        使用这个选项可能会导致不正确的字幕渲染。

``--sub-ass-hinting=<none|light|normal|native>``
    设置字体hinting类型。 <type> 可以是：

    :none:       无hinting（默认）
    :light:      FreeType autohinter，light模式
    :normal:     FreeType autohinter，normal模式
    :native:     字体的原生hinter

    .. admonition:: 警告

        启用hinting可能会导致错误位置的文本（在它应该与视频背景相匹配的情况下），或者降低一些不好的ASS脚本的动画的平滑度。不推荐使用这个选项，除非真的需要。

``--sub-ass-line-spacing=<value>``
    设置SSA/ASS渲染器的行距值。

``--sub-ass-shaper=<simple|complex>``
    设置libass使用的文本布局引擎。

    :simple:   只使用Fribidi，速度快，不能正确渲染某些语言
    :complex:  使用HarfBuzz，速度较慢，支持更多语言

    ``complex`` 是默认的。如果libass没有针对HarfBuzz进行编译，libass会默默地恢复到 ``simple``

``--sub-ass-styles=<filename>``
    加载在指定文件中找到的所有SSA/ASS样式，并使用它们来渲染文本字幕。文件的语法与SSA/ASS的 ``[V4 Styles]`` / ``[V4+ Styles]`` 部分完全一样。

    .. note::

        使用这个选项可能导致不正确的字幕渲染。

``--sub-ass-override=<yes|no|force|scale|strip>``
    控制是否应该应用用户风格覆盖。请注意，所有这些覆盖都尝试在某种程度上智能的识别出一个字幕是否被认为是一个“符号”。

    :no:    按照字幕脚本的指定渲染字幕，没有覆盖
    :yes:   应用所有的 ``--sub-ass-*`` 样式覆盖选项。改变这些选项的默认值可能导致不正确的字幕渲染（默认）
    :force: 类似 ``yes`` ，但也强制使用所有 ``--sub-*`` 选项。可以轻易破坏渲染
    :scale: 类似 ``yes`` ，但也应用 ``--sub-scale``
    :strip: 彻底剥离字幕的所有ASS标签和样式。这相当于以前的 ``--no-ass`` / ``--no-sub-ass`` 选项

    这也控制了一些位图字幕的覆盖，以及SRT等格式的HTML标签，尽管该选项的名称不同。

``--sub-ass-force-margins``
    如果字幕是ASS格式，在有黑边的情况下，启用将顶部字幕和字幕放进黑边。

    默认： no

``--sub-use-margins``
    如果字幕是纯文本格式（或ASS格式，前提是如果 ``--sub-ass-override`` 设置得足够高），在有黑边的情况下，启用将顶部字幕和字幕放进黑边。

    默认： yes

    由 ``--sub-ass-use-margins`` 改名。如果要把ASS字幕也放进黑边（像旧的选项那样），也要增加 ``--sub-ass-force-margins``

``--sub-ass-vsfilter-aspect-compat=<yes|no>``
    在播放变形视频时拉伸SSA/ASS字幕，与传统VSFilter行为兼容。当视频以方形像素存储时，这个开关没有影响。

    历史上最常用于SSA/ASS字幕格式的渲染器VSFilter具有可疑的行为，如果视频以变形格式存储，需要缩放显示时，会导致字幕也被拉伸。这种行为通常是不可取的，较新的VSFilter版本可能会有不同的行为。然而，许多现有的脚本通过在相反的方向上进行修改来补偿拉伸。因此，如果这类脚本被“正确”地显示出来，它们就不会如预期那样出现。这个开关启用模拟旧的VSFilter行为（不可取但许多现有的脚本都如此期望）。

    默认情况下是启用的。

``--sub-ass-vsfilter-blur-compat=<yes|no>``
    根据视频分辨率而不是脚本分辨率来缩放 ``\blur`` 标签的大小（默认启用）。这是VSFilter的错误，根据一些人的说法，为了兼容性的名义不再能被修复。

    请注意，这是用实际的视频分辨率来计算偏移比例系数，而不是视频滤镜链或视频输出所使用的。

``--sub-ass-vsfilter-color-compat=<basic|full|force-601|no>``
    像(xy-)vsfilter那样损坏颜色（默认： basic）。历史上，VSFilter没有颜色空间的概念。只要使用标清视频（BT.601）的色彩空间就没有问题。但是，当一切都转向高清（BT.709）时，VSFilter仍然将RGB颜色转换为BT.601，将它们渲染到视频帧中，并将帧处理到使用BT.709来转换为RGB的视频输出。结果是字幕的颜色被损坏了。后来，在ASS格式的基础上增加了一些不好的hack，来控制颜色的损坏处理方式。

    :basic:     只处理BT.601->BT.709的损坏，如果字幕似乎表明这是需要的（默认）
    :full:      处理完整的 ``YCbCr Matrix`` header和所有libass和mpv支持的视频色彩空间。这可能会导致在极端情况下出现严重的故障，而且对于兼容性来说不是严格需要的（希望如此），这就是它不是默认的原因
    :force-601: 强制BT.601->BT.709的损坏，无视字幕header或视频色彩空间
    :no:        完全禁用颜色损坏。所有颜色都是RGB。

    选择除 ``no`` 以外的任何东西都会使字幕颜色依赖于视频色彩空间，例如，理论上不可能将字幕脚本与另一个视频文件重复使用。 ``--sub-ass-override`` 选项不影响该选项的解释。

``--stretch-dvd-subs=<yes|no>``
    在播放变形视频时拉伸DVD字幕，以便在不良的DVD上获得更好的字体效果。当视频以方形像素存储时，这个开关没有效果 —— 虽然对DVD输入来说不可能是这种情况。

    许多工作室在制作DVD时倾向于使用为方形像素设计的位图字体，导致字体在DVD播放器上看起来被拉伸了。这个选项可以解决这个问题，然而代价是可能会使一些字幕错误对齐（例如公示语翻译）。

    默认情况下是禁用的。

``--stretch-image-subs-to-screen=<yes|no>``
    拉伸DVD和其它图像字幕到屏幕，忽略视频的边距。这和 ``--sub-use-margins`` 对文本字幕的效果类似，只是文本本身会被拉伸，而不仅仅是重新定位（至少在一般情况下这是不可避免的，因为理论上一个图像位图可以由单个覆盖整个屏幕的位图组成，而播放器将无法得知文本部分的确切定位）。

    这个选项不能正确显示字幕。小心使用。

    默认情况下是禁用的。

``--image-subs-video-resolution=<yes|no>``
    用视频分辨率覆盖图像字幕的分辨率（默认： no）。通常情况下，字幕画布是匹配视频画布的（例如信箱式）。设置这个选项可以使用视频尺寸作为字幕画布尺寸。可以用来测试损坏的字幕，这经常发生在视频被转码时，同时试图保留旧的字幕。

``--sub-ass``, ``--no-sub-ass``
    原生渲染ASS字幕（默认启用）。

    .. note::

        这已经被 ``--sub-ass-override=strip`` 淘汰过时。你可能还需要 ``--embeddedfonts=no`` 来获得同样的行为。另外，使用 ``--sub-ass-override=style`` 应该给出更好的效果，而不会对字幕造成太大破坏。

    如果指定了 ``--no-sub-ass`` ，所有的标签和样式声明都会被剥离并在显示时被忽略。字幕渲染器使用 ``--sub-`` 选项所指定的字体样式来替代。

    .. note::

        使用 ``--no-sub-ass`` 可能会导致ASS/SSA字幕的渲染不正确或完全损坏。有时强行覆盖ASS字幕的样式是有用的，但一般情况下应该避免。

``--sub-auto=<no|exact|fuzzy|all>``, ``--no-sub-auto``
    加载与视频文件名匹配的额外字幕文件。参数指定了外部字幕文件的匹配模式。默认情况下， ``exact`` 被启用。

    :no:    不自动加载外部字幕文件
    :exact: 加载带有字幕文件扩展名和可能的语言后缀的媒体文件名（默认）
    :fuzzy: 加载包含媒体文件名的所有字幕
    :all:   加载当前和 ``--sub-file-paths`` 目录中的所有字幕文件

``--sub-codepage=<codepage>``
    你可以用这个选项来指定字幕代码页，uchardet将被用来猜测字符集（如果mpv没有用uchardet编译，那么 ``utf-8`` 是有效的默认值）。

    这个选项的默认值是 ``auto`` ，它启用自动检测。

    依次采取以下步骤来确定最终的编码页：

    - 如果特定的代码页有 ``+`` ，则使用它
    - 如果数据看起来像UTF-8，就假定它是UTF-8
    - 如果 ``--sub-codepage`` 被设置为一个特定的代码页，则使用它
    - 运行uchardet，如果成功，则使用它
    - 否则，使用 ``UTF-8-BROKEN``

    .. admonition:: 示例

        - ``--sub-codepage=latin2`` 如果输入不是UTF-8，则使用Latin 2
        - ``--sub-codeepage=+cp1250`` 始终强制重编码为cp1250

    伪代码页 ``UTF-8-BROKEN`` 是内部使用的。如果它被设置，字幕被解释为UTF-8，"Latin 1" 作为非有效UTF-8序列的后备字节。 iconv从不参与这种模式。

    该选项在mpv0.23.0中被改变。对旧语法的支持在mpv0.24.0中被完全移除。

    .. note::

        这只适用于文本字幕文件。其它类型的字幕（特别是mkv文件中的字幕）始终被假定为UTF-8。


``--sub-fix-timing=<yes|no>``
    调整字幕计时是为了移除字幕之间的微小间隔或重叠（如果差距小于210毫秒，间隔或重叠会被移除）。

``--sub-forced-only=<auto|yes|no>``
    只显示由 ``--slang`` 等选择的DVD字幕流的强制字幕（默认： ``auto`` ）。当设置为 ``auto`` 时，当 ``--subs-with-matching-audio`` 选项打开并且选择了一个非强制的字幕流时启用。启用这个选项将隐藏流中的所有字幕，这些字幕不会区分流中的强制和非强制事件。

``--sub-fps=<rate>``
    指定字幕文件的帧速率（默认：视频帧速率）。只影响文本字幕。

    .. note::

        ``<rate>`` > 视频帧率，则加快基于帧的字幕文件的字幕速度，减慢基于时间的字幕文件的速度。

    另参见： ``--sub-speed``

``--sub-gauss=<0.0-3.0>``
    对图像字幕应用高斯模糊（默认： 0）。这有助于使像素化的DVD/Vobsubs观感更佳。除了0以外的值还可以切换到软件字幕的缩放。可能会很慢。

    .. note::

        从不应用于文本字幕。

``--sub-gray``
    将图像字幕转换成灰度。有助于使黄色的DVD/Vobsubs观感更佳。

    .. note::

        从不应用于文本字幕。

``--sub-paths=<path1:path2:...>``
    已过时，使用 ``--sub-file-paths``

``--sub-file-paths=<path-list>``
    指定额外的目录来搜索匹配视频的字幕。多个目录可以用":"（在Windows下为";"）隔开。路径可以是相对的或绝对的。相对路径被解释为相对于视频文件的目录。如果文件是一个URL，只有绝对路径和 ``sub`` 设置子目录会被扫描。

    .. admonition:: 示例

        假定 ``/path/to/video/video.avi`` 被播放并且 ``--sub-file-paths=sub:subtitles`` 被指定，mpv在这些目录中搜索字幕文件：

        - ``/path/to/video/``
        - ``/path/to/video/sub/``
        - ``/path/to/video/subtitles/``
        - ``sub`` 设置子目录（通常是 ``~/.config/mpv/sub/`` ）

    这是一个路径列表选项。详见 `列表选项`_

``--sub-visibility``, ``--no-sub-visibility``
    可用于禁用字幕显示，但仍可选中和解码它。

``--secondary-sub-visibility``, ``--no-secondary-sub-visibility``
    可用于禁用次字幕显示，但仍可选中和解码它。

``--sub-clear-on-seek``
    （费解的，很少有用。）可以用来播放有重复ReadOrder字段的损坏的mkv文件。ReadOrder是Matroska式ASS字幕packets的第一个字段。它应该是唯一的，libass使用它来快速消除重复的内容。这个选项禁用了交叉跳转的字幕缓存，因此在跳转之后，libass不能消除与先前的packets具有相同ReadOrder的字幕packets。

``--teletext-page=<1-999>``
    这适用于 ``dvb_teletext`` 字幕流，如果FFmpeg在编译时支持它。

``--sub-past-video-end``
    在视频的最后一帧之后，如果这个选项被启用，字幕将继续根据音频的时间戳来更新。否则，最后一帧视频的字幕将停留在屏幕上。

    默认：禁用

``--sub-font=<name>``
    为本身没有指定特定字体的字幕指定使用的字体。默认是 ``sans-serif``

    .. admonition:: 示例

        - ``--sub-font='Bitstream Vera Sans'``
        - ``--sub-font='Comic Sans MS'``

    .. note::

        在渲染ASS字幕时， ``--sub-font`` 选项（以及许多其它与样式相关的 ``--sub-`` 选项）会被忽略，除非指定 ``--no-sub-ass`` 选项。

        这被用于支持fontconfig模式。从libass0.13.0开始，它不再工作。

``--sub-font-size=<size>``
    指定字幕字体的大小。单位是窗口高度为720时按比例计算的像素大小。实际的像素大小随着窗口高度的变化而缩放：如果窗口高度大于或小于720，文字的实际大小也会随之增加或减少。

    默认： 55

``--sub-back-color=<color>``
    参见 ``--sub-color`` 。用于字幕文本背景的颜色。你可以使用 ``--sub-shadow-offset`` 来改变它相对于文本的大小。

``--sub-blur=<0..20.0>``
    高斯模糊系数。0表示不应用模糊（默认）。

``--sub-bold=<yes|no>``
    格式化文本为粗体。

``--sub-italic=<yes|no>``
    格式化文本为斜体。

``--sub-border-color=<color>``
    参见 ``--sub-color`` 。用于字幕字体边框的颜色。

``--sub-border-size=<size>``
    字幕字体边框的大小，以缩放的像素为单位（详见 ``--sub-font-size`` ）。值为0时禁用边框。

    默认： 3

``--sub-color=<color>``
    指定无样式的文本字幕的颜色。

    颜色是以 ``r/g/b`` 的形式指定的，其中每个颜色分量被指定为0.0到1.0范围内的数字。也可以通过使用 ``r/g/b/a`` 来指定透明度，其中alpha值0表示完全透明，1.0表示不透明。如果没有给出alpha分量，颜色就是100%不透明的。

    传递单个数字给选项，就可以把字幕设置为灰色，而``gray/a``的形式可以让你额外指定alpha。

    .. admonition:: 示例

        - ``--sub-color=1.0/0.0/0.0`` 设置字幕为不透明的红色
        - ``--sub-color=1.0/0.0/0.0/0.75`` 设置字幕为不透明的红色带75%透明
        - ``--sub-color=0.5/0.75`` 设置字幕为50%灰色带75%透明

    另外，颜色可以被指定为RGB十六进制三元组，其形式为 ``#RRGGBB`` ，其中每个2位数组表示0（ ``00`` ）到255（ ``FF`` ）范围内的一个颜色值。例如， ``#FF0000`` 是红色。这与web颜色类似。Alpha是用 ``#AARRGGBB`` 来表示的。

    .. admonition:: 示例

        - ``--sub-color='#FF0000'`` 设置字幕为不透明的红色
        - ``--sub-color='#C0808080'`` 设置字幕为50%灰色带75%透明

``--sub-margin-x=<size>``
    字幕的左右屏幕边距，以缩放后的像素为单位（详见 ``--sub-font-size`` ）。

    这个选项指定了字幕到左边的距离，以及长字幕文本到右边界被打断的距离。

    默认： 25

``--sub-margin-y=<size>``
    字幕的顶部和底部的屏幕边距，以缩放后的像素为单位（详见 ``--sub-font-size`` ）。

    这个选项指定了无样式的文本字幕的垂直边距。如果你只想提高垂直字幕的位置，使用 ``--sub-pos``

    默认： 22

``--sub-align-x=<left|center|right>``
    控制文本字幕应该对齐屏幕的哪个角落（默认： ``center`` ）

    除了在 ``--no-sub-ass`` 模式下，从不应用于ASS字幕。同样，这也不适用于图像字幕。

``--sub-align-y=<top|center|bottom>``
    垂直位置（默认： ``bottom`` ）。详见 ``--sub-align-x``

``--sub-justify=<auto|left|center|right>``
    控制多行字幕的对齐方式，而不考虑其对齐位置（默认： ``auto`` ，按照 ``--sub-align-x`` 的定义进行对齐）。推荐使用左对齐，使子句更易便于人眼阅读。

``--sub-ass-justify=<yes|no>``
    如果 ``--sub-ass-override`` 没有设置为 ``no`` ，则在ASS字幕上应用 ``--sub-justify`` 所定义的对齐方式。默认： ``no``

``--sub-shadow-color=<color>``
    参见 ``--sub-color`` 。用于字幕文本阴影的颜色。

    .. note::

        当指定 ``--sub-back-color`` 时（或者更确切地说：当该选项没有被设置为完全透明时）被忽略。

``--sub-shadow-offset=<size>``
    字幕文本阴影的偏移，以缩放后的像素为单位（详见 ``--sub-font-size`` ）。值为0时禁用阴影。

    默认： 0

``--sub-spacing=<size>``
    水平字幕字体的间距，以缩放后的像素为单位（详见 ``--sub-font-size`` ）。这个值会加到正常的字符间距上。允许负值。

    默认： 0

``--sub-filter-sdh=<yes|no>``
    应用滤镜去除为耳聋人或听力障碍者（SDH）添加的字幕。这是为英语准备的，但也可能部分适用于其它语言。其目的是，它可以被始终启用，所以可能不会移除所有添加的部分。它可以移除speaker labels（如MAN:）、圆括号内的大写文本和任何方括号内的文本。

    默认： ``no``

``--sub-filter-sdh-harder=<yes|no>``
    做更难的SDH过滤（如果由 ``--sub-filter-sdh`` 启用）。也将移除speaker labels和圆括号内使用小写和大写字母的文本。

    默认： ``no``

``--sub-filter-regex-...=...``
    设置一个正则表达式列表来匹配文本字幕，并移除任何匹配的行（默认：空）。这是一个字符串列表选项。详见 `列表选项`_ 。通常，你应该使用 ``--sub-filter-regex-append=<regex>`` ，每一个选项的使用都会附加一个新的正则表达式，而不需要对抗转义问题。

    列表的项目是按顺序匹配的。如果一个正则表达式匹配，这个过程就会停止，该字幕行会被丢弃。默认情况下，匹配的文本是ASS event的 ``Text`` 字段（如果字幕格式不同，它总是被转换）。这可能包括格式化的tags。匹配是不分大小写的，但如何做到这一点取决于libc，而且很可能只在ASCII中工作。它对位图/图像字幕不起作用。在劣质操作系统上不可用（需要POSIX regex的支持）。

    .. admonition:: 示例

        ``--sub-filter-regex-append=opensubtitles\.org`` 过滤一些广告。

    从技术上讲，使用列表进行匹配是多余的，因为你可以只使用单个组合的正则表达式。但它有助于诊断，便于使用，以及临时禁用或启用单个的滤镜。

    .. warning::

        这是实验性的。语义很可能会改变，如果你使用这个，你应该准备好以后更新这个选项。想法包括用一个非常原始和小的sed子集来代替regexes，或者用一些方法来控制大小写敏感度。

``--sub-filter-jsre-...=...``
    与 ``--sub-filter-regex`` 相同，但使用JavaScript正则表达式。共享/受所有 ``--sub-filter-regex-*`` 控制选项影响（见下文），也是试验性的。只需要JavaScript支持。

``--sub-filter-regex-plain=<yes|no>``
    是否首先将ASS "Text" 字段转换为纯文本（默认： no）。这将剥离ASS tags并应用ASS directives，比如 ``\N`` 到换行。如果结果是多行的，那么重构表达式锚点 ``^`` 和 ``$`` 会匹配每一行，但任何匹配都会丢弃所有行。

``--sub-filter-regex-warn=<yes|no>``
    用warning日志级别记录被丢弃的行，而不是verbose（默认： no）。对测试有帮助.

``--sub-filter-regex-enable=<yes|no>``
    是否启用regex过滤（默认： yes）。注意，如果在 ``--sub-filter-regex`` 列表中没有添加任何regexes，将此选项设置为 ``yes`` 没有任何作用。它是为了方便临时禁用或启用过滤功能。

``--sub-create-cc-track=<yes|no>``
    对于每个视频流，创建一个closed captions轨道（默认： no）。唯一的目的是使轨道在播放开始时可以选择，而不是懒散地创建它。这只适用于 ``ATSC A53 Part 4 Closed Captions`` （显示由mpv使用 ``eia_608`` 编码的字幕轨道）。CC轨道被标记为 "default" ，并根据正常的字幕轨道选择规则来选择。然后你也可以使用 ``--sid`` 来明确选择正确的轨道。

    如果视频流不包含closed captions，或者没有视频被解码，CC轨道将保持空白且不显示任何文本。

``--sub-font-provider=<auto|none|fontconfig>``
    使用哪种libass的font provider后端（默认： auto）。 ``auto`` 将尝试使用原生font provider：Linux上的fontconfig，macOS上的CoreText，Windows上的DirectWrite。 ``fontconfig`` 会强制使用fontconfig，如果libass在构建时支持的话（如果不支持，它的行为与 ``none`` 相似）。

    ``none`` font provider有效地禁用了系统字体。它仍然会试图使用内嵌的字体（除非设置了 ``--embeddedfonts=no`` ；这与所有其它font provider的行为相同），和 ``subfont.ttf`` （如果提供），和 ``fonts`` 子目录中的字体（如果提供）。（回退比其它font provider更严格，如果一个字体名称不匹配，它可能宁愿不渲染任何使用缺失字体的文本。）

``--sub-fonts-dir=<path>``
    这个目录中的字体文件将被mpv/libass用来渲染字幕。如果你不想在系统中安装字体的话，该目录很有用。注意，此目录中的文件在被mpv使用之前会被加载到内存中。如果你有很多字体，考虑使用 fonts.conf（参见 `文件`_ 部分）来涵盖额外的mpv用户设置。

    If this option is not specified, ``~~/fonts`` will be used by default.

窗口
----

``--title=<string>``
    设置窗口的标题。这用于视频窗口，如果可能，也设置音频流标题。

    属性被扩展。（参见 `属性扩展`_ ）

    .. warning::

        有可能导致显著的CPU占用，这取决于使用的属性。变更窗口的标题通常是一个缓慢的操作，如果标题每一帧都在变化，播放可能会被损坏。

``--screen=<default|0-32>``
    在多显示器配置中（例如单个桌面跨越多个显示器），这个选项告知mpv在哪个屏幕上显示视频。

    .. admonition:: 注意（X11）

        该选项并非适用于所有的窗口管理器。在这种情况下，你可以尝试使用 ``--geometry`` 来明确定位窗口。窗口管理器也可能提供原生功能来控制应用程序窗口应使用的屏幕。

    另参见 ``--fs-screen``

`--screen-name=<string>```。
    在多显示器配置中，这个选项告知mpv根据来自视频后端的屏幕名称在哪个屏幕上显示视频。 ``--screen`` 选项中的注意事项同样适用于此。如果 ``--screen`` 是明确设置的，这个选项将被忽略，没有任何作用。

``--fullscreen``, ``--fs``
    全屏播放。

``--fs-screen=<all|current|0-32>``
    在多显示器配置中（例如单个桌面跨越多个显示器），这个选项告知mpv要全屏到哪个屏幕。如果使用 ``current`` ，mpv将回退到用户提供的 ``screen`` 选项。

    .. admonition:: 注意（X11）

        这个选项只有在理解EWMH ``_NET_WM_FULLSCREEN_MONITORS`` 提示的窗口管理器中才能正常工作。

    .. admonition:: 注意（macOS）

        ``all`` 在macOS上不起作用，行为会像 ``current`` 一样。

    另参见 ``--screen``

``--fs-screen-name=<string>``
    在多显示器配置中，这个选项告知mpv根据视频后端的屏幕名称进入全屏。 ``--fs-screen`` 选项中的注意事项同样适用于此。如果 ``--fs-screen`` 是明确设置的，这个选项将被忽略，没有任何作用。

``--keep-open=<yes|no|always>``
    当播放或跳转超过文件的末尾，并且没有下一个文件要播放时（并且不使用 ``--loop`` ），不终止。取代的是，暂停播放器。当尝试在文件结束后跳转时，播放器将试图跳转到最后一帧。

    通常情况下，这就像在文件末尾时 ``set pause yes`` 一样，除非设置了 ``--keep-open-pause=no`` 选项。

    可以给出以下参数：

    :no:        如果当前文件结束，转到下一个文件或终止（默认）
    :yes:       如果当前文件是最后一个播放列表条目，不终止。相当于 ``--keep-open`` 不带参数
    :always:    类似 ``yes`` ，但也应用于最后一个播放列表条目之前的文件。这表示播放将永远不会自动推进到下一个文件

    .. note::

        当使用 ``--frames`` 时，这个选项不被遵循。如果绑定使用 ``force`` ，明确地跳到下一个文件，也会终止播放。

        另外，如果发生错误或异常情况，播放器还是会退出。

    从mpv0.6.0开始，如果播放列表中有下一个文件，或者播放列表是循环的，这就不会暂停。近似地，这将在播放器正常退出时暂停，但在实际中，有一些极端的情况不是这样的（例如， ``mpv --keep-open file.mkv /dev/null`` 将正常播放file.mkv，然后无法打开 ``/dev/null`` ，然后退出）。（在mpv0.8.0中， ``always`` 被引入，它恢复了旧的行为。）

``--keep-open-pause=<yes|no>``
    如果设置为 ``no`` ，当 ``--keep-open`` 激活时，不会暂停，而只是在文件结束时停止，当你向前跳转时继续向后播放，直到结束时再次停止。默认： ``yes``

``--image-display-duration=<seconds|inf>``
    如果当前文件是图像，播放图像的时间为给定的秒数（默认： 1）。 ``inf`` 表示该文件永远保持打开（直到用户手动停止播放）。

    与 ``--keep-open`` 不同，播放器不是暂停的，只是继续播放直到时间结束。（在“播放”期间，它不应该使用任何资源。）

    这影响到图像文件，它被定义为只有1个视频帧且无音频。播放器可能会将某些非图像识别为图像，例如，如果 ``--length`` 被用来减少长度到1帧，或者如果你跳转到最后一帧。

    这个选项不影响用于 ``mf://`` 或 ``--merge-files`` 的帧速率。为此，请使用 ``--mf-fps`` 代替。

    设置 ``--image-display-duration`` 隐藏OSC，不在命令行输出中追踪播放时间，也不在编码时重复图像帧。要强制播放器进入“dumb模式”并实际计算秒数，或在编码时复制图像，你需要使用 ``--demuxer=lavf --demuxer-lavf-o=loop=1`` ，并使用 ``--length`` 或 ``--frames`` 来在特定时间后停止。

``--force-window=<yes|no|immediate>``
    即使没有视频也要创建一个视频输出窗口。这对假装mpv是一个GUI应用程序时很有用。目前，该窗口的大小总是640x480，并受 ``--geometry`` 、 ``--autofit`` 和类似选项的制约。

    .. warning::

        窗口只在初始化后创建（以确保在视频尺寸与 ``--force-window`` 默认窗口尺寸不同的情况下，默认的窗口放置仍然有效）。如果初始化工作不完美，这可能是一个问题，比如在网络连接不好的情况下打开URL，或者打开损坏的视频文件。 ``immediate`` 模式可用于在程序启动时创建窗口，但这可能导致其它问题。

``--taskbar-progress``, ``--no-taskbar-progress``
    （Windows独占）启用/禁用任务栏中的播放进度渲染（Windows 7及以上）。

    默认启用。

``--snap-window``
    （Windows独占）将播放器窗口固定在屏幕边缘。

``--drag-and-drop=<auto|replace|append>``
    (X11和Wayland独占)
    控制拖放在支持该功能的平台上的默认行为。 ``auto`` 将服从底层操作系统/平台给mpv的指示。通常情况下，在拖放过程中按住shift会将项目追加到播放列表中，否则新文件将完全取代旧文件。 ``replace`` 和 ``append`` 总是分别强制替换和追加到播放列表中。

``--ontop``
    使播放器窗口停留在其他窗口的顶部。

    在Windows上，如果与全屏模式相结合，这将导致mpv被视为绕过DWM的独占全屏窗口。

``--ontop-level=<window|system|desktop|level>``
    （macOS独占）设置一个置顶窗口的等级（默认： window）。

    :window:  在所有其它窗口之上
    :system:  在系统元素，比如任务栏、菜单栏和Dock之上
    :desktop: 在窗口和桌面图标后的Dekstop之上
    :level:   一个整数的级别

``--focus-on-open``, ``--no-focus-on-open``
    （macOS独占）在创建时聚焦视频窗口，使其成为最前面的窗口。这在默认情况下是打开的。

``--border``, ``--no-border``
    播放视频时带有窗口边框和装饰。由于这是默认开启的，使用 ``--no-border`` 来禁用标准的窗口装饰。

``--on-all-workspaces``
    （X11和macOS独占）在所有虚拟桌面上显示视频窗口。

``--geometry=<[W[xH]][+-x+-y][/WS]>``, ``--geometry=<x:y>``
    调整初始窗口的位置或大小。 ``W`` 和 ``H`` 以像素为单位设置窗口大小。 ``x`` 和 ``y`` 设置窗口位置，从屏幕的左上角到正在显示的图像的左上角，以像素计算。如果在参数后给了一个百分比符号（ ``%`` ），就会把这个值变成该方向上屏幕尺寸的百分比。位置的指定类似于标准的X11 ``--geometry`` 选项格式，例如，+10-50表示“从左边框开始放置10个像素，从下边框开始放置50个像素”，"-20+-10"表示“从右边框开始放置20个像素，从上边框开始放置10个像素”。末尾的 ``/`` 后接一个整数，表示窗口应该出现在哪个工作区（虚拟桌面）（X11独占）。

    如果使用 ``--wid`` 选项指定一个外部窗口，这个选项将被忽略。

    对于完全支持 ``--screen`` 的视频输出驱动，坐标是相对于 ``--screen`` 给出的屏幕的。

    .. note::

        一般而言只受GUI视频输出驱动的支持。编码时会被忽略。

    .. admonition:: 注意（macOS）

        在macOS上，屏幕坐标系的原点位于左下角。例如， ``0:0`` 将把窗口放在屏幕的左下方。

    .. admonition:: 注意（X11）

        这个选项并不能在所有的窗口管理器中正常工作。

    .. admonition:: 示例

        ``50:40``
            将窗口放在x=50, y=40的位置。
        ``50%:50%``
            将窗口放置在屏幕的中央。
        ``100%:100%``
            将窗口放置在屏幕的右下角。
        ``50%``
            将窗口宽度设置为屏幕宽度的一半。窗口高度的设置是为了使窗口具有视频的长宽比。
        ``50%x50%``
            强制窗口的宽度和高度为屏幕宽度和高度的一半。将显示黑边来补偿视频的长宽比（适用于大多数视频输出驱动且没有带 ``--no-keepaspect`` ）。
        ``50%+10+10/2``
            将窗口设置为屏幕宽度的一半，并将其定位在屏幕左上角下/左10个像素，在第二个工作区。

    另参见 ``--autofit`` 和 ``--autofit-larger`` ，用于在不改变长宽比的情况下让窗口匹配一个给定的尺寸。

``--autofit=<[W[xH]]>``
    将初始窗口尺寸设置为由 ``WxH`` 指定的最大尺寸，不改变窗口的长宽比。尺寸以像素为单位计算，如果数字后有百分比符号（ ``%`` ），则以屏幕大小的百分数为单位。

    该选项永远不改变窗口的长宽比。如果长宽比不匹配，窗口的尺寸就会缩小，直到匹配到指定的尺寸。

    窗口的位置不纳入考虑，也不被这个选项修改（窗口管理器仍然可能根据尺寸的不同来放置窗口）。使用 ``--geometry`` 来改变窗口的位置。它的效果会在这个选项之后应用。

    详见 ``--geometry`` 以了解如何处理多显示器的设置。

    如果你只想限制窗口的最大尺寸，而不是总是强制一个窗口尺寸，请使用 ``--autofit-larger`` 代替。

    如果你想把窗口的宽度和高度都强制到一个特定的尺寸，请使用 ``--geometry``

    .. note::

        一般而言只受GUI视频输出驱动的支持。编码时会被忽略。

    .. admonition:: 示例

        ``70%``
            使窗口宽度为屏幕尺寸的70%，保持宽高比。
        ``1000``
            设置窗口宽度为1000像素，保持长宽比。
        ``70%x60%``
            使窗口尽可能大，不超过屏幕宽度的70%，或不超过屏幕高度的60%。

``--autofit-larger=<[W[xH]]>``
    这个选项的行为与 ``--autofit`` 完全一样，只有在窗口会大于指定的尺寸时才会改变窗口大小。

    .. admonition:: 示例

        ``90%x80%``
            如果视频超过屏幕宽度的90%或屏幕高度的80%，使窗口变小，直到其宽度为屏幕的90%，或高度为屏幕的80%。

``--autofit-smaller=<[W[xH]]>``
    这个选项的行为与 ``--autofit`` 完全一样，只是它设置了窗口的最小尺寸（就像 ``--autofit-larger`` 设置的最大尺寸一样）。

    .. admonition:: 示例

        ``500x500``
            使窗口至少有500像素宽和500像素高（根据视频的长宽比，宽度或高度将大于500，以保持长宽比相同）。

``--window-scale=<factor>``
    将视频窗口的大小调整为视频大小的倍数（或分数）。该选项在 ``--autofit`` 和其它选项应用之前应用（所以它们覆盖此选项）。

    例如， ``--window-scale=0.5`` 将显示窗口为视频尺寸的一半。

``--window-minimized=<yes|no>``
    视频窗口是否被最小化。如果当前视频输出驱动支持的话，设置这个将最小化或取消最小化视频窗口。注意，有些视频输出驱动可能支持最小化而不支持取消最小化（例如：Wayland）。

    这个选项和 ``--window-maximized`` 是在程序启动时还是在运行时工作，以及它们是否（在运行时）被更新以反映实际的窗口状态，很大程度上取决于视频输出驱动和窗口系统。有些视频输出驱动根本没有实现它们或其中的一部分，而其它视频输出驱动可能受到窗口系统的限制（尤其是Wayland）。

``--window-maximized=<yes|no>``
    视频窗口是否被最大化。如果当前视频输出驱动支持的话，设置这个将最大化或取消最大化视频窗口。更多详见 ``--window-minimized``

``--cursor-autohide=<number|no|always>``
    使鼠标指针在指定的毫秒数后自动隐藏（默认： 1000 ）。 ``no`` 将禁用光标自动隐藏功能。 ``always`` 表示光标将保持隐藏。

``--cursor-autohide-fs-only``
    如果给出这个选项，光标在窗口模式下总是可见的。在全屏模式下，光标会根据 ``--cursor-autohide`` 显示或隐藏。

``--no-fixed-vo``, ``--fixed-vo``
    ``--no-fixed-vo`` 加载多个文件时强制关闭和重新打开视频窗口（每个文件都有一个（未）初始化）。

``--force-rgba-osd-rendering``
    改变一些视频输出渲染OSD和文本字幕的方式。这并不改变字幕的外观，只对性能有影响。对于支持原生ASS渲染的视频输出（如 ``gpu``, ``vdpau``, ``direct3d`` ），这可能会稍快或稍慢，取决于GPU驱动和硬件。对于其它视频输出，这只会使渲染变慢。

``--force-render``
    不论窗口的可见性，强制mpv始终渲染帧。目前只影响X11和Wayland视频输出驱动，因为只有它们具有这种优化（即其它的输出都是不考虑可见性进行渲染）。

``--force-window-position``
    每当视频参数、视频流或文件有变化时，强制将mpv的视频输出窗口移到默认位置。这曾经是默认行为。目前只影响到X11视频输出驱动。

``--auto-window-resize=<yes|no>``
    (Wayland, Win32 或 X11) 默认情况下，如果视频的大小发生变化，mpv会自动调整自己的大小（例如，在播放列表中向前跳转）。把这个选项设置为 ``no`` 就可以阻止该行为，因此窗口的大小不会自动改变。这个选项对 ``--autofit`` 和 ``--geometry`` 选项没有任何影响。

``--no-keepaspect``, ``--keepaspect``
    ``--no-keepaspect`` 会始终将视频拉伸到窗口大小，并禁用窗口管理器的提示的窗口强制长宽比。（在全屏模式下被忽略）

``--no-keepaspect-window``, ``--keepaspect-window``
    ``--keepaspect-window`` （默认）会将窗口尺寸锁定为视频长宽。 ``--no-keepaspect-window`` 禁用这一行为，如果窗口的长宽和视频的长宽不匹配，则会增加黑条。这是否真的有效，取决于视频输出的后端。（在全屏模式下被忽略）

``--monitoraspect=<ratio>``
    设置你的显示器或电视屏幕的长宽比。如果数值为0，则禁用之前的设置（例如在设置文件中）。如果启用，将覆盖 ``--monitorpixelaspect`` 的设置。

    另参见 ``--monitorpixelaspect`` 和 ``--video-aspect-override``

    .. admonition:: 示例

        - ``--monitoraspect=4:3`` 或 ``--monitoraspect=1.3333``
        - ``--monitoraspect=16:9`` 或 ``--monitoraspect=1.7777``

``--hidpi-window-scale``, ``--no-hidpi-window-scale``
    （macOS, Windows, X11, 和Wayland独占） 根据支持的比例系数来缩放窗口大小（默认： yes）。在常规的HiDPI分辨率下，窗口以双倍的尺寸打开，但在非HiDPI分辨率下看起来有相同的尺寸。

``--native-fs``, ``--no-native-fs``
    （macOS独占）使用操作系统的原生全屏机制（默认： yes）。

``--monitorpixelaspect=<ratio>``
    设置你的显示器或电视屏幕的单个像素的长宽比（默认： 1）。值1表示方形像素（对（几乎？）所有LCD都是正确的）。另参见 ``--monitoraspect`` 和 ``--video-aspect-override``

``--stop-screensaver=<yes|no|always>``
    在启动时关闭屏幕保护程序（或屏幕blanker和类似机制），在退出时再次打开（默认： yes）。当使用 ``yes`` 时，屏幕保护程序将在播放不激活时被重新启用。 ``always`` 将始终禁用屏幕保护程序。注意只能在有视频输出的情况下才能停止屏保（例如，有一个打开的mpv窗口）。

    这不在所有的视频输出或平台上都受支持。有时它被实现了，但并不工作（特别是在Linux“桌面”上）。请仔细阅读 `禁用屏保`_ 部分。

``--wid=<ID>``
    这告知mpv附加到一个现有的窗口。如果选择了支持该选项的视频输出驱动，它将使用该窗口进行视频输出。mpv将根据该窗口的大小缩放视频，如果视频的长宽比不同，将添加黑条来补偿。

    在X11上，该ID被解释为X11上的一个 ``Window`` 。与MPlayer/mplayer2不同，mpv始终创建自己的窗口，并将wid窗口设置为父窗口。该窗口将始终重新调整大小来完全覆盖父窗口。值 ``0`` 被特别解释，mpv将直接在根窗口上绘制。

    在win32上，ID被解释为 ``HWND`` 。将其作为值转换传递给 ``uint32_t`` （所有的Windows句柄都是32位的）。 mpv将创建自己的窗口，并将窗口设置为父窗口，就像X11一样。

    在macOS/Cocoa上，ID被解释为 ``NSView*`` 。将其作为值转换传递给 ``intptr_t`` ，mpv将创建自己的子视图。因为macOS不支持外来进程的窗口内嵌，这只适用于libmpv，从命令行使用时会崩溃。

    在Android上，ID会被解释为 ``android.view.Surface`` 。将其作为值转换传递给 ``intptr_t`` 。与 ``--vo=mediacodec_embed`` 和 ``--hwdec=mediacodec`` 一起使用，以便使用MediaCodec直接渲染，或者与 ``--vo=gpu --gpu-context=android`` 一起使用（带或者不带 ``--hwdec=mediacodec`` ）。

``--no-window-dragging``
    当鼠标点击在窗口上并移动指针时，不移动窗口。

``--x11-name=<string>``
    为基于X11的视频输出方法设置窗口类名称。

``--x11-netwm=<yes|no|auto>``
    （X11独占）控制NetWM协议功能的使用。

    这可能对损坏的窗口管理器有帮助，也可能没有。这提供了一些现已被移除的 ``--fstype`` 选项实现的功能。实际上，开发人员并不知道这个选项被需要到什么程度，所以欢迎反馈。

    具体来说， ``yes`` 将强制使用NetWM的全屏支持，即使WM没有宣传过。这对那些故意破坏的WM很有用，比如XMonad（据说XMonad没有宣传全屏支持，是因为Flash使用它）。显然，那些想使用全屏的应用程序应该忽略NetWM的支持提示，或者提供一个变通方案。XMonad故意破坏X协议，真是太可耻了（好像X还不够坏似的）。

    默认情况下，NetWM支持是自动检测的（ ``auto`` ）。

    这个选项在将来可能会被移除。

``--x11-bypass-compositor=<yes|no|fs-only|never>``
    如果设置为 ``yes`` ，则要求合成器取消对mpv窗口的重定向（默认： ``fs-only`` ）。这使用了 ``_NET_WM_BYPASS_COMPOSITOR`` 的提示。

    ``fs-only`` 要求窗口管理器只在全屏模式下禁用合成器。

    ``no`` 将 ``_NET_WM_BYPASS_COMPOSITOR`` 设置为0，这是EWMH规范所声明的默认值，也就是说，不做任何改变。

    ``never`` 要求窗口管理器永不禁用合成器。

``--x11-present=<no|auto|yes>``
    是否使用来自X11演示扩展的演示统计（默认： ``auto`` ）。

    mpv向X11询问目前的事件，然后它可以使用这些事件进行更精确的帧呈现。这只有在使用 ``--video-sync=display-...`` 时才有效果。

    ``auto`` 选项列举了自动检测的XRandr提供者。如果找到amd、radeon、intel或nouveau（标准的x86 Mesa驱动），并且没有找到nvidia，就会启用演示反馈。其它驱动不被认为可以工作，所以它们不会被自动启用。

    ``yes`` 或 ``no`` 仍然可以被传递，以启用/禁用这一机制，以防你的硬件/驱动程序/等等的组合出现好/坏的行为。


光盘设备
--------

``--cdrom-device=<path>``
    指定CD-ROM的路径（默认： ``/dev/cdrom`` ）。

``--dvd-device=<path>``
    指定DVD设备或ISO文件名（默认： ``/dev/dvd`` ）。你也可以指定一个包含之前直接从DVD复制文件出来的目录（例如，使用 vobcopy ）。

    .. admonition:: 示例

        ``mpv dvd:// --dvd-device=/path/to/dvd/``

``--bluray-device=<path>``
    （Blu-ray独占）指定蓝光光盘的位置。必须是一个具有蓝光结构的目录。

    .. admonition:: 示例

        ``mpv bd:// --bluray-device=/path/to/bd/``

``--cdda-...``
    这些选项可以用来调节mpv的CD音频读取功能。

``--cdda-speed=<value>``
    设置CD的旋转速度。

``--cdda-paranoia=<0-2>``
    设置偏移水平。0以外的值似乎会破坏第一个以外的任何轨道的播放。

    :0: 禁用检查（默认）
    :1: 只检查重叠部分
    :2: 完整的数据修正和验证

``--cdda-sector-size=<value>``
    设置atomic读取大小。

``--cdda-overlap=<value>``
    在验证过程中强制最小重叠搜索到 <value> 扇区。

``--cdda-toc-bias``
    假设目录树中报告的第1轨的起始偏移量将被寻址为LBA 0。 一些光盘需要这样才能正确获得轨道边界。

``--cdda-toc-offset=<value>``
    在寻址轨道时，在报告的数值上增加 ``<value>`` 扇区。可能是负值。

``--cdda-skip=<yes|no>``
    （永不）接受不完美的数据重建。

``--cdda-cdtext=<yes|no>``
    输出CD文本。这在默认情况下是禁用的，因为它会因未知原因损坏CD-ROM驱动器的性能。

``--dvd-speed=<speed>``
    尝试限制DVD的速度（默认： 0 ，不改变）。DVD的基础速度是1385 kB/s，所以一个8x的驱动器的读取速度可以达到11080 kB/s。较慢的速度使硬盘更安静。针对观看DVD，2700 kB/s应该足够安静和快速。mpv在关闭时将速度重置为驱动器的默认值。取值超过100则表示速度的单位是kB/s。取值低于100的则表示1385 kB/s的倍数，例如 ``--dvd-speed=8`` 选择了11080 kB/s。

    .. note::

        你需要有对DVD设备的写入权限才能变更速度。

``--dvd-angle=<ID>``
    一些DVD包含可以从多个角度观看的场景。该选项告知mpv要使用哪个角度（默认： 1）。



均衡器
------

``--brightness=<-100-100>``
    调整视频信号的明度（默认： 0）。不是所有的视频输出驱动都支持。

``--contrast=<-100-100>``
    调整视频信号的对比度（默认： 0）。不是所有的视频输出驱动都支持。

``--saturation=<-100-100>``
    调整视频信号的饱和度（默认： 0）。用这个选项可以得到灰度输出。不是所有的视频输出驱动都支持。

``--gamma=<-100-100>``
    调整视频信号的伽玛（默认： 0）。不是所有的视频输出驱动都支持。

``--hue=<-100-100>``
    调整视频信号的色相（默认： 0）。用这个选项可以得到图像的彩色底片。不是所有的视频输出驱动都支持。

解复用器
--------

``--demuxer=<[+]name>``
    强制使用的解复用器类型。在名称前使用'+'来强制它；这将跳过一些检查。可给的解复用器名称和 ``--demuxer=help`` 输出的一样。

``--demuxer-lavf-analyzeduration=<value>``
    分析流属性的最大长度，以秒为单位。

``--demuxer-lavf-probe-info=<yes|no|auto|nostreams>``
    是否探测流的信息（默认： auto）。技术上讲，这控制了是否调用libavformat的 ``avformat_find_stream_info()`` 函数。通常情况下，调用它比较安全，但它也可能使启动变慢。

    ``auto`` 的选择（默认）尝试对一些已知安全的白名单中的格式跳过该功能，而对所有其它格式调用。

    ``nostreams`` 的选择只在文件打开后，似乎不包含流的情况下才调用（在需要调用该函数来检测流的情况下很有帮助，比如FLV文件）。

``--demuxer-lavf-probescore=<1-100>``
    请求libavformat的最低探测分数。较低的值需要加载更少的数据（使流启动的更快），但使文件格式检测不那么可靠。可以用来强制自动检测 libavformat 的解复用器，即使 libavformat 认为检测结果不够可靠。（默认： 26）

``--demuxer-lavf-allow-mimetype=<yes|no>``
    允许从HTTP MIME类型衍生出的格式（默认： yes）。如果从HTTP播放文件时神秘的失败，即使同样的文件在本地磁盘上能正常播放，则将此设置为 no 。

    它的默认值是为了以减少打开HTTP流时的延迟。

``--demuxer-lavf-format=<name>``
    强制使用一个指定的libavformat解复用器。

``--demuxer-lavf-hacks=<yes|no>``
    默认情况下，其中一些格式与其它格式不同，将通过明确的检查来处理。其中大多数是对libavformat解复用器的怪异或不完美行为的补偿。传递 ``no`` 将禁用这些格式。仅用于调试和测试。

``--demuxer-lavf-o=<key>=<value>[,<key>=<value>[,...]]``
    将AVOptions传递给libavformat解复用器。

    注意，欢迎打补丁，使 *o=* 不需要，并通过AVOption系统传递所有未知的选项。AVOptions的完整列表可以在FFmpeg手册中找到。注意，一些选项可能与mpv的选项冲突。

    这是一个按键/值列表选项。详见 `列表选项`_

    .. admonition:: 示例

        ``--demuxer-lavf-o=fflags=+ignidx``

``--demuxer-lavf-probesize=<value>``
    在检测阶段探测的最大数据量。在MPEG-TS的情况下，这个值确定了要扫描的最大TS packets 的数量。

``--demuxer-lavf-buffersize=<value>``
    为libavformat分配的流读取缓冲区的大小，以字节为单位（默认： 32768）。减少该尺寸可以降低延迟。注意，libavformat可能会在内部重新分配缓冲区，或者不完全使用所有的缓冲区。

``--demuxer-lavf-linearize-timestamps=<yes|no|auto>``
    试图对解复用后的流中的时间戳重置进行线性化处理（默认： auto）。这只对单一音频流进行了测试。不知道它对视频是否正常工作（但可能不会）。请注意，无论哪种方式的实现都有点不正确，并且会引入大约1个编码帧大小的不连续性。

    ``auto`` 模式对OGG音频流启用这个功能。这涵盖了OGG网络广播流的常见和恼人的情况。其中一些会在每次新歌开始时将时间戳重置为0。这破坏了mpv的可寻址缓存，它无法处理时间戳的重置。请注意，FFmpeg/libavformat的跳转API也不能处理这个问题；如果这个选项对这个问题的破坏更大，而如果它被禁用，你至少可以在流中的第一首歌内跳转。好吧，如果在mpv的缓存之外跳转，你也不会获得任何有用的东西。

``--demuxer-lavf-propagate-opts=<yes|no>``
    传播FFmpeg级别的选项到递归打开的连接（默认： yes）。这是有必要的，因为FFmpeg会自动将这些设置应用到嵌套的AVIO上下文。另一方面，在某些情况下这可能会破坏 —— 这是FFmpeg的API，你不可能赢。

    这尤其影响到 ``--timeout`` 选项和任何与 ``--demuxer-lavf-o`` 一起传递的东西。

    如果这个选项在未来的某个时候被认为是不必要的，它将被删除而不另行通知。

``--demuxer-mkv-subtitle-preroll=<yes|index|no>``, ``--mkv-subtitle-preroll``
    当在某处跳转时，更努力的显示内嵌的软字幕。正常情况下，由于一些容器文件格式的设计，可能会发生在跳转目标处的字幕不显示的情况。只有在跳转之前或正好在字幕首次出现的位置时，字幕才会出现。更糟的是，字幕的出现时间往往比相关的视频帧提前很久，因此，跳转视频帧通常不会在该位置解复用字幕。

    启用这个选项使解复用器在跳转目标的前方一点开始读取数据，从而使字幕正确出现。请注意，这将使跳转变慢，而且不能保证始终有效。它只在字幕足够接近跳转目标时才起作用。

    只对内部的Matroska解复用器起作用。始终则对绝对跳转和精确跳转启用，这个选项只改变相对或不精确的跳转行为。

    你可以使用 ``--demuxer-mkv-subtitle-preroll-secs`` 选项来指定解复用器最多应该预读多少数据，以便找到可能重叠的字幕packets。将此设置为0将有效地禁用这种预滚动机制。设置一个非常大的值会使跳转变得非常慢，而且一个非常大的值会在每次跳转时从开始到跳转目标完全重读整个文件 —— 在文件的最后，跳转会变得更慢。细节很混乱，这个值实际上是四舍五入到与前一个视频关键帧的簇。

    一些文件，特别是用较新的mkvmerge版本混流的文件，有内嵌的信息，可以用来确定哪些字幕packets与跳转目标重叠。在这些情况下，mpv会将读取的数据量降到最低（尽管它仍然会读取 *所有* 包含第一个想要的字幕packets的集群和跳转目标之间的数据）。如果指定了 ``index`` 的选择（这是默认值），那么只有在这个信息实际可用的情况下才会进行预滚动。如果使用这种方法，跳过的最大数据量可以由 ``--demuxer-mkv-subtitle-preroll-secs-index`` 来控制（它仍然使用没有 ``-index`` 的选项的值，如果该值更高的话）。

    零参见 ``--hr-seek-demuxer-offset`` 选项。 这个选项可以达到类似的效果，但是只有在精确跳转激活的情况下。它适用于任何解复用器，但会使跳转速度大幅降低，因为它必须解码音频和视频数据，而不只是跳过它们。

    ``--mkv-subtitle-preroll`` 是一个已过时的别名。

``--demuxer-mkv-subtitle-preroll-secs=<value>``
    参见 ``--demuxer-mkv-subtitle-preroll``

``--demuxer-mkv-subtitle-preroll-secs-index=<value>``
    参见 ``--demuxer-mkv-subtitle-preroll``

``--demuxer-mkv-probe-start-time=<yes|no>``
    检查Matroska文件的开始时间（默认： yes）。这简单的读取第一个簇的时间戳，并假定它是开始时间。技术上来说，这也读取第一个时间戳，它可能会增加一帧的延迟（这可能与直播流有关）。

``--demuxer-mkv-probe-video-duration=<yes|no|full>```
    当打开文件时，跳转到文件的结尾，并检查最后一个视频packet的时间戳，并将其报告为文件的持续时间。这仅仅是为了与Haali兼容。在这种模式下，打开文件的速度可能会变慢（特别是在通过http播放时），或者对损坏的文件的处理会更糟糕。所以不要使用该选项。

    ``yes`` 模式只是使用索引，并从文件的末端读取少量的块。 ``full`` 模式实际上是遍历整个文件，即使没有索引也能做出可靠的估计（比如分部的文件）。

``--demuxer-rawaudio-channels=<value>``
    如果使用 ``--demuxer=rawaudio`` ，声道的数量（或声道布局）（默认： stereo）。

``--demuxer-rawaudio-format=<value>``
    ``--demuxer=rawaudio`` 的采样格式（默认： s16le）。使用 ``--demuxer-rawaudio-format=help`` 来获得所有格式的列表。

``--demuxer-rawaudio-rate=<value>``
    ``--demuxer=rawaudio`` 的采样率（默认： 44kHz）。

``--demuxer-rawvideo-fps=<value>``
    ``--demuxer=rawvideo`` 的每秒帧数（默认： 25.0）。

``--demuxer-rawvideo-w=<value>``, ``--demuxer-rawvideo-h=<value>``
    ``--demuxer=rawvideo`` 的图像尺寸，以像素为单位。

    .. admonition:: 示例

        播放一个 raw YUV 样本：

            mpv sample-720x576.yuv --demuxer=rawvideo \
            --demuxer-rawvideo-w=720 --demuxer-rawvideo-h=576

``--demuxer-rawvideo-format=<value>``
    ``--demuxer=rawvideo`` 的色彩空间（fourcc）的十六进制或字符串（默认： ``YV12`` ）。

``--demuxer-rawvideo-mp-format=<value>``
    ``--demuxer=rawvideo`` 的内部视频格式的色彩空间。使用 ``--demuxer-rawvideo-mp-format=help`` 获得可能的格式的列表。

``--demuxer-rawvideo-codec=<value>``
    设置视频编码，而不是在使用 ``--demuxer=rawvideo`` 时选择的 rawvideo 编码。它使用与 ``--vd`` 中的编解码器名称相同的值（但它不接受解码器的名称）。

``--demuxer-rawvideo-size=<value>``
    当使用 ``--demuxer=rawvideo`` 时帧的大小，以字节为单位。

``--demuxer-cue-codepage=<codepage>``
    指定CUE表的代码页。（详见 ``--sub-codepage`` ）。

``--demuxer-max-bytes=<bytesize>``
    这控制了解复用器允许提前缓冲的量。一般来说，解复用器会根据需要尽量提前读取，或者根据 ``--demuxer-readahead-secs`` 的请求来进行。该选项可以用来限制最大的预读数。这限制了在文件损坏或播放不同步的情况下过多的预读取。一旦达到其中一个限制，解复用器将停止读取额外的packets（由于技术原因，这些限制仍然可以被略微超出）。

    如果你得到一个packet队列溢出的警告，并且你认为用一个更大的packet队列可以正常播放，那么就把这些限制设得更高。

    默认值和取值范围参见 ``--list-options`` 。 ``<bytesize>`` 选项接受后缀，比如 ``KiB`` 和 ``MiB``

``--demuxer-max-back-bytes=<bytesize>``
    这控制了解复用器允许保留多少过去的数据。这只有在启用缓存时才有用。

    与前向缓存不同，没有控制实际缓存的秒数 —— 它将简单地使用该选项允许的内存。把这个选项设置为0将严格禁止任何后缓存，但这将导致前向寻址范围从当前播放位置之后开始的情况（因为它删除了作为寻址点的过去的packets）。

    如果到达文件的末端，剩余的未使用的前向缓冲区空间将被“捐献”给后向缓冲区（除非后向缓冲区的大小被设置为0，或者 ``--demuxer-donate-buffer`` 被设置为 ``no`` ）。这仍然限制了缓存的总使用量为前向和后向缓存的总和，并有效地更好地利用了允许的总内存预算。（相反的情况不会发生：空闲的后向缓冲区永远不会被“捐献”给前向缓冲区。)

    请记住，播放器中的其他缓冲区（如解码器）会导致解复用器将“未来”帧缓存在后缓冲区中，这可能会扭曲关于后缓冲区包含多少数据的印象。

    参见 ``--list-options`` ，了解默认值和取值范围。

``--demuxer-donate-buffer=<yes|no>``
    是否让后缓冲区使用前缓冲区的一部分（默认： yes）。如果设置为 ``yes`` ，则启用 ``--demuxer-max-back-bytes`` 选项描述中的“捐献”行为。这意味着后缓冲区可以使用的内存达到前和后缓冲区选项的总和，减去前缓冲区的活动大小。如果设置为 ``no`` ，选项会严格限制前和后缓冲区的大小。

    注意，如果到达文件的末尾，缓冲的数据保持不变，即使你在缓冲区内回头跳转。这是因为只有在读取新的数据时才会减少后缓冲区。

``--demuxer-seekable-cache=<yes|no|auto>``
    调试选项，控制跳转是否可以使用解复用器缓存（默认： auto）。通常你不需要设置这个选项；如果 ``--cache`` 被设置为 ``yes`` （或者如果 ``--cache=auto`` ，则暗示为 ``yes`` ），默认的 ``auto`` 会做正确的事情并启用缓存跳转。

    如果启用，短的寻道偏移将不会触发低级别的解复用器寻道（这意味着，例如可以避免缓慢的网络往返或FFmpeg寻道错误）。如果跳转不能在缓存范围内发生，将触发一个低级别的寻址。在缓冲区外跳转将开始一个新的缓冲范围，但如果解复用器表现出某些不被支持的行为，可能丢弃旧的缓冲范围。

    特殊值 ``auto`` 表示在与 ``--cache-secs`` 相同的情况下 ``yes`` （即当流出现在网络或流缓存被启用时）。

``--demuxer-force-retry-on-eof=<yes|no>``
    是否在解码器每次排队时不断重试，使解复用器线程读取更多的packets，即使已经到达文件的末端（默认： no）。这其实没有什么意义，但在mpv0.32.0和更早的版本中是默认行为。这个选项在一段时间后会被默默移除，它的存在只是为了恢复旧的行为以备测试，以防在某些地方确实需要这样做。这对正在被追加的文件没有帮助（在这种情况下，使用 ``appending://`` ，或者禁用缓存）。

``--demuxer-thread=<yes|no>``
    在一个单独的线程中运行解复用器，并让它预取一定数量的packets（默认： yes）。启用这个功能可以使播放更顺畅，启用预取等功能，并防止网络卡住使播放器冻结。另一方面，它可能会增加开销，或者后台预取会占用CPU资源。

    不建议禁用这个选项。只在调试时使用它。

``--demuxer-termination-timeout=<seconds>``
    播放器应该等待多少秒来关闭解复用器（默认： 0.1）。在强行关闭流层之前，播放器将最多等待这么长的时间。强制关闭通常意味着网络I/O没有机会优雅地关闭它的连接（当然操作系统仍然可以正确地关闭TCP连接），可能会导致恼人的信息被记录下来，在某些情况下，会使远程服务器混乱。

    这个超时通常只在加载已经正常完成的情况下应用。如果加载被用户中止，或者在某些极端的情况下，比如在播放过程中移除来自网络的外部音轨，强制关闭始终会被使用。

``--demuxer-readahead-secs=<seconds>``
    如果 ``--demuxer-thread`` 被启用，这控制了解复用器应该提前多少秒缓冲（默认： 1）。只要没有packet的时间戳差异高于相对于返回给解码器的最后一个packet的预读量，解复用器就会保持读取。

    注意，启用缓存（如 ``--cache=yes`` ，或者如果输入被认为是网络流，并使用 ``--cache=auto`` ），这个选项几乎会被忽略（ ``--cache-secs`` 将覆盖这个选项。技术上讲，使用两个选项的最大值）。

    这个选项的主要目的是限制本地播放的预读，因为一个大的预读值在这种情况下没有太大作用。

    （这个值往往是模糊的，因为许多文件格式不存储线性时间戳。）

``--demuxer-hysteresis-secs=<seconds>``
    一旦达到 ``--demuxer-max-bytes`` 的限制，该值可以用来指定在解复用器再次提前缓冲前的滞后时间。这指定了从当前播放位置开始，在解复用器继续提前缓冲之前，需要在缓存中剩余的最大秒数。

    例如，指定一个10秒的值，解复用器将提前缓冲到 ``--demuxer-max-bytes`` ，直到缓存中只剩下10秒的内容，才会再次开始缓冲。当解复用器再次开始提前缓冲时，它将提前缓冲到 ``--demuxer-max-bytes`` 然后停止，直到缓存中只剩下10秒的内容，以此类推。

    这可以显著节省功耗，并通过使解复用器一次只缓冲几块内容而不是不停地缓冲以保持缓冲区的填充来减少负载。

    如果你想省电并减少负载，把它设置成一个比 ``--cache-secs`` 或 ``--demuxer-readahead-secs`` 低得多的数值。如果对于一个给定的数据流，需要很长的时间来缓冲任何东西（比如从一个非常慢的磁盘上读取），那么应该提高滞后值进行补偿。

    默认值是0秒，这将禁用缓存滞后。一个10秒的值可能对大多数情况都有效。

``--prefetch-playlist=<yes|no>``
    在当前项目的播放结束时预取下一个播放列表项目（默认： no）。

    这不会将下一个URL的视频数据预填充到缓存中。预取的视频数据只受当前的播放列表条目支持，并取决于解复用器缓存设置（默认启用）。这只用在当前的URL被完全读取后，打开下一个播放列表的URL。

    这对由 ``youtube-dl`` 封装器解析的URL **没** 效果，也不会起作用。

    如果使用特定文件的选项，或者在预取开始和下一个文件播放之间的时间窗口内改变选项，这可能会产生微妙错误的结果。

    这可能偶尔会做出错误的预取判定。例如，它不能预测你是否在播放列表中回退，并假定你不会编辑播放列表。

    它是高度实验性的。

``--force-seekable=<yes|no>``
    如果播放器认为媒体文件是不可跳转的（例如，从管道中播放，或者是http流的服务器不支持范围的请求），跳转将被禁用。这个选项可以强行启用它。对于缓存中的跳转，有很大的成功机会。

``--demuxer-cache-wait=<yes|no>``
    在开始播放之前读取数据，直到到达文件的末端，或者解复用器缓存达到最大容量。只有当这一切完成后，播放才开始。这故意发生在用 ``--start`` 触发的初始搜索之前。这不会改变初始缓存后的任何运行时行为。如果文件不能被完全缓存，该选项无用。

``--rar-list-all-volumes=<yes|no>``
    当打开多卷rar文件时，打开所有卷以创建一个包含文件的完整列表（默认： no）。如果禁用，只有标题位于第一卷内的存档条目被列出（因此在用mpv打开.rar文件时播放）。这样做可以加快打开速度，而且典型的白痴用例，即播放包含单个媒体文件的未压缩的多卷rar文件，也变得更快。

    打开的速度仍然很慢，因为出于未知的、愚蠢的和不必要的原因，libarchive在播放主文件时还是会打开所有卷，尽管mpv还没有迭代出任何存档条目。

输入
----

``--native-keyrepeat``
    使用系统设置的按键重复的延迟和速率，而不是 ``--input-ar-delay`` 和 ``--input-ar-rate`` （这是否应用取决于视频输出的后端和它如何处理键盘输入。不应用于终端输入）。

``--input-ar-delay``
    在开始前自动重复一个按键的延迟，以毫秒为单位（0为禁用）。

``--input-ar-rate``
    在自动重复中每秒产生的按键按压的数量。

``--input-conf=<filename>``
    指定输入设置文件，而不是mpv设置目录中的默认位置（通常是 ``~/.config/mpv/input.conf`` ）。

``--no-input-default-bindings``
    禁用默认等级的（“弱”）按键键绑定。这些是设置文件比如 ``input.conf`` 可以覆盖的绑定。目前它影响到内置的按键绑定，以及脚本使用 ``mp.add_key_binding`` 绑定的按键（但不包括 ``mp.add_forced_key_binding`` ，因为这会覆盖 ``input.conf`` ）。

``--no-input-builtin-bindings``
    在启动时禁用加载内置的按键绑定。这个选项只在(lib)mpv初始化时应用，如果使用的话，以后就不可能再启用它们。可能对libmpv clients有用。

``--input-cmdlist``
    输出所有可以绑定到按键的命令。

``--input-doubleclick-time=<milliseconds>``
    将连续两次按键识别为一次双击的时间，以毫秒为单位（默认： 300）。

``--input-keylist``
    输出所有可以与命令绑定的按键。

``--input-key-fifo-size=<2-65000>``
    指定缓冲按键events的FIFO的大小（默认： 7）。如果它太小，一些events可能会丢失。设置为一个非常大的值的主要缺点是，如果你按住一个按键触发了一些特别慢的命令，那么播放器在处理所有排队的命令时可能无法响应。

``--input-test``
    输入测试模式。mpv不会在按键时执行命令，而是在OSD上显示按键和绑定的命令。必须和一个虚拟视频一起使用，一般的退出播放器的方法将不起作用（通常退出的按键绑定将只显示在OSD上，就像其它的绑定一样）。参见 `INPUT.CONF`_

``--input-terminal``, ``--no-input-terminal``
    ``--no-input-terminal`` 阻止播放器从标准输入读取按键events。在从标准输入读取数据时很有用。当在命令行中发现 ``-`` 时，这将自动启用。有些情况下，你必须手动设置，例如，如果你打开 ``/dev/stdin`` （或你系统中的等价物），在播放列表中使用stdin或打算以后通过loadfile或loadlist输入命令从stdin读取数据。

``--input-ipc-server=<filename>``
    启用IPC支持并在给定的路径上创建监听套接字。

    在Linux和Unix上，给定的路径是一个常规的文件系统路径。在Windows上，使用命名的pipes，所以路径指的是pipe namespace（ ``\\.\pipe\<name>`` ）。如果缺少 ``\\.\pipe\`` 前缀，mpv会在创建pipe前自动添加，所以 ``--input-ipc-server=/tmp/mpv-socket`` 和 ``--input-ipc-server=\\.\pipe\tmp\mpv-socket`` 对于Windows上的IPC是等效的。

    详见 `JSON IPC`_

``--input-ipc-client=fd://<N>``
    连接单个IPC client到给定的FD。这与 ``--input-ipc-server`` 有点相似，只是没有创建套接字，而传递的FD被当作从 ``accept()`` 收到的套接字连接。在实践中，你可以传递一个由 ``socketpair()`` 创建的FD，或者一个pipe。在这两种情况下，你必须确保FD实际上是由mpv继承的（不要设置POSIX的 ``CLOEXEC`` 标志）。

    当连接被关闭时，播放器就会退出。

    这有点类似于被移除的 ``--input-file`` 选项，只是它只支持整数FDs，而不能打开实际的路径。

    .. admonition:: 示例

        ``--input-ipc-client=fd://123``

    .. note::

        在Windows上不适用，将来也不适用。

    .. warning::

        在运行时写入 ``input-ipc-server`` 选项将为 ``input-ipc-client`` 选项启动另一个IPC client句柄实例，因为初始化是捆绑的，这个东西很愚蠢。这是一个错误。在运行时写入到 ``input-ipc-client`` 将为新的值启动另一个IPCclient句柄，而不停止旧的句柄，即使FD值是相同的（但字符串是不同的，例如，由于whitespace）。这不是一个错误。

``--input-gamepad=<yes|no>``
    启用/禁用SDL2游戏手柄支持。默认禁用。

``--input-cursor``, ``--no-input-cursor``
    允许mpv接收由视频输出驱动报告的指针events。必需要使用OSC，或在选中DVD菜单中的按钮。支持与否取决于使用的视频输出驱动。

``--input-media-keys=<yes|no>``
    在mpv可以选择接收媒体按键或让系统处理媒体按键的系统中 —— 这个选项控制mpv是否应该接收媒体按键。

    默认： yes（除了libmpv）。macOS和Windows独占，因为在其它地方mpv没有选择 —— 系统决定是否将媒体按键发送给mpv。例如，在X11或Wayland上，没有实现系统级的媒体按键。当mpv窗口被聚焦时，媒体按键是否起作用是由实现定义的。

``--input-right-alt-gr``, ``--no-input-right-alt-gr``
    （Cocoa和Windows独占）将右Alt键作为Alt Gr来产生特殊字符。如果禁用，将右键Alt算作Alt修饰键。默认启用。

``--input-vo-keyboard=<yes|no>``
    对于不能参与正确的键盘输入调度的视频输出驱动，禁用所有键盘输入。可能不会影响所有的视频输出。一般而言只对内嵌有用。

    在X11上，一个启用了输入功能的子窗口会抓取所有的键盘输入，只要它是 1.一个焦点窗口的子窗口，并且 2.鼠标在子窗口内。 它可以从嵌入mpv窗口的应用程序中窃取所有的键盘输入，另一方面，如果鼠标在mpv窗口之外，即使mpv有焦点，mpv窗口也不会收到任何输入。现代的toolkits可以绕过这个奇怪的X11行为，但是天真的内嵌外部的窗口会破坏它。

    唯一合理处理这个问题的方法是使用XEmbed协议，它是为了解决这些问题而设计的。GTK提供 ``GtkSocket`` ，它支持XEmbed。Qt似乎没有提供任何在较新版本中的工作的东西。

    如果embedder支持XEmbed，输入应该在默认设置下工作，并且禁用这个选项。注意 ``input-default-bindings`` 在libmpv中也是默认禁用的 —— 如果你想要mpv的默认按键绑定，应该启用它。

    （这个选项由 ``--input-x11-keyboard`` 重命名而来）

OSD
---

``--osc``, ``--no-osc``
    是否加载屏显式控制器（默认： yes）。

``--no-osd-bar``, ``--osd-bar``
    禁用OSD条的显示。

    你可以在input.conf中使用 ``osd-`` 前缀在每条命令的基础上进行设置，参见 ``输入命令前缀`` 。如果你想完全禁用OSD，使用 ``--osd-level=0``

``--osd-on-seek=<no,bar,msg,msg-bar>``
    设置在跳转过程中OSD上显示的内容。默认： ``bar``

    你可以在input.conf中使用 ``osd-`` 前缀在每条命令的基础上进行设置，参见 ``输入命令前缀``

``--osd-duration=<time>``
    设置OSD信息的持续时间，以ms为单位（默认： 1000）。

``--osd-font=<name>``
    指定OSD使用的字体。默认： ``sans-serif``

    .. admonition:: 示例

        - ``--osd-font='Bitstream Vera Sans'``
        - ``--osd-font='Comic Sans MS'``

``--osd-font-size=<size>``
    指定OSD的字体大小。详见 ``--sub-font-size``

    默认： 55

``--osd-msg1=<string>``
    在OSD等级1（默认可见）的OSD上显示这个字符串作为信息。该信息默认是可见的，只要没有其它信息挡住它，并且OSD等级无改变（参见 ``--osd-level`` ）。扩展属性；参见 `属性扩展`_

``--osd-msg2=<string>``
    类似于 ``--osd-msg1`` ，但用于OSD等级2。如果这是一个空字符串（默认），那么将显示播放时间。

``--osd-msg3=<string>``
    类似于 ``--osd-msg1`` ，但用于OSD等级3。如果这是一个空字符串（默认），那么就会显示播放时间、持续时间和一些更多的信息。

    当使用 ``show-progress`` 命令时（默认映射到 ``P`` ），以及在input.conf中使用 ``--osd-on-seek`` 或 ``osd-`` 前缀（参见 ``输入命令前缀`` ）进行跳转时，这将覆盖 ``--osd-level=3`` 的状态文本。

    ``--osd-status-msg`` 是一个遗留的等效选项（但有一个微小差异）。

``--osd-status-msg=<string>``
    在播放过程中显示一个自定义的字符串而不是标准的状态文本。当使用 ``show-progress`` 命令时（默认映射到 ``P`` ），以及在input.conf中使用 ``--osd-on-seek`` 或 ``osd-`` 前缀（参见 ``输入命令前缀`` ）进行跳转时，这将覆盖 ``--osd-level=3`` 的状态文本。扩展属性。参见 `属性扩展`_

    这个选项已经被 ``--osd-msg3`` 取代。唯一的区别是该选项隐含了 ``${osd-sym-cc}`` 。如果 ``--osd-msg3`` 不是空的，这个选项将被忽略。

``--osd-playing-msg=<string>``
    当播放开始时在OSD上显示一条信息。字符串被扩展为属性，例如： ``--osd-playing-msg='file: ${filename}'`` 将显示信息 ``file:`` ，后方接的是一个空格和当前播放的文件名。

    参见 `属性扩展`_

``--osd-playing-msg-duration=<time>``
    设置 ``osd-playing-msg`` 的持续时间，以毫秒为单位。如果不设置， ``osd-playing-msg`` 将在以 ``osd-duration`` 设置的时间内停留在屏幕上。

``--osd-bar-align-x=<-1-1>``
    OSD条的位置。-1是最左边，0是中间，1是最右边。允许使用小数值（如0.5）。

``--osd-bar-align-y=<-1-1>``
    OSD条的位置。-1是顶部，0是中间，1是底部。允许使用小数值（如0.5）。

``--osd-bar-w=<1-100>``
    OSD条的宽度，以屏幕宽度的百分比为单位（默认： 75）。50的值表示条的宽度是屏幕的一半。

``--osd-bar-h=<0.1-50>``
    OSD条的高度，以屏幕高度的百分比为单位（默认： 3.125）。

`--osd-back-color=<color>```。
    参见 ``--sub-color`` 。用于OSD文本背景的颜色。

``--osd-blur=<0..20.0>``
    高斯模糊系数。0表示不应用模糊（默认）。

``--osd-bold=<yes|no>``
    格式化文本为粗体。

``--osd-italic=<yes|no>``
    格式化文本为斜体。

``--osd-border-color=<color>``
    参见 ``--sub-color`` 。用于OSD字体边框的颜色。

``--osd-border-size=<size>``
    OSD字体边框的大小，以像素为单位（详见 ``--sub-font-size`` ）。值为0时禁用边框。

    默认： 3

``--osd-color=<color>``
    指定用于OSD的颜色。详见 ``--sub-color``

``--osd-fractions``
    显示带小数点的秒数的OSD时间（精度为毫秒）。有助于查看视频帧的精确时间戳。

``--osd-level=<0-3>``
    指定OSD应该以何种模式启动。

    :0: OSD被完全禁用（仅剩字幕）
    :1: 启用（仅在用户交互时显示）
    :2: 启用 + 默认可见当前时间
    :3: 启用 + ``--osd-status-msg`` （默认为当前时间和状态）

``--osd-margin-x=<size>``
    OSD的左右屏幕边距，以缩放后的像素为单位（详见 ``--sub-font-size`` ）。

    这个选项指定了OSD与左边的距离，以及从右边框到长OSD文本的断开距离。

    默认： 25

``--osd-margin-y=<size>``
    OSD的顶部和底部屏幕边距，以缩放后的像素为单位（详见 ``--sub-font-size`` ）。

    这个选项指定了OSD的垂直边距。

    默认： 22

``--osd-align-x=<left|center|right>``
    控制OSD应该对齐屏幕的哪个角（默认： ``left`` ）。

``--osd-align-y=<top|center|bottom>``
    垂直位置（默认： ``top`` ）。详见 ``--osd-align-x``

``--osd-scale=<factor>``
    OSD字体大小的乘数，与 ``--osd-font-size`` 的值相乘。

``--osd-scale-by-window=<yes|no>``
    是否随窗口尺寸缩放OSD（默认： yes）。如果这个选项被禁用， ``--osd-font-size`` 和其它使用缩放后像素的OSD选项总是以实际像素为准。其影响是，改变窗口尺寸不会改变OSD字体大小。

``--osd-shadow-color=<color>``
    参见 ``--sub-color`` 。用于OSD阴影的颜色。

    .. note::

        当指定 ``--osd-back-color`` 时被忽略（或者更确切地说：当该选项没有设置为完全透明时）。

``--osd-shadow-offset=<size>``
    OSD阴影的位移，以缩放后的像素为单位（详见 ``--sub-font-size`` ）。值为0时禁用阴影。

    默认： 0

``--osd-spacing=<size>``
    水平OSD/字幕字体的间距，以缩放后的像素为单位（详见 ``--sub-font-size`` ）。这个值会加到正常的字母间距上。允许负值。

    默认： 0

``--video-osd=<yes|no>``
    在视频窗口上启用OSD渲染（默认： yes）。这可用于终端OSD是优先的情况。如果你只是想禁用所有的OSD渲染，使用 ``--osd-level=0``

    它不影响字幕或由脚本创建的覆盖层（特别的是，OSC需要用 ``--no-osc`` 来禁用）。

    这个选项在某种程度上是实验性的，将来可能会被另一种机制所取代。

``--osd-font-provider=<...>``
    参见 ``--sub-font-provider`` 了解可接受的值。注意，不同于字幕，OSD从不使用来自媒体文件的内嵌字体。

``--osd-fonts-dir=<path>``
    参见 ``--sub-fonts-dir`` 了解详情。默认为 ``~~/fonts``

屏幕截图
--------

``--screenshot-format=<type>``
    设置用于保存屏幕截图的图像文件类型。

    可用的选择：

    :png:       PNG
    :jpg:       JPEG（默认）
    :jpeg:      JPEG（JPG的别名）
    :webp:      WebP
    :jxl:       JPEG XL

``--screenshot-tag-colorspace=<yes|no>``
    用适当的色彩空间标记屏幕截图。

    注意，不是所有的格式都被支持。

    默认： ``yes``

``--screenshot-high-bit-depth=<yes|no>``
    如果可能的话，用与源视频相似的位深写入截图（默认： yes）。这对PNG来说特别有意思，因为这有时会触发写入16位的PNG，使得文件体积很大。如果使用16比特，这也会在结果文件中内含一个未使用的alpha通道。

``--screenshot-template=<template>``
    指定用于保存屏幕截图的文件名模板。该模板指定了不含扩展名的文件名，并可以包含格式说明符，在截屏时将被替换。默认情况下，模板是 ``mpv-shot%n`` ，这会导致产生类似例如 ``mpv-shot0012.png`` 的文件名。

    模板可以用相对或绝对路径开始，来指定应保存截图的目录位置。

    如果最终的截图文件名指向一个已经存在的文件，该文件将不会被覆盖写入。或者如果模板包含 ``%n`` ，那么就使用不同的、新生成的文件名保存，否则截图将不被保存。

    允许的格式说明符：

    ``%[#][0X]n``
        一个序列数字，用零填充，长度为X（默认： 04）。例如，传递格式 ``%04n`` 将产生的第12张截图是 ``0012`` 。每次截图或文件已经存在的情况下，数字会递增。长度 ``X`` 必须在0-9的范围内。带了可选的#符号，mpv将使用最低的可用数字。例如，如果你截了三张图 —— 0001, 0002, 0003 —— 并删除了前两张，接下来的两张截图就不会是0004和0005，而是0001和0002。
    ``%f``
        当前播放视频的文件名。
    ``%F``
        与 ``%f`` 相同，但剥离文件扩展名，包括点。
    ``%x``
        当前播放视频的目录路径。如果视频不在文件系统上（但例如 ``http://`` ），这将扩展为一个空字符串。
    ``%X{fallback}``
        与 ``%x`` 相同，但如果视频文件不在文件系统上，返回 ``{...}`` 内的回退字符串。
    ``%p``
        当前播放时间，格式与OSD中使用的相同。其结果是一个 "HH:MM:SS" 形式的字符串。例如，如果视频处于5分34秒的时间位置， ``%p`` 将被替换为 "00:05:34" 。
    ``%P``
        类似于 ``%p`` ，但扩展为以毫秒为单位的播放时间。它的格式是 "HH:MM:SS.mm"，其中 "mmm" 是播放时间的毫秒部分。

        .. note::

            这是一个获得独特的每帧时间戳的简单方法（帧数序号会更直观，但不容易被实现，因为容器格式通常使用时间戳来识别帧）。
    ``%wX``
        使用格式化的字符串 ``X`` 指定当前播放时间。 ``%p`` 就像 ``%wH:%wM:%wS`` ， ``%P`` 就像 ``%wH:%wM:%wS.%wT``

        有效的格式说明符：
            ``%wH``
                时（用0到2位数填充）
            ``%wh``
                时（无填充）
            ``%wM``
                分（00-59）
            ``%wm``
                总时间（包括小时，与 ``%wM`` 不同）
            ``%wS``
                秒（00-59）
            ``%ws``
                总秒数 (包括小时和分钟)
            ``%wf``
                类似 ``%ws`` ，但作为浮点数
            ``%wT``
                毫秒（000-999）

    ``%tX``
        使用格式化的 ``X`` 指定当前的本地日期/时间。这个格式说明符在内部使用UNIX的 ``strftime()`` 函数，并插入传递 "%X" 到 ``strftime`` 的结果。例如， ``%tm`` 将插入当前月份的数字。你不得不使用多个 ``%tX`` 说明符来建立一个完整的日期/时间字符串。
    ``%{prop[:fallback text]}``
        插入输入属性 'prop' 的值。例如： ``%{filename}`` 与 ``%f`` 相同。如果该属性不存在或不可用，将插入一个错误文本，除非指定一个回退文本。
    ``%%``
        替换为 ``%`` 字符本身。

``--screenshot-directory=<path>``
    存储屏幕截图在此目录中。该路径与 ``--screenshot-template`` 生成的文件名结合。如果模板文件名已经是绝对的，该目录将被忽略。

    如果该目录不存在，它将在首张截图时被创建。如果它不是一个目录，在尝试写入截图时将产生一个错误。

    这个选项在默认情况下没有设置，因此将写入截图到mpv启动的目录中。在伪GUI模式下（参见 `伪GUI模式`_ ），这被设置为桌面。

``--screenshot-jpeg-quality=<0-100>``
    设置JPEG的质量等级。越高表示质量越好。默认： 90

``--screenshot-jpeg-source-chroma=<yes|no>``
    写入与视频相同的色度抽样到JPEG文件（默认： yes）。如果禁用，将使用libjpeg的默认值。

``--screenshot-png-compression=<0-9>``
    设置PNG压缩等级。越高表示更好的压缩率。这将影响写入截图文件的体积和所用时间。太高的压缩率可能会占用足够的CPU时间而打断播放。默认： 7

``--screenshot-png-filter=<0-5>``
    设置在PNG压缩前应用的滤镜。0是无，1是 "sub" ，2是 "up" ，3是 "average" ，4是 "Paeth" ，5是 "mixed" 。这影响到可以达成的压缩等级。对于大多数图像， "mixed" 实现了最佳的压缩率，因此它是默认的。

``--screenshot-webp-lossless=<yes|no>``
    写入无损的WebP文件。如果设置了这个选项， ``--screenshot-webp-quality`` 将被忽略。默认： no

``--screenshot-webp-quality=<0-100>``
    设置WebP质量等级。越高表示质量越好。默认： 75

``--screenshot-webp-compression=<0-6>``
    设置WebP的压缩等级。越高表示更好的压缩率，但需要更多的CPU时间。注意，在使用有损的WebP文件时，这也会影响截图质量。默认： 4

``--screenshot-jxl-distance=<0-15>``
    设置JPEG XL的Butteraugli距离。更低意味着更好的质量。无损是 0.0 ，而 1.0 大约相当于摄影内容的JPEG质量90。对于“视觉无损”的屏幕截图，使用 0.1 。默认： 1.0

``--screenshot-jxl-effort=<1-9>``
    设置JPEG XL的压缩力度。更高的力度（通常）意味着更好的压缩度，但需要更多的CPU时间。默认： 4

``--screenshot-sw=<yes|no>``
    是否对屏幕截图使用软件渲染（默认： no）。

    如果设置为no，如果可能的话（目前vo_gpu独占），屏幕截图将由当前的视频输出驱动渲染。这样做的好处是，这将（可能）始终像在视频窗口中显示的那样，因为渲染时使用的是相同的代码。但是由于渲染器需要重新初始化，这可能会很慢，而且可能打断播放（除非 ``window`` 模式与 ``screenshot`` 命令一起使用）。

    如果设置为yes，则使用软件缩放器将视频转换为RGB（或目标截图要求的任何内容）。在这种情况下，转换将在一个单独的线程中运行，可能不会打断播放。软件渲染器可能缺乏一些职能，比如HDR渲染。

软件缩放器
----------

``--sws-scaler=<name>``
    指定与 ``--vf=scale`` 一起使用的软件缩放器算法。这也影响到缺乏硬件加速的视频输出驱动，例如 ``x11`` 。另参见 ``--vf=scale``

    要获取可用的缩放器列表，请运行 ``--sws-scaler=help``

    默认： ``bicubic``

``--sws-lgb=<0-100>``
    软件缩放器的高斯模糊滤波（亮度）。参见 ``--sws-scaler``

``--sws-cgb=<0-100>``
    软件缩放器的高斯模糊滤波（色度）。参见 ``--sws-scaler``

``--sws-ls=<-100-100>``
    软件缩放器的锐化滤波（亮度）。参见 ``--sws-scaler``

``--sws-cs=<-100-100>``
    软件缩放器的锐化滤波（色度）。参见 ``--sws-scaler``

``--sws-chs=<h>``
    软件缩放器的色度水平偏移。参见 ``--sws-scaler``

``--sws-cvs=<v>``
    软件缩放器的色度垂直偏移。参见 ``--sws-scaler``

``--sws-bitexact=<yes|no>``
    未知的功能（默认： no）。请参考libswscale的源代码。就libswscale API而言，其主要目的是为所有平台上的相同输入产生完全相同的输出（输出在任何地方都有相同的“位深”，因此是 "bitexact"）。通常禁用该优化。

``--sws-fast=<yes|no>``
    允许优化以助于提高性能，但会降低质量（默认： no）。

    像 ``drm`` 和 ``x11`` 这样的视频输出驱动将从使用 ``--sws-fast`` 中获益良多。你可能需要设置其它选项，如 ``--sws-scaler`` 。内建的 ``sws-fast`` 配置预设应用了该选项和其它一些选项，以获得性能提升而降低质量。另参见 ``--sws-allow-zimg``

``--sws-allow-zimg=<yes|no>``
    允许使用zimg（如果使用内部swscale包装器的组件明确允许这样做）（默认： yes）。在这种情况下，如果内部的zimg包装器支持输入和输出的格式，就 *可能* 使用zimg。如果这些条件中的任一不适用，它将默默的或无声的回退到libswscale。

    如果使用了zimg，其它的 ``--sws-`` 选项将被忽略，而使用 ``--zimg-`` 类的选项来取代。

    如果使用swscale包装器的内部组件正确的挂上了日志，一个冗长的优先级日志信息将显示是否使用了zimg。

    大多数需要软件转换的东西都可以利用该项。

    .. note::

        请注意，zimg *可能* 比libswscale慢。通常，它在x86平台上更快，但在ARM上更慢（由于缺乏ARM特定的优化）。mpv的zimg包装器对某些格式使用了未经优化的重新打包，这不能责怪zimg。

``--zimg-scaler=<point|bilinear|bicubic|spline16|spline36|lanczos>``
    使用的Zimg亮度缩放器（默认： lanczos）。

``--zimg-scaler-param-a=<default|float>``, ``--zimg-scaler-param-b=<default|float>``
    设置缩放器参数。默认情况下，这些参数被设置为特殊的字符串 ``default`` ，它映射到一个特定的缩放器默认值。如果某缩放器是不可调节的，则忽略。

    ``lanczos``
        ``--zimg-scaler-param-a`` 是tap的数量。

    ``bicubic``
        a和b是双立方的b和c参数。

``--zimg-scaler-chroma=...``
    与 ``--zimg-scaler`` 相同，用于色度插值（默认： bilinear）。

``--zimg-scaler-chroma-param-a``, ``--zimg-scaler-chroma-param-b``
    与 ``--zimg-scaler-param-a`` / ``--zimg-scaler-param-b`` 相同，用于色度。

``--zimg-dither=<no|ordered|random|error-diffusion>``
    色深抖动（默认： random）。

``--zimg-threads=<auto|integer>``
    设置用于缩放的最大线程数（默认： auto）。 ``auto`` 使用当前机器的逻辑内核数量。注意，缩放器可能会根据情况使用更少的线程（甚至只有1个线程）。传递值1可禁用线程，并始终在单个操作中缩放图像。更高的线程数浪费资源，但通常会使它更快。

    注意，一些zimg的git版本有bug，如果使用了线程，会破坏输出。

``--zimg-fast=<yes|no>``
    允许优化以助于提高性能，但会降低质量（默认： yes）。目前，这可能简化伽马的转换操作。


音频重采样器
------------

它控制mpv所做的任何重采样的默认选项（但除去内建的libavfilter，系统音频API重采样，或任何其它的地方）。

它也为 ``lavrresample`` 音频滤镜设置默认值。

``--audio-resample-filter-size=<length>``
    相对于低采样率的滤波长度。（默认： 16）

``--audio-resample-phase-shift=<count>``
    多相条目数的对数。（..., 10->1024, 11->2048, 12->4096, ...） （默认： 10->1024）

``--audio-resample-cutoff=<cutoff>``
    截止频率（0.0-1.0），默认设置取决于滤波长度。

``--audio-resample-linear=<yes|no>``
    如果设置，那么滤波将在多相条目之间进行线性插值。（默认： no）

``--audio-normalize-downmix=<yes|no>``
    如果环绕声被下混为立体声，启用/禁用标准化（默认： no）。如果该功能被禁用，下混可能导致削波。如果它被启用，输出可能会太安静。这取决于源音频。

    技术上讲，这执行了下混，改变了 ``lavrresample`` 音频滤镜的 ``normalize`` 子选项。

    如果下混由于某种原因发生在mpv之外，或在解码器内（解码器下混），或在音频输出中（系统混音器），这无影响。

``--audio-resample-max-output-size=<length>``
    限制一次过滤的音频帧的最大尺寸，以毫秒为单位（默认： 40）。为了使重采样速度变化反应更快，输出的大小是受限的。特别是当解码器或滤镜输出非常大的帧尺寸时（如一些无损编解码器或一些DRC滤镜），这是必要的。该选项不会以任何方式影响重采样算法。

    仅用于测试/调试。可能在任何时候被移除或更改。

``--audio-swresample-o=<string>``
    在SwrContext或AVAudioResampleContext上设置AVOptions。这些应该记录在FFmpeg或Libav中。

    这是一个按键/值列表选项。详见 `列表选项`_

终端
----

``--quiet``
    使控制台的输出不过于冗长；特别是防止显示状态行（即 AV: 3.4 (00:00:03.37) / 5320.6 ... ）。在低速的或不能正确处理回车（即 ``\r`` ）的损坏终端上特别有用。

    另参见： ``--really-quiet`` 和 ``--msg-level``

``--really-quiet``
    显示比 ``--quiet`` 更少的输出和状态信息。

``--no-terminal``, ``--terminal``
    禁用任何终端和 stdin/stdout/stderr 的使用。这将完全静默任何的信息输出。

    与 ``--really-quiet`` 不同，这也禁用输入和终端的初始化。

``--no-msg-color``
    禁用终端的彩色控制台输出。

``--msg-level=<module1=level1,module2=level2,...>``
    直接控制每个模块的冗长程度。模块 ``all`` 可以变更所有模块的冗长程度。从这个选项中变更冗长程度是按照从左到右的顺序进行的，且每项都可以覆盖前项。

    用 ``--msg-level=all=trace`` 来运行mpv，可以看到mpv输出的所有信息。你可以使用输出中输出的模块名称（每行的前缀为 ``[...]`` ）来限制只输出感兴趣的模块。

    这也会影响 ``--log-file`` ，并在某些情况下也会影响到libmpv API的日志记录。

    .. note::

        有些信息在命令行被解析之前就已被输出，因此不受 ``--msg-level`` 的影响。要控制这些信息，你必须使用 ``MPV_VERBOSE`` 环境变量；详见 `环境变量`_

    可用的级别：

        :no:        完全静默
        :fatal:     仅限致命信息
        :error:     错误信息
        :warn:      警告信息
        :info:      信息类的消息
        :status:    状态信息（默认）
        :v:         冗长信息
        :debug:     调试信息
        :trace:     非常嘈杂的调试信息

    .. admonition:: 示例

        ::

            mpv --msg-level=ao/sndio=no

        完全静默 ao_sndio 的输出，它使用日志前缀 ``[ao/sndio]``

        ::

            mpv --msg-level=all=warn,ao/alsa=error

        只显示警告或更糟的信息，且让 ao_alsa 的输出只显示错误。

``--term-osd=<auto|no|force>``
    当没有视频输出时，控制是否在控制台显示OSD信息（默认： auto）。

    :auto:      如果没有视频输出，使用终端OSD
    :no:        禁用终端OSD
    :force:     即使视频输出激活，也使用终端OSD

    如果设置了 ``--video-osd=no`` ，模式 ``auto`` 也会启用终端OSD。

``--term-osd-bar``, ``--no-term-osd-bar``
    启用在终端的状态行下输出一个进度条。（默认禁用）

``--term-osd-bar-chars=<string>``
    自定义 ``--term-osd-bar`` 功能。该字符串预计由5个字符组成（开始，左侧空格，位置指示器，右侧空格，结束）。你可以使用Unicode字符，但要注意双倍宽度的字符将不会被正确处理。

    默认： ``[-+-]``

``--term-playing-msg=<string>``
    开始播放后输出一个字符串。该字符串可被扩展为属性，例如： ``--term-playing-msg='file: ${filename}'`` 将输出字符串 ``file:`` 后接空格和当前播放的文件名。

    参见 `属性`_

``--term-status-msg=<string>``
    在播放过程中输出一个自定义的字符串，而不是标准的状态行。可扩展属性。参见 `属性扩展`_

``--term-title=<string>``
    设置终端的标题。目前，这只是将设置窗口标题的转义序列与提供的（属性扩展）字符串简单连接起来。如果扩展的字符串包含结束转义序列的字节，或者终端不理解该序列，这将会造成混乱。后者可能包括令人遗憾的win32.

    可扩展属性。参见 `属性扩展`_

``--msg-module``
    在每个控制台信息前加上模块名称。

``--msg-time``
    在每个控制台信息前加上时间信息。时间的单位是播放器进程开始后的秒数（理论，但实际略晚），使用单一的取决于操作系统的时间源。在正常的UNIX系统中，这叫 ``CLOCK_MONOTONIC``

缓存
----

``--cache=<yes|no|auto>``
    决定是否使用网络缓存设置（默认： auto）。

    如果启用，使用最大的 ``--cache-secs`` 作为缓存大小（但仍然受限于 ``--demuxer-max-bytes`` ），并使缓存数据可跳转（如果可能）。如果禁用， ``--cache-pause`` 和相关的都被隐式禁用。

    ``auto`` 的选择是根据流是否被认为涉及网络链接或其它慢速媒体来启用（这是一个不完美的启发式方法）。

    在mpv0.30.0之前，这个选项曾经接受一个数字，指定缓存的大小，单位是kilobytes。使用例如 ``--cache --demuxer-max-bytes=123k`` 来代替。

``--no-cache``
    关闭输入流缓存。参见 ``--cache``

``--cache-secs=<seconds>``
    如果缓存被激活，要预读取多少秒的音频/视频。如果且仅当缓存被启用且数值较大时，这将覆盖``--demuxer-readahead-secs`` 选项。默认值被设置的非常高，所以实际达到的预读取通常会受到 ``--demuxer-max-bytes`` 选项的限制。设置这个选项通常只对限制预读取有用。

``--cache-on-disk=<yes|no>``
    将packet数据写入到一个临时文件，而不是将它们保存在内存中。这只有和 ``--cache`` 一起使用才有意义。如果一般的缓存被禁用，这个选项将被忽略。

    缓存文件只是附加的。即使播放器出现裁剪数据，它所释放的文件空间也不会被重新使用。缓存文件在播放结束时被删除。

    注意，packet元数据仍然保留在内存中。 ``--demuxer-max-bytes`` 和相关选项 *只* 适用于元数据。这种元数据的大小不尽相同，但每小时50MB的媒体是典型的。缓存统计将报告这个元数据的大小，而不是缓存文件的大小。如果元数据触顶了大小限制，元数据就会被裁剪（但不会切掉缓存文件）。

    当媒体被关闭时，缓存文件被删除。缓存文件在媒体关闭后一般是没有价值的，而且很难从中检索到任何媒体数据（设计上不支持）。

    如果该选项在运行时被启用，缓存文件会被创建，但旧的数据会保留在内存缓存中。如果该选项在运行时被禁用，旧的数据将保留在硬盘缓存中，并且缓存文件在媒体关闭之前不会被关闭。如果该选项被禁用并再次启用，将继续使用首先打开的缓存文件。

``--cache-dir=<path>``
    创建临时文件的目录。如果未设置，缓存将被存储在系统的缓存目录下（通常是 ``~/.cache/mpv`` ）。

    目前，这只用于 ``--cache-on-disk``

``--cache-pause=<yes|no>``
    当缓存中的数据用完后，播放器是否应该自动暂停，并中止解码/播放（默认： yes）。如果启用，它会暂停，一旦有更多的数据可用，又名“缓冲”，就解除暂停。

``--cache-pause-wait=<seconds>``
    如果输入了“缓冲”，packet缓存在再次开始播放之前应该有多少秒的缓冲时间（默认： 1）。这可以用来控制如果 ``--cache-pause`` 被启用，解复用器拖欠时，播放器重新缓存的时间。如果给定的时间高于 ``--cache-secs`` 或 ``--demuxer-readahead-secs`` 设置的最大时间，或者由于其它原因（如文件结束或达到设置的最大缓存大小）预读取结束，播放将提前恢复。

``--cache-pause-initial=<yes|no>``
    在开始播放前进入“缓冲”模式（默认： no）。这可以用来确保播放顺利开始，以换取等待一些时间来预读取网络数据（由 ``--cache-pause-wait`` 控制）。例如，一些常见的行为是，播放开始后，但随着播放的进行尝试解码更多的数据时，网络缓存立即不足。

    另一个可能发生的情况是，网络预读取对CPU的要求很高（由于在后台进行解复用），以至于播放一开始就掉帧。在这种情况下，启用这个选项，并将 ``--cache-secs`` 和 ``--cache-pause-wait`` 设置为大致相同的值，会有帮助。

    这个选项也会在跳转后重新开始播放时触发。

``--cache-unlink-files=<immediate|whendone|no>``
    是否或何时解除缓存文件的连接（默认： immediate）。这影响到缓存文件，这些文件本身是临时性的，在播放器终止后留在硬盘上没有意义。这是一个调试选项。

    ``immediate``
        在缓存文件被创建后解除其连接。缓存文件将不再可见，即使它们还在使用。这可以确保当播放器终止时，它们被保证从硬盘中删除，即使它崩溃。

    ``whendone``
        关闭后删除缓存文件。

    ``no``
        不删除缓存文件。它们会消耗硬盘空间且没有用途。

    目前，这只用于 ``--cache-on-disk``

``--stream-buffer-size=<bytesize>``
    低级流字节缓冲区的大小（默认： 128KB）。它被用作解复用器和低级I/O（例如套接字）之间的缓冲区。一般来说，它可以非常小，主要用途类似于C标准库中的内部缓冲区FILE。

    缓冲区的一半始终用于保证回跳转，这对不可跳转的输入很重要。

    有一些已知的情况，这有助于性能而设置一个大的缓冲区：

        1. mp4文件。libavformat可能会在两个方向上触发许多小的跳转，取决于文件是如何被复用的。

        2. 某些网络文件系统，它们没有缓存，小的读取可能是低效的。

    在其它情况下，将其设置为一个大的值会降低性能。

    通常情况下，读取链接是在缓冲区大小的一半，但可能会发生链接是在较小和较大的交替进行的情况（这是由于内部环形缓冲区的wrap-around）。

    默认值和取值范围参见 ``--list-options`` 。 ``<bytesize>`` 选项接受后缀，比如 ``KiB`` 和 ``MiB``

``--vd-queue-enable=<yes|no>, --ad-queue-enable``
    启用在一个单独的线程上运行视频/音频解码器（默认： no）。如果启用，解码器将在一个单独的线程上运行，并在解码器和更高等级的播放逻辑之间放置一个帧队列。帧队列的大小由下面的其它选项定义。

    这可能是毫无意义的。libavcodec已经有了多线程解码（默认启用），这使得它基本上没有必要。在一些高带宽视频缓慢解码的极端条件下，它可能会有帮助（在这些情况下，libavcodec会屏蔽播放逻辑，而使用解码线程将在不影响播放逻辑的情况下均匀分配解码时间）。在其它情况下，它只是会使跳转速度变慢，并使用明显更多的内存。

    队列大小受其它 ``--vd-queue-...`` 选项的限制。最终的队列大小是具有最低限制的选项所指示的最小值。每个解码器/轨道都有自己的队列，可以使用完全配置的队列大小。

    大多数队列选项可以在运行时改变。 ``--vd-queue-enable`` 本身（和音频等效选项）只有在解码完全重新初始化时才会更新。然而，设置 ``--vd-queue-max-samples=1`` 应该几乎导致与 ``--vd-queue-enable=no`` 相同的行为，该值可用于有效地在运行时启用/禁用队列。

    这不应该被用于硬件解码。有可能为音频启用这个功能，但这更没有意义。

``--vd-queue-max-bytes=<bytesize>``, ``--ad-queue-max-bytes``
    队列的最大近似允许大小。如果超出，解码将被停止。最大尺寸可以超过大约1帧。

    默认值和数值范围参见 ``--list-options`` 。 ``<bytesize>`` 选项接受后缀，比如 ``KiB`` 和 ``MiB``

``--vd-queue-max-samples=<int>``, ``--ad-queue-max-samples``
    队列的最大帧数（视频）或采样数（音频）。音频的大小可能会超过1帧左右。

    默认值和取值范围参见 ``--list-options``

``--vd-queue-max-secs=<seconds>``, ``--ad-queue-max-secs``
    队列中媒体的最大秒数。特殊值0表示不设置限制。队列大小可能会超过2帧左右。时间戳重置可能导致队列大小的随机使用。

    默认值和取值范围参见 ``--list-options``

网络
----

``--user-agent=<string>``
    使用 ``<string>`` 作为HTTP流的用户代理。

``--cookies``, ``--no-cookies``
    在进行HTTP请求时支持cookies。默认禁用。

``--cookies-file=<filename>``
    从 ``<filename>`` 读取HTTP cookies。假设该文件是 Netscape 格式。

``--http-header-fields=<field1,field2>``
    设置当访问HTTP流时自定义HTTP字段。

    这是一个字符串列表选项。详见 `列表选项`_

    .. admonition:: 示例

        ::

            mpv --http-header-fields='Field1: value1','Field2: value2' \
            http://localhost:1234

        将生成HTTP请求::

            GET / HTTP/1.0
            Host: localhost:1234
            User-Agent: MPlayer
            Icy-MetaData: 1
            Field1: value1
            Field2: value2
            Connection: close

``--http-proxy=<proxy>``
    HTTP/HTTPS的URL代理。如果设置了它，环境变量 ``http_proxy`` 就会被忽略。环境变量 ``no_proxy`` 仍被遵循。如果该选项不是以 ``http://`` 开头，则会被静默忽略。代理不用于https URL。设置该选项并不能试图让ytdl脚本使用代理。

``--tls-ca-file=<filename>``
    用于TLS的证书授权数据库文件。（在较早的FFmpeg或Libav版本中静默失败。）

``--tls-verify``
    当使用TLS时，验证对方的证书（例如，用 ``https://...`` ）。（在较早的FFmpeg或Libav版本中静默失败。）

``--tls-cert-file``
    一个包含证书的用于与对方握手的文件。

``--tls-key-file``
    一个包含证书的私钥的文件。

``--referrer=<string>``
    为HTTP请求指定一个引用者路径或URL。

``--network-timeout=<seconds>``
    指定网络超时，以秒为单位（默认： 60）。这至少会影响HTTP。特殊值 0 将使用FFmpeg/Libav的默认值。如果使用的协议不支持超时，该选项会被静默忽略。

    .. warning::

        这破坏了RTSP协议，因为FFmpeg的API在其内部超时选项上不一致。RTSP超时选项不仅接受不同的单位（秒而不是微秒，导致mpv传递给它巨大的数值），而且还会溢出FFmpeg的内部计算结果。最糟糕的是，仅仅设置该选项就会使RTSP进入监听模式，这就破坏了任何客户端的使用。在写这篇文档的时候，此修正还未生效。由于该原因，此选项在RTSP URL上被忽略（或应该被忽略）。你仍可以直接用 ``--demuxer-lavf-o`` 设置超时选项。

``--rtsp-transport=<lavf|udp|udp_multicast|tcp|http>``
    选择RTSP传输方式（默认： tcp）。在播放 ``rtsp://...`` 网址时，这将选择底层网络传输。值 ``lavf`` 将决定权留给libavformat。

``--hls-bitrate=<no|min|max|<rate>>``
    如果播放HLS流，该选项控制默认选择哪些流。该选项允许以下参数：

    :no:        不做任何特别的事情。通常，这将简单的选择它能找到的首个音频/视频流。
    :min:       挑选比特率最低的流。
    :max:       相同的挑选但比特率最高的流。（默认）

    此外，如果选项是一个数字，那么将选择最高比特率等于或小于该选项值的流。

    所用的比特率是由服务器发送的，并不能保证它是真正有意义的。

数字视频广播
------------

``--dvbin-prog=<string>``
    这定义了要调节的频道。通常，你可以通过使用流URL来指定，比如 ``"dvb://ZDF HD"`` ，但你可以通过在运行时写入此属性来调节到不同的频道。另参见 ``dvbin-channel-switch-offset`` 来获得更有用的频道切换功能。

``--dvbin-card=<0-15>``
    指定使用卡号 0-15（默认： 0）。

``--dvbin-file=<filename>``
    指示mpv从 ``<filename>`` 中读取频道列表。默认是在mpv设置目录下（通常是 ``~/.config/mpv`` ），文件名是 ``channels.conf.{sat,ter,cbl,atsc}`` （根据你的卡类型）或 ``channels.conf`` 作为最后手段。对于DVB-S/2卡，推荐使用VDR 1.7.x格式的频道表，因为它可以调节到DVB-S2频道，启用字幕并对PMT进行解码（这在很大程度上改善了解复用）。仍然支持经典的mplayer格式的频道表（没有这些改进），对于其它的卡类型，只实现了有限的VDR格式频道表支持（欢迎打补丁）。对于有动态PID切换的频道或不完整的 ``channels.conf`` ，推荐使用 ``-dvbin-full-transponder`` 或神奇的 ``8192`` PID。

``--dvbin-timeout=<1-30>``
    试图调节到一个频率时，在放弃前等待的最大秒数（默认： 30）。

``--dvbin-full-transponder=<yes|no>``
    不对程序的PID进行过滤，只对频率进行调节，并将全转发器传给解复用器。在这种情况下，播放器前端从全转发器中选择流，所以最初显示的频道可能与所选频道不匹配。通过循环 ``program`` 属性，可以在频道之间进行切换。这对于在一个转发器上录制多个节目，或解决 ``channels.conf`` 中的问题很有用。我们也建议对那些即时切换PID的频道使用这个功能，例如区域新闻。

    默认： ``no``

``--dvbin-channel-switch-offset=<integer>``
    这个值不是通过设置文件来设定的，但是可用于频道切换。 ``input.conf`` 中可以通过 ``cycle`` 该值来执行 ``up`` 和 ``down`` 的通道切换。该数字有效的给出了频道列表中初始调节到的频道的偏移量。

    一个示例， ``input.conf`` 可以包含：``H cycle dvbin-channel-switch-offset up``, ``K cycle dvbin-channel-switch-offset down``

ALSA音频输出选项
----------------


``--alsa-device=<device>``
    已过时，应使用 ``--audio-device`` （需要 ``alsa/`` 前缀）。

``--alsa-resample=yes``
    启用ALSA重采样插件。（默认禁用，因为一些驱动程序在某些情况下报告了不正确的音频延迟）。

``--alsa-mixer-device=<device>``
    设置与 ``ao-volume`` 一起使用的混音器设备（默认： ``default`` ）。

``--alsa-mixer-name=<name>``
    设置混音器元素的名称（默认： ``Master`` ）。例如，这是 ``PCM`` 或 ``Master``

``--alsa-mixer-index=<number>``
    设置混音器通道的索引（默认： 0）。考虑到 "``amixer scontrols``" 的输出，那么索引就是元素名称后面的数字。

``--alsa-non-interleaved``
    允许输出非交错格式（如果音频解码器使用这种格式）。目前默认禁用，因为一些流行的ALSA插件在使用非交错格式时完全失效。

``--alsa-ignore-chmap``
    不读取或设置ALSA设备的声道图 —— 只请求所需的声道数，然后将音频原封不动的传递给它。此选项很可能不应被使用。它在调试中可能很有用，或者对于有特殊设计的ALSA配置的静态设置（在这种情况下，你应该始终用 ``--audio-channels`` 强制使用相同的布局，否则它只对使用ALSA设备暗含布局的文件有效）。

``--alsa-buffer-time=<microseconds>``
    设置请求的缓冲时间，以微秒为单位。数值 0 可以跳过ALSA API的任何请求。该选项和 ``--alsa-periods`` 选项使用ALSA的 ``near`` 函数来设置请求的参数。如果这样做的结果是一个空的配置集，那么就跳过设置这些参数。

    这两个选项都控制缓冲区的大小。过小的缓冲区会导致较高的CPU使用率和音频丢失，而过大的缓冲区则会导致音量变化和其它滤镜的延迟。

``--alsa-periods=<number>``
    从ALSA API请求的周期数。详见 ``--alsa-buffer-time`` 以了解更多。


GPU渲染选项
-----------

以下视频选项目前都是针对 ``--vo=gpu``, ``--vo=libmpv`` 和 ``--vo=gpu-next`` 的，它们是唯一实现这些选项的视频输出驱动。

``--scale=<filter>``
    放大视频时使用的filter函数。

    ``bilinear``
        双线性硬件纹理过滤（最快，质量很低）。由于兼容性原因，这是默认的。

    ``spline36``
        中等质量和速度。这是使用 ``gpu-hq`` 时的默认值。

    ``lanczos``
        Lanczos缩放。提供中等质量和速度。一般而言比 ``spline36`` 差，但它的结果是稍微锐利的图像，对某些内容类型来说是好的。可以用 ``scale-radius`` 来控制taps的数量，但最好不做变更。

        （该filter是 ``sinc``-windowed ``sinc`` 的别名）

    ``ewa_lanczos``
        椭圆加权平均的Lanczos缩放。也被称为Jinc。相对较慢，但质量非常好。半径可以用 ``scale-radius`` 来控制。增加半径会使filter更锐利但会增加更多的振铃。

        （该filter是 ``jinc``-windowed ``jinc`` 的别名）

    ``ewa_lanczossharp``
        ewa_lanczos的一个略锐利的版本，预设为使用一个理想的半径和参数。如果你的硬件可以运行它，这可能是你应该默认使用的。

    ``mitchell``
        Mitchell-Netravali。 ``B`` 和 ``C`` 参数可以用 ``--scale-param1`` 和 ``--scale-param2`` 来设置。这个filter非常擅长缩小（参见 ``--dscale`` ）。

    ``oversample``
        最邻近的一个版本，（天真地）对像素进行过采样，因此，重叠在边缘的像素会被线性内插值，而不是取整。这以换取增加一些模糊度为代价，基本上消除了由最邻近插值引起的小缺陷和抖动伪影。该filter擅长时域插值，也被称为 "smoothmotion"（参见 ``--tscale`` ）。

    ``linear``
        一个 ``--tscale`` filter。

    还有一些更多的filter，但大多数没那么有用。传递值 ``help`` 以获得完整的列表，例如::

        mpv --scale=help

``--cscale=<filter>``
    和 ``--scale`` 一样，但用于插值色度信息。如果图像没有进行抽样，这个选项将完全被忽略。

``--dscale=<filter>``
    和 ``--scale`` 一样，但在缩小时应用这些filter。如果这个选项没有被设置，将应用由 ``--scale`` 暗示的filter。

``--tscale=<filter>``
    用于插值时间轴（帧）的filter。只有当 ``--interpolation`` 被启用时才会使用。 ``--tscale`` 的唯一有效选择是可分离的卷积filter（使用 ``--tscale=help`` 来获得一个列表）。默认： ``mitchell``

    常见的 ``--tscale`` 选择包括 ``oversample``, ``linear``, ``catmull_rom``, ``mitchell``, ``gaussian``, 或 ``bicubic`` 。这些都是按照平滑度/模糊度递增的顺序排列的， ``bicubic`` 是最平滑/最模糊的，而 ``oversample`` 是最清晰/最不平滑的。

``--scale-param1=<value>``, ``--scale-param2=<value>``, ``--cscale-param1=<value>``, ``--cscale-param2=<value>``, ``--dscale-param1=<value>``, ``--dscale-param2=<value>``, ``--tscale-param1=<value>``, ``--tscale-param2=<value>``
    设置filter参数。默认情况下，这些参数被设置为特殊的字符串 ``default`` ，它映射到一个特定缩放器的默认值。如果filter是不可调的，则忽略。目前，这影响到下列filter参数：

    bcspline
        样条参数（ ``B`` 和 ``C`` ）。两者都默认： 0.5

    gaussian
        缩放参数（ ``t`` ）。增加这个参数会使结果更模糊。默认： 1

    oversample
        使用插值之前与边缘的最小距离。设置为0将始终插值边缘，而设置为0.5将永远不插值，因此表现为使用常规的最邻近算法。默认： 0.0

``--scale-blur=<value>``, ``--scale-wblur=<value>``, ``--cscale-blur=<value>``, ``--cscale-wblur=<value>``, ``--dscale-blur=<value>``, ``--dscale-wblur=<value>``, ``--tscale-blur=<value>``, ``--tscale-wblur=<value>``
    Kernel/window的缩放系数（也被称为模糊系数）。减少它可以使结果更锐利，增加它可以使结果更模糊（默认： 0）。如果设置为0，将使用kernel的首选模糊系数。注意，设置的太低（例如0.5）会导致不好的结果。通常推荐使用0.8到1.2之间的值。

``--scale-clamp=<0.0-1.0>``, ``--cscale-clamp``, ``--dscale-clamp``, ``--tscale-clamp``
    指定要乘以负系数的权重偏差。指定 ``--scale-clamp=1`` 的效果是完全去除负的权重，从而有效地将数值范围限制在[0-1]。可以指定0.0和1.0之间的值，只对负权重进行适度减弱。这对 ``--tscale`` 特别有用，它可以减少时域的过多的振铃伪影（通常表现为短促的闪光或黑边，主要围绕在移动的边缘），以可能增加更多模糊为代价。 ``--tscale-clamp`` 的默认值是1.0，其它的默认值是0.0。

``--scale-cutoff=<value>``, ``--cscale-cutoff=<value>``, ``--dscale-cutoff=<value>``
    一旦数值范围下降到这个阈值以下，就提前切断filter的kernel。这样做可以通过忽略LUT中被window函数有效归零的部分，更积极地修剪可跳过的系数。只影响polar (EWA) filter。默认是0.001，这在感知上是透明的，但可以提供10%-20%的加速，取决于所选择的确切半径和filter kernel。

``--scale-taper=<value>``, ``--scale-wtaper=<value>``, ``--dscale-taper=<value>``, ``--dscale-wtaper=<value>``, ``--cscale-taper=<value>``, ``--cscale-wtaper=<value>``, ``--tscale-taper=<value>``, ``--tscale-wtaper=<value>``
    Kernel/window taper系数。增加它可以使filter函数变平。值的范围是0到1。值为0（默认）表示没有平坦化，值为1使filter完全平坦（相当于一个box函数）。介于两者之间的值意味着某些部分将是平坦的，实际的filter函数将被挤压到两者之间的空间中。

``--scale-radius=<value>``, ``--cscale-radius=<value>``, ``--dscale-radius=<value>``, ``--tscale-radius=<value>``
    为可调的filter设置半径，必须是0.5到16.0之间的浮点数。如果未指定则默认为filter的首选半径。并非对每个缩放器和视频输出驱动的组合都有效。

    注意，根据filter的实现细节和视频缩放比例，实际使用的半径可能是不同的（很可能被增加一点）。

``--scale-antiring=<value>``, ``--cscale-antiring=<value>``, ``--dscale-antiring=<value>``, ``--tscale-antiring=<value>``
    设置抗振铃强度。这尝试消除振铃，但在此过程中可能会引入其它伪影。必须是0.0和1.0之间的浮点数。默认值0.0完全禁用抗振铃。

    注意，这不影响特殊的 ``bilinear`` 和 ``bicubic_fast`` filter，也不影响任何polar (EWA) 缩放器。

``--scale-window=<window>``, ``--cscale-window=<window>``, ``--dscale-window=<window>``, ``--tscale-window=<window>``
    （仅限高级用户）为kernel选择一个自定义的window函数。如果未设置则默认为filter的首选window。使用 ``--scale-window=help`` 来获得一个支持的window函数的列表。

``--scale-wparam=<window>``, ``--cscale-wparam=<window>``, ``--cscale-wparam=<window>``, ``--tscale-wparam=<window>``
    （仅限高级用户）设置由 ``--scale-window`` 等给出的window函数的参数。默认情况下，这些参数被设置为特殊的字符串 ``default`` ，它映射到一个特定window的默认值。如果window不可调则忽略。目前，这影响到以下window参数：

    kaiser
        window参数（alpha）。默认： 6.33
    blackman
        window参数（alpha）。默认： 0.16
    gaussian
        缩放参数（t）。增加它使window变宽。默认： 1

``--scaler-lut-size=<4..10>``
    设置缩放器kernels的查找纹理的大小（默认： 6）。纹理的实际大小是 ``2^N`` ，选项值为 ``N`` 。所以默认设置下的查找纹理使用64采样。

    所有的权重都是从这些采样中线性插值出来的，所以增加查找表的大小可能会改善缩放器的精度。

``--scaler-resizes-only``
    如果视频图像没有调整大小，则禁用缩放器。在这种情况下， ``bilinear`` 会被用来代替 ``--scale`` 设置的任何东西。如果不进行缩放，双线性将完美再现源图像。默认启用。注意，这个选项从不影响 ``--cscale``

``--correct-downscaling``
    当使用基于卷积的filter时，在缩小时扩展filter的尺寸。增加了质量，但降低了缩小时的性能。

    这对变形视频来说会有轻微的次优化表现（但仍然比没有好），因为它将扩展尺寸以仅匹配轴之间比例系数的较低值。

    注意：当使用双线性缩小时（默认），该选项被忽略。

``--linear-downscaling``
    在缩小时线性缩放亮度。它应该只能用于至少有16位精度的 ``--fbo-format`` 。该选项对HDR内容无影响。

``--linear-upscaling``
    在放大时线性缩放亮度。和 ``--linear-downscaling`` 一样，它应该只能用于至少有16位精度的 ``--fbo-format`` 。除了测试/特殊目的外，通常不推荐这样做。建议用户启用 ``--sigmoid-upscaling`` 或保持两个选项都禁用（即以伽玛缩放亮度）。

``--sigmoid-upscaling``
    当放大时，使用正弦波颜色变换以避免强调振铃伪影。这与 ``--linear-upscaling`` 不兼容并取代了它（注意sigmoidization也需要线性化，所以在两种情况下 ``LINEAR`` 渲染步骤都会启动）。

``--sigmoid-center``
    用于 ``--sigmoid-upscaling`` 的正弦曲线的中心，必须是0.0到1.0之间的浮点数。如果未指定则默认： 0.75

``--sigmoid-slope``
    用于 ``--sigmoid-upscaling`` 的正弦曲线的斜率，必须是1.0到20.0之间的浮点数。如果未指定则默认： 6.5

``--interpolation``
    减少由视频帧数和显示器刷新率不匹配引起的卡顿（也被称为抖动）。

    .. warning:: 这需要将 ``--video-sync`` 选项设置为 ``display-`` 模式之一，否则它将被默默禁用。这在mpv0.14.0之前是不需要的。

    这实质上是试图通过沿时间轴卷积视频来插补缺失的帧。使用的filter可以用 ``--tscale`` 设置来控制。

``--interpolation-threshold=<0..1,-1>``
    低于这个阈值的帧率插值将被禁用（默认： ``0.01`` ）。计算方法是 ``abs(disphz/vfps - 1) < threshold`` ，其中 ``vfps`` 是速度调整后的视频FPS， ``disphz`` 是显示器刷新率（速度调整后的视频FPS大致等于正常的视频FPS，但是应用了减速和加速。如果你使用 ``--video-sync=display-resample`` 来使视频与显示FPS同步运行，或者改变 ``speed`` 属性，这很重要）。

    默认的目的是，在使用 ``--video-sync=display-*`` 的重计时不能充分调整视频速度以实现流畅播放的情况下启用插值。例如，如果一个视频是60.00FPS，而你的显示器刷新率是59.94Hz，插值将永远不会被激活，因为不匹配是在刷新率的1%以内。默认值还处理了mpv不能确定容器FPS的情况，比如在某些直播流中，可能会动态地切换插值的开启和关闭。在这种情况下，默认情况是不使用插值，而是允许 ``--video-sync=display-*`` 来重新计时视频以匹配显示器的刷新率。详见 ``--video-sync-max-video-change`` 了解关于mpv如何重新计时视频。

    还要注意的是，如果你使用 ``--video-sync=display-vdrop`` ，速率的微小偏差会禁用插值，每隔一分钟就会引入一个不连续。

    将此设置为 ``-1`` 来禁用这个逻辑。

``--interpolation-preserve``
    即使渲染器参数发生变化，也保留前几帧的插值结果 —— 与剪切和视频放置有关的选项除外，这些选项总是会使缓存失效。启用该选项可以使渲染器设置的动态更新稍微平滑，但代价是对这种变化的响应延迟会稍高。默认为开启（只影响 ``--vo=gpu-next`` ，注意 ``--vo=gpu`` 始终使插值的帧失效）。

``--opengl-pbo``
    启用PBOs的使用。在某些驱动上，这可能会更快，特别是当源视频尺寸很大时（例如所谓的“4K”视频）。在其他它驱动上，它可能会更慢或引起延迟问题。

``--dither-depth=<N|no|auto>``
    设置抖动的目标深度为N，默认： no

    no
        禁用mpv所做的任何抖动
    auto
        自动选择。如果不能检测到输出位深度，则假定每个分量为8位
    8
        抖动到8比特输出

    注意，无法检测到连接的视频显示设备的深度。通常情况下，LCD面板会自行抖动，这与该选项相冲突并导致难看的输出。

``--dither-size-fruit=<2-8>``
    设置抖动矩阵的大小（默认： 6）。矩阵的实际大小是 ``(2^N) x (2^N)`` ，选项值为 ``N`` ，所以值为6时，大小为64x64。矩阵在启动时生成，一个大的矩阵可能需要相当长的时间来计算（秒）。

    只能在 ``--dither=fruit`` 模式下使用。

``--dither=<fruit|ordered|error-diffusion|no>``
    选择抖动算法（默认： fruit）（通常情况下， ``--dither-depth`` 选项控制是否启用抖动。）

    ``error-diffusion`` 选项需要计算着色器的支持。它也需要大量的共享内存来运行，其大小取决于kernel（见下方的 ``--error-diffusion`` 选项）和视频窗口的高度。如果没有足够的共享内存来运行着色器，它将回退到 ``fruit`` 抖动。

``--temporal-dither``
    启用时域抖动（只有在一般情况下启用抖动时才会激活）。通过改变平铺的抖动矩阵的方向，每个帧上的8种不同抖动模式之间会发生变化。不幸的是，这可能会导致LCD显示器上的闪烁，因为这些显示器有很高的反应时间。

``--temporal-dither-period=<1-128>``
    确定在使用 ``--temporal-dither`` 时抖动模式的更新频率。1（默认）将在每一视频帧上更新，2在每隔一帧更新，以此类推。

``--error-diffusion=<kernel>``
    当设置了 ``--dither=error-diffusion`` 时，使用的误差扩散的kernel。

    ``simple``
        只向相邻的两个像素传播误差。最快但质量低

    ``sierra-lite``
        速度快且质量合理。这是默认值

    ``floyd-steinberg``
        最值得注意的误差扩散kernel

    ``atkinson``
        看起来与其它kernel不同，因为在抖动过程中只有部分误差会被传播。这个kernel的典型用途是保存抖动的屏幕截图（在窗口模式下）。这个kernel产生的文件稍小，但抖动质量仍然合理。

    还有其它的kernel（使用 ``--error-diffusion=help`` 列出），但它们中的大多数都要慢得多，而且需要更大的共享内存。在这些kernel中， ``burkes`` 在性能和质量之间取得了良好的平衡，可能是你首先想尝试的kernel。

``--gpu-debug``
    启用GPU调试。这意味着什么取决于API类型。对于OpenGL，它调用 ``glGetError()`` ，并请求一个调试环境。对于Vulkan，它启用验证层。

``--opengl-swapinterval=<n>``
    两次缓冲区互换之间的显示帧间隔。1相当于启用垂直同步，0相当于禁用垂直同步。如果没有指定则默认为1。

    注意，这取决于正确的OpenGL 垂直同步支持。在某些平台和驱动上，只有在全屏模式下才能可靠地工作。如果使用多个显示器，它可能还需要特定驱动程序的hack，以确保mpv同步到正确的显示器。合成窗口管理器也会导致不好的结果，比如显示FPS信息可能丢失或不正确（参见 ``--overrid-display-fps`` ）。

``--vulkan-device=<device name>``
    用于渲染和呈现的Vulkan设备的名称。使用 ``--vulkan-device=help`` 来查看可用设备的列表和它们的名称。如果未指定，将使用第一个枚举的硬件Vulkan设备。

``--vulkan-swap-mode=<mode>``
    控制vulkan交换链的呈现模式。这与 ``--opengl-swapinterval`` 选项相似。

    auto
        使用vulkan上下文的首选交换链模式（默认）
    fifo
        非撕裂，垂直同步被阻塞。类似于“垂直同步打开”
    fifo-relaxed
        撕裂，垂直同步被阻塞。迟来的帧会撕裂而不是卡顿
    mailbox
        非撕裂，无垂直同步阻塞。类似于“三重缓冲”
    immediate
        撕裂，无垂直同步阻塞。类似于“垂直同步关闭”

``--vulkan-queue-count=<1..8>``
    控制用于渲染的VkQueues的数量（受你的设备支持的数量限制）。理论上，使用更多的队列可以在帧之间实现一些并行性（当使用一个高于1的 ``--swapchain-depth`` 时），但在队列之间没有真正的并行性的硬件上，它也会使这变得缓慢。（默认： 1）

``--vulkan-async-transfer``
    在支持的vulkan设备上启用异步传输队列的使用。使用它们可以使纹理上传和混合等传输操作与实际渲染同时进行，从而提高整体吞吐量和功耗。默认启用，而且应该是相对安全的。

``--vulkan-async-compute``
    在支持的vulkan设备上启用异步计算队列的使用。从理论上讲，使用它可以实现计算着色器与图形着色器的乱序调度，从而使硬件在等待管线bubbles和内存操作时能够做更有效的工作。不是在所有的GPU上都有优势。值得注意的是，如果启用了异步计算，并且设备支持的计算队列多于图形队列（受 ``--vulkan-queue-count`` 的限制），mpv将在内部尝试并尽可能优先使用计算着色器而不是片段着色器。默认启用，尽管Nvidia用户可能想禁用它。

``--vulkan-display-display=<n>``
    当使用 ``displayvk`` GPU上下文时，选定的Vulkan设备上的显示器的索引将呈现在上面。使用 ``--vulkan-display-display=help`` 来查看可用的显示器列表。如果没有指定，将使用第一个枚举的显示器。

``--vulkan-display-mode=<n>``
    当使用 ``displayvk`` GPU上下文时，所选Vulkan显示器的显示模式的索引。使用 ``--vulkan-display-mode=help`` 来查看可用模式的列表。如果没有指定，将使用第一个枚举的模式。

``--vulkan-display-plane=<n>``
    当使用 ``displayvk`` GPU上下文时，选定的Vulkan设备上的平面的索引，以呈现在上面。使用 ``--vulkan-display-plane=help`` 来查看可用平面的列表。如果没有指定，将使用第一个枚举的平面。

``--d3d11-exclusive-fs=<yes|no>``
    当全屏视频被请求时，将D3D11交换链的全屏状态切换为“全屏”。在其它应用程序中也被称为“独占全屏”或“D3D全屏”。让mpv完全控制在交换链的屏幕上进行渲染。默认情况下是关闭的。

``--d3d11-warp=<yes|no|auto>``
    使用WARP（Windows高级光栅化平台）与D3D11 GPU后端（默认： auto）。这是一个高性能的软件渲染器。默认情况下，只有当系统没有支持D3D11的硬件适配器时才会使用它。即使扩展的GPU功能将与WARP一起工作，但它们可能非常慢。

``--d3d11-feature-level=<12_1|12_0|11_1|11_0|10_1|10_0|9_3|9_2|9_1>``
    在使用D3D11 GPU后端时，选择一个特定的功能等级。默认情况下，会使用最高的可用功能等级。这个选项可以用来选择一个较低的功能等级，这主要是对调试有用。大多数扩展的GPU特性在9_x功能等级下将无法工作。

``--d3d11-flip=<yes|no>``
    启用翻转模型呈现，通过与DWM共享表面来避免不必要地复制后缓存（默认： yes）。这可能会引起老旧驱动的性能问题。如果不支持翻转模型呈现（例如，在没有平台更新的Windows 7上），mpv将自动回退到旧的bitblt呈现模型。

``--d3d11-sync-interval=<0..4>``
    安排呈现每一帧的VBlank间隔数（默认：1）。设置为1将启用垂直同步，设置为0将禁用它。

``--d3d11-adapter=<adapter name|help>``
    选择一个特定的D3D11适配器来进行D3D11渲染。如果没有设置，将选择默认的适配器。当给出“help”时，会列出其它的适配器。

    根据字符串的开头来检查是否匹配，不区分大小写。因此，如果适配器的描述以厂商名称开始，就可以使用它作为选择参数。

    利用D3D11渲染抽象的辅助功能来接收设备的硬件解码器，比如D3D11VA或DXVA2的DXGI模式，将受此选择的影响。

``--d3d11-output-format=<auto|rgba8|bgra8|rgb10_a2|rgba16f>``
    选择一种用于D3D11渲染的特定的D3D11输出格式。"auto" 是默认的，它将根据设置的桌面位深度选择rgba8或rgb10_a2。rgba16f和bgra8不在自动检测逻辑中，可用于手动测试。

    .. note::

        桌面位深度的查询只来自于Windows 10的API。因此在旧系统上，它只能自动利用rgba8输出格式。

``--d3d11-output-csp=<auto|srgb|linear|pq|bt.2020>``
    选择一个用于D3D11渲染的特定的D3D11输出色彩空间。 ``auto`` 是默认值，它将选择交换链所在的桌面的色彩空间。

    除了 ``srgb`` 和 ``pq`` 以外的值在测试中存在问题，所以它们主要用于手动测试。

    .. note::

        交换链色彩空间的设置只能从Windows 10的API中获得。因此，在旧系统上它将无法工作。

``--d3d11va-zero-copy=<yes|no>``
    默认情况下，当使用 ``--gpu-api=d3d11`` 带硬件解码时  ，视频图像将从解码器表面复制（GPU到GPU）到一个着色器资源。设置这个选项可以避免复制，直接从解码器图像中采样。这可能会提高性能并降低功耗，但是由于填充的原因，可能会导致图像在底部和右侧边缘的采样不正确，并且可能会引发驱动错误，因为Direct3D 11在技术上不允许从解码器表面采样（尽管大多数驱动支持它）。

    目前只与 ``--gpu-api=d3d11`` 有关。

``--wayland-app-id=<string>``
    为基于Wayland的视频输出方法设置client app ID（默认： ``mpv`` ）。

``--wayland-configure-bounds=<auto|yes|no>``
    控制mpv是否选择进入由合成器发送的configure bounds事件（默认： auto）。这将限制mpv窗口的初始大小，使其达到合成器所期望的最大尺寸。在大多数情况下，这只是为了防止mpv窗口在第一次渲染时大于显示器的尺寸。默认值为 ``auto`` ，此时如果任何 ``autofit`` 或 ``geometry`` 类的选项也被设置，configure-bounds 将被静默忽略。

``--wayland-content-type=<auto|none|photo|video|game>``
    如果合成器支持，mpv将使用内容类型协议发送一个提示，告诉合成器正在显示什么类型的内容。 ``auto`` （默认）将自动切换，告诉合成器内容是照片、视频或可能不是，这取决于内部启发式的方法。

``--wayland-disable-vsync=<yes|no>``
    为基于Wayland的视频输出禁用mpv的内部垂直同步（默认： no）。当与 ``--video-sync=display-desync`` ``--no-audio`` 和 ``--untimed=yes`` 结合使用时，这对wayland视频输出的基准测试非常有用。

``--wayland-edge-pixels-pointer=<value>``
    定义边缘边框的大小（默认： 16），以便使用鼠标在wayland上下文中启动client调整大小的events。仅当合成器中没有服务器端装饰时，此选项才能激活。

``--wayland-edge-pixels-touch=<value>``
    定义边缘边框的大小（默认： 32），以便使用鼠标在wayland上下文中启动client调整大小的events。

``--spirv-compiler=<compiler>``
    控制哪个编译器用于将GLSL翻译成SPIR-V。这（目前）只与 ``--gpu-api=vulkan`` 和 ``--gpu-api=d3d11`` 有关。目前可能的选择只有：

    auto
        使用第一个可用的编译器（默认）
    shaderc
        使用libshaderc，它是一个围绕glslang的API wrapper。如果可用，这通常是最优先的

    .. note::

        这个选项已过时，因为只有一个合理的值。它可能在将来被移除。

``--glsl-shader=<file>``, ``--glsl-shaders=<file-list>``
    自定义GLSL hooks。这些是一种灵活的来添加自定义片段着色器的方式，可以在渲染管线中几乎任意的点注入，并访问所有先前的中间纹理。

    每次使用 ``--glsl-shader`` 选项都会在内部着色器列表中添加另一个文件，而 ``--glsl-shaders`` 则是一个文件列表，并用它覆盖内部列表。后者是一个路径列表选项（详见 `列表选项`_ ）。

    .. admonition:: 警告

        语法还不稳定且可能随时会改变。

    用户着色器的一般语法是这样的::

        //!METADATA ARGS...
        //!METADATA ARGS...

        vec4 hook() {
           ...
           return something;
        }

        //!METADATA ARGS...
        //!METADATA ARGS...

        ...

    每一段元数据，连同它后面的非元数据行，都定义了单一的块。目前有两种类型的块，HOOKs和TEXTUREs。

    一个 ``TEXTURE`` 块可以设置以下选项：

    TEXTURE <name> (required)
        这个纹理的名称。然后Hooks可以用BIND绑定这个名字下的纹理。这必须是纹理块的第一个选项。

    SIZE <width> [<height>] [<depth>] (required)
        纹理的尺寸。高度和深度是可选的。纹理的类型（1D、2D或3D）取决于指定的组件数量。

    FORMAT <name> (required)
        示例的纹理格式。初始化 ``gpu`` 视频输出驱动时，支持的纹理格式将在调试日志记录中列出（查找 ``Texture formats:`` ）。通常，这遵循OpenGL命名规则。例如， ``rgb16`` 提供了3个具有标准化16位组件的通道。一个奇怪之处是浮点格式：例如， ``rgba16f`` 具有16位内部精度，但纹理数据以32位浮点形式提供，驱动程序在纹理上传时转换数据。

        虽然格式名称遵循通用的命名规则，但并不是所有的硬件、驱动、GL版本等都能使用这些格式。

    FILTER <LINEAR|NEAREST>
        从该纹理采样时使用的最小/放大率filter。

    BORDER <CLAMP|REPEAT|MIRROR>
        从该纹理采样时使用的边框wrapping模式。

    元数据之后接一串十六进制的字节，定义了原始纹理数据，对应 ``FORMAT`` 指定的格式，在单行上，没有多余的空白。

    一个 ``HOOK`` 块可以设置以下选项：

    HOOK <name> (required)
        要挂钩的纹理。在一个元数据块中可以出现多次，最多是一个预定的限制。请看下面的可钩住的纹理列表。

    DESC <title>
        用户友好型的传递描述。这是在属性 ``vo-passes`` 的传递列表中代表该着色器时使用的名称。

    BIND <name>
        加载一个纹理（可以来自mpv，也可以来自 ``TEXTURE`` 块），并使其可用于该通道。当从mpv中绑定纹理时，这也将设置宏，以方便正确访问它。列表见下文。默认情况下，没有纹理被绑定。特殊名称HOOKED可以用来指代触发这个传递的纹理。

    SAVE <name>
        给出纹理的名称，以便将这次传递的结果保存到其中。默认情况下，它被设置为特殊名称HOOKED，具有覆盖挂钩纹理的效果。

    WIDTH <szexpr>, HEIGHT <szexpr>
        指定本次处理结果的纹理尺寸。 ``szexpr`` 指的是RPN（反向波尔符号）中的表达式，使用运算符+ - * / > < !，浮点字数，以及对现有纹理（如MAIN.width或CHROMA.height）、OUTPUT或NATIVE_CROPPED（经过pan-and-scan, video-align-x/y, video-pan-x/y等裁剪的输入纹理的尺寸，可能还有预缩放）的引用。默认情况下，这些被分别设置为HOOKED.w和HOOKED.h。

    WHEN <szexpr>
        指定一个需要为真（非零）的条件，以使着色器阶段被评估。如果它失败了，它将被默默地省略（注意，像这样的着色器阶段，如果依赖于一个可选的钩子点，仍然会导致钩子点被保存，这有一些小的开销）。

    OFFSET <ox oy | ALIGN>
        表示这个通道所引入的像素偏移（offset）。这些像素偏移将被累积，并在下一个缩放通道（ ``cscale`` 或 ``scale`` ）中被修正。默认值是0 0，对应于无偏移。请注意，在不覆盖挂钩纹理时，偏移量会被忽略。

        一个特殊的值  ``ALIGN`` 将试图通过将其与参照物对齐来修复HOOKED的现有偏移。它要求HOOKED是可调整大小的（见下文）。它与片段着色器透明地工作。对于计算着色器，需要使用预定义的 ``texmap`` 宏来处理坐标映射。

    COMPONENTS <n>
        指定这个通道的输出有多少个相关的组件，并且应该存储在纹理中，最多4个（rgba）。默认情况下，这个值等于HOOKED中的组件数。

    COMPUTE <bw> <bh> [<tw> <th>]
        指定此着色器应被视为计算着色器，其块大小为bw和bh。计算着色器将被派发多少个必要的块，以完全铺满输出。在每个块中，将有tw*th线程，形成一个工作组。换句话说：tw和th指定了工作组的大小，它可以与块的大小不同。因此，举例来说，一个在500x500纹理上运行的bw, bh = 32，tw, th = 8的计算着色器将调度16x16块（向上取整），每个块有8x8个线程。

        mpv中的计算着色器的处理方式与片段着色器有些不同。你不需要定义产生输出样本的 ``vec4 hook`` ，而是直接定义 ``void hook`` ，使用 ``imageStore`` 写到一个固定的只写的图像单元 ``out_image`` （这是由mpv绑定的）。为了帮助在没有顶点的情况下翻译纹理坐标，mpv提供了一个特殊的函数 ``NAME_map(id)`` 来从输出图像的texel空间映射到所有绑定纹理的纹理坐标。特别是， ``NAME_pos`` 等同于 ``NAME_map(gl_GlobalInvocationID)`` ，尽管只有在(tw,th)==(bw,bh)的情况下使用这个函数才真正有意义。

    每个绑定的mpv纹理（通过 ``BIND`` ）将为该着色器通道提供以下定义，其中NAME是绑定纹理的名称：

    vec4 NAME_tex(vec2 pos)
        用来访问某个点的纹理的采样函数（在纹理坐标空间，范围[0,1]）。这将处理任何必要的归一化转换。
    vec4 NAME_texOff(vec2 offset)
        以像素为单位在某一偏移处对纹理进行采样。工作原理与NAME_tex类似，但还负责必要的旋转，例如在vec2(-1,0)处取样，总是向左倾斜一个像素。
    vec2 NAME_pos
        该纹理的局部纹理坐标，范围[0,1]。
    vec2 NAME_size
        纹理的（旋转）尺寸，单位为像素。
    mat2 NAME_rot
        与该纹理相关的旋转矩阵（将像素空间旋转到纹理坐标）。
    vec2 NAME_pt
        单个像素的（未旋转的）尺寸，范围[0,1]。
    float NAME_mul
        需要乘以纹理内容的系数，以便将其归一化为[0,1]的范围。
    sampler NAME_raw
        原始绑定纹理本身。除非绝对必要，否则应避免使用这个。

    通常情况下，用户应该使用NAME_tex或NAME_texOff来读取纹理。然而，对于某些着色器来说，从NAME_RAW中进行自定义采样，性能会更好，在这种情况下，需要注意遵循NAME_mul和NAME_rot。

    除了这些参数外，以下uniforms也是全局可用的：

    float random
        范围为[0-1]的随机数，每帧不同。
    int frame
        一个简单的渲染帧数，每一帧增加一个，永不重置（不考虑寻求）。
    vec2 input_size
        输入图像的像素大小（可能经过裁剪和预缩放）。
    vec2 target_size
        缩放后（可能是裁剪后）的图像的可见部分的像素大小。
    vec2 tex_offset
        由用户着色器或panscan、video-align-x/y、video-pan-x/y等选项引入的纹理偏移。

    在内部，vo_gpu可以生成以下任意数量的纹理。每当一个纹理被vo_gpu渲染并保存时，所有钩住它的通道都会按照用户添加的顺序运行。这是一个合法钩点的列表：

    RGB, LUMA, CHROMA, ALPHA, XYZ (resizable)
        源平面（原始）。其中哪个工作取决于源的图像格式。

    CHROMA_SCALED, ALPHA_SCALED (fixed)
        源平面（放大）。这些只在抽样的内容上启动。

    NATIVE (resizable)
        合并后的图像，在源色彩空间中，转换为RGB之前。

    MAINPRESUB (resizable)
        转换为RGB后的图像，但在应用 ``--blend-subtitles=video`` 之前。

    MAIN (resizable)
        主图像，在转换为RGB后，但在放大前。

    LINEAR (fixed)
        线性亮度图像，在缩放之前。这只在 ``--linear-upscaling``, ``--linear-downscaling`` or ``--sigmoid-upscaling`` 生效的情况下发生。

    SIGMOID (fixed)
        在缩放之前，对亮度进行Sigmoid处理。这只在 ``--sigmoid-upscaling`` 生效的情况下发生。

    PREKERNEL (fixed)
        缩放器kernel运行前的图像。

    POSTKERNEL (fixed)
        缩放器kernel运行后的图像。

    SCALED (fixed)
        在进行色彩管理之前，最终放大的图像。

    OUTPUT (fixed)
        最终的输出图像，在色彩管理之后但在抖动和绘制到屏幕之前。

    只有标有 ``resizable`` 的贴图可以通过该通道进行转换。当覆盖一个标有 ``fixed`` 的纹理时，WIDTH、HEIGHT和OFFSET必须保持其默认值。

``--glsl-shader=<file>``
    CLI/设置文件只是 ``--glsl-shaders-append`` 的别名。

``--glsl-shader-opts=param1=value1,param2=value2,...``
    指定用于可调节着色器参数的选项。你可以通过在着色器名称前加上 ``/`` ，例如 ``shader/param=value`` ，来针对特定命名的着色器。如果没有前缀，参数会影响所有着色器。着色器名称是着色器文件名的基础部分，不带扩展名（ ``--vo=gpu-next`` 独占）。

``--deband``
    启用去色带算法。这大大减少了可见的色带、色块和其它量化伪影的数量，代价是使一些最细微的细节变得非常模糊。在实际中，它几乎总是一种改进 —— 禁用它的唯一原因是为了性能。

``--deband-iterations=<1..16>``
    每个采样要执行去色带步骤的数量。每一步都会减少一点带状物，但需要时间来计算。注意，每一步的强度下降得很快，所以较高数字（>4）实际上是无用的（默认： 1）。

``--deband-threshold=<0..4096>``
    去色带滤镜的截止阀值。较高的数字会大大增加去色带强度，但会逐渐减少图像细节（默认： 32）。

``--deband-range=<1..64>``
    去色带的初始半径。半径在每次迭代中线性增加。半径越大则坡度越大，但半径越小平滑效果越好（默认： 16）。

    如果你增加了 ``--deband-iterations`` ，你可能应该减少此项来进行补偿。

``--deband-grain=<0..4096>``
    给图像添加一些额外的噪点。这大大有助于掩盖剩余的量化伪影。更高的数字会增加更多的噪点（默认： 48）。

``--corner-rounding=<0..1>``
    如果将值设置为大于 0.0 ，则输出将呈现带有圆角的效果，就好像应用了一个alpha透明度遮罩一样。该值表示要圆角的边长的相对比例 - 值为 1.0 时尽可能圆角化（ ``--vo=gpu`` 独占）。

``--sharpen=<value>``
    如果设置为0以外的值，则启用一个unsharp masking滤镜。正值将锐化图像（但增加更多的振铃和锯齿）。负值会使图像变得模糊。如果你的GPU足够强大，可以考虑使用 ``ewa_lanczossharp`` 缩放filter或 ``--scale-blur`` 选项取代（ ``--vo=gpu`` 独占）。

``--opengl-glfinish``
    在交换缓冲区之前调用 ``glFinish()`` （默认： no）。速度较慢，但在进行framedropping时可能会改善结果。可能完全损坏性能。细节完全取决于OpenGL驱动。

``--opengl-waitvsync``
    在每次缓冲区交换后调用 ``glXWaitVideoSyncSGI`` （默认： no）。这可能会也可能不会对视频计时的准确性和丢帧有帮助。这有可能使视频输出变慢，或者根本没有影响。

    （X11/GLX独占）

``--opengl-dwmflush=<no|windowed|yes|auto>``
    在Windows下交换缓冲区后调用 ``DwmFlush`` （默认： auto）。它还设置了 ``SwapInterval(0)`` 以忽略OpenGL的时间。可用的值是：no（禁用），windowed（仅在窗口模式下），yes（也在全屏下）。

    值 ``auto`` 将尝试确定合成器是否处于激活状态，只有当它似乎处于活动状态时才调用 ``DwmFlush``

    这可能有助于获得更一致的帧间隔，特别是对于高帧率的clips —— 这也可能减少丢帧。通常，一个 ``windowed`` 的值就足够了，因为全屏可能会绕过DWM。

    （Windows独占）

``--angle-d3d11-feature-level=<11_0|10_1|10_0|9_3>``
    在D3D11中使用ANGLE后端时，选择一个特定的功能等级。默认情况下，会使用最高的可用功能等级。这个选项可以用来选择一个较低的功能等级，这主要对调试有用。请注意，OpenGL ES 3.0只支持10_1或更高的功能等级。大多数扩展的OpenGL功能在较低的功能等级下无法工作（类似于 ``--gpu-dumb-mode`` ）。

    （Windows ANGLE独占）

``--angle-d3d11-warp=<yes|no|auto>``
    在D3D11中使用ANGLE后端时，使用WARP（Windows高级光栅化平台）（默认： auto）。这是一个高性能的软件渲染器。默认情况下，当Direct3D硬件不支持Direct3D 11功能级别9_3时，会使用它。虽然扩展的OpenGL功能将与WARP一起工作，但它们可能非常慢。

    （Windows ANGLE独占）

``--angle-egl-windowing=<yes|no|auto>``
    使用ANGLE的内置EGL窗口函数来创建交换链（默认： auto）。如果设置为 ``no`` ，并且正在使用D3D11渲染器，ANGLE内置的交换链将不被使用，而是创建一个为视频渲染而优化的自定义交换链。如果设置为 ``auto`` ，自定义交换链将用于D3D11，而内置交换链将用于D3D9。这个选项主要是为了调试，以防自定义交换链的性能不佳或不工作。

    如果设置为 ``yes`` ，选项 ``--angle-max-frame-latency``, ``--angle-swapchain-length`` 和 ``--angle-flip``  将没有影响。

    （Windows ANGLE独占）

``--angle-flip=<yes|no>``
    启用翻转模型呈现，这可以避免通过与DWM共享表面而不必要地复制后缓存（默认： yes）。这可能会导致老旧驱动的性能问题。如果不支持翻转模型呈现（例如，在没有平台更新的Windows 7上），mpv将自动回退到旧的bitblt呈现模型。

    如果设置为 ``no`` ，选项 ``--angle-swapchain-length`` 将没有影响。

    （Windows ANGLE独占）

``--angle-renderer=<d3d9|d3d11|auto>``
    在使用ANGLE后端时强制使用特定的渲染器（默认： auto）。在自动模式下，对于支持Direct3D 11功能级别9_3或更高的系统，它会选择D3D11，否则会选择D3D9。这个选项主要是为了调试的目的。通常情况下，没有理由强制使用特定的渲染器，尽管 ``--angle-renderer=d3d9`` 在旧硬件上可能会有稍好的性能。请注意，D3D9渲染器只支持OpenGL ES 2.0，所以如果选择了这个渲染器，大多数扩展的OpenGL功能将无法工作（类似于 ``--gpu-dumb-mode`` ）。

    （Windows ANGLE独占）

``--macos-force-dedicated-gpu=<yes|no>``
    停用自动图形切换并强制使用独立GPU（默认： no）。

    （macOS独占）

``--cocoa-cb-sw-renderer=<yes|no|auto>``
    在使用cocoa-cb时使用苹果软件渲染器（默认： auto）。如果设置为 ``no`` ，软件渲染器永远不会被使用，而是在无法创建通常的像素格式时失败， ``yes`` 将永远只使用软件渲染器，而 ``auto`` 只在无法创建通常的像素格式时回退到软件渲染器。

    （macOS独占）

``--cocoa-cb-10bit-context=<yes|no>``
    为上下文的创建创建一个10bit的像素格式（默认： yes）。要求使用16位的半浮点帧缓冲器，而不是8位的整数帧缓冲器。

    （macOS独占）

``--macos-title-bar-appearance=<appearance>``
    设置标题栏的外观（默认： auto）。并非所有的外观和 ``--macos-title-bar-material`` 材质的组合都是有意义的或者是唯一的。当前macOS版本不支持的外观会回退到默认值。

    ``<appearance>`` 可以是下列之一：

    :auto:                     检测系统设置并适当地设置标题栏的外观。在macOS 10.14上，它也能检测到运行时的变化
    :aqua:                     标准的macOS浅色外观
    :darkAqua:                 标准的macOS暗色外观(macOS 10.14+)
    :vibrantLight:             充满活力的浅色外观
    :vibrantDark:              充满活力的深色外观
    :aquaHighContrast:         浅色无障碍外观(macOS 10.14+)
    :darkAquaHighContrast:     深色无障碍外观(macOS 10.14+)
    :vibrantLightHighContrast: 活力的浅色易读性外观(macOS 10.14+)
    :vibrantDarkHighContrast:  活力的深色易读性外观(macOS 10.14+)

``--macos-title-bar-material=<material>``
    设置标题栏的材质（默认： titlebar）。所有过时的材质不应该在macOS 10.14+上使用，因为它们的功能没有保证。不是所有的材质和 ``--macos-title-bar-appearance`` 的组合都有意义，也不是唯一的。你当前的macOS版本不支持的材质会回退到默认值。（macOS和cocoa-cb独占）

    ``<material>`` 可以是以下的一种：

    :titlebar:              标准的macOS标题栏材质
    :selection:             标准的macOS选择材质
    :menu:                  标准的macOS菜单材质(macOS 10.11以上)
    :popover:               标准的macOS弹出窗口材质(macOS 10.11+)
    :sidebar:               标准的macOS侧边栏材质(macOS 10.11+)
    :headerView:            标准的macOS标题视图材质(macOS 10.14+)
    :sheet:                 标准的macOS页面材质(macOS 10.14+)
    :windowBackground:      标准的macOS窗口背景材质(macOS 10.14+)
    :hudWindow:             标准的macOS hudWindow材质(macOS 10.14+)
    :fullScreen:            标准的macOS全屏材质(macOS 10.14+)
    :toolTip:               标准的macOS工具提示材质(macOS 10.14+)
    :contentBackground:     标准的macOS内容背景材质(macOS 10.14+)
    :underWindowBackground: 标准的macOS窗口下的背景材质(macOS 10.14+)
    :underPageBackground:   标准的macOS页面下的背景材质(在macOS 10.14+中已过时)
    :dark:                  标准的macOS深色材质(在macOS 10.14+中已过时)
    :light:                 标准的macOS浅色材质(macOS 10.14+)
    :mediumLight:           标准的macOS中浅材质(macOS 10.11+, 在macOS 10.14+中已过时)
    :ultraDark:             标准的macOS超深材质(macOS 10.11+, 在macOS 10.14+中已过时)

``--macos-title-bar-color=<color>``
    设置标题栏的颜色（默认：完全透明）。受 ``--macos-title-bar-appearance`` 和 ``--macos-title-bar-material`` 的影响。颜色语法参见 ``--sub-color``

``--macos-fs-animation-duration=<default|0-1000>``
    设置全屏调整大小动画的持续时间，单位是ms（默认： default）。默认值略小于系统的动画持续时间（500ms），以防止当一个异步动画的结束与系统全屏动画的结束同时发生时出现一些问题。设置任何高于500ms的时间都只会在系统宽屏动画结束后过早地取消调整大小的动画。上限仍然设置为1000ms，因为苹果或用户有可能改变系统的默认值。不过任何高于1000ms的东西都显得太长了，无论如何都不应该被设置。（macOS和cocoa-cb独占）


``--macos-app-activation-policy=<regular|accessory|prohibited>``
    改变应用程序的激活策略。accessory使得Dock中的mpv图标可以被隐藏（默认： regular）。

    （macOS独占）

``--macos-geometry-calculation=<visible|whole>``
    这将改变用于计算窗口的屏幕位置和大小的矩形（默认： visible）。 ``visible`` 考量菜单栏和Dock，窗口只在可见的屏幕框架矩形内定位/大小， ``whole`` 考量整个屏幕框架矩形，忽略了菜单栏和Dock。之前的其他限制仍然适用，比如窗口不能放在菜单栏的上面等等。

    （macOS独占）

``--android-surface-size=<WxH>``
    设置Android gpu上下文使用的渲染表面的尺寸。如果尺寸在运行期间发生变化（例如，如果设备被旋转），需要由嵌入的应用程序通过surfaceChanged回调进行设置。

    （Android 和 ``--gpu-context=android`` 独占）

``--gpu-sw``
    即使检测到软件渲染器也继续。

``--gpu-context=<sys>``
    值 ``auto`` （默认）选择GPU上下文。你也可以通过 ``help`` 来获得后端编译的完整列表（按自动探针顺序排序）。

    auto
        自动选择（默认）
    cocoa
        Cocoa/macOS（已过时，使用--vo=libmpv代替）
    win
        Win32/WGL
    winvk
        VK_KHR_win32_surface
    angle
        Direct3D11通过OpenGL ES转译层ANGLE。这几乎支持 ``win`` 后端所做的一切（如果ANGLE的构建足够新）
    dxinterop（实验性的）
        Win32，使用WGL进行渲染，使用Direct3D 9Ex进行呈现。在Nvidia和AMD上工作。较新的Intel芯片和最新的驱动也适用
    d3d11
        Win32，使用原生Direct3D 11渲染
    x11
        X11/GLX（已过时/遗留，现在优选EGL）
    x11vk
        VK_KHR_xlib_surface
    wayland
        Wayland/EGL
    waylandvk
        VK_KHR_wayland_surface
    drm
        DRM/EGL
    displayvk
        VK_KHR_display。这个后端大致相当于Vukan的DRM/EGL，允许通过Vulkan直接渲染而无需显示管理器
    x11egl
        X11/EGL
    android
        Android/EGL。需要 ``--wid`` 被设置为 ``android.view.Surface``

``--gpu-api=<type>``
    控制哪种类型的图形API将被接受：

    auto
        使用任何可用的API（默认）
    opengl
        只允许OpenGL（需要OpenGL 2.1+或GLES 2.0+）
    vulkan
        只允许Vulkan（需要一个有效的/工作的 ``--spirv-compiler`` ）
    d3d11
        只允许 ``--gpu-context=d3d11``

``--opengl-es=<mode>``
    控制哪种类型的OpenGL上下文将被接受

    auto
        允许所有类型的OpenGL（默认）
    yes
        只允许GLES
    no
        只允许桌面/核心GL

``--fbo-format=<fmt>``
    选择用于FBOs的纹理的内部格式。该格式可以影响视频输出的性能和质量。 ``fmt`` 可以是：rgb8, rgb10, rgb10_a2, rgb16, rgb16f, rgb32f, rgba12, rgba16, rgba16f, rgba16hf, rgba32f之一。

    默认： ``auto`` ，首先尝试使用16位浮点（rgba16f, rgba16hf），如果没有这些浮点，则回退到rgba16。最后，如果先前的所有格式都不可用，则尝试使用rgb10_a2或rgba8。

``--gamma-factor=<0.1..2.0>``
    设置一个额外的原始伽玛系数（默认：1.0）。如果用其他方式调整伽玛（比如用 ``--gamma`` 选项或按键绑定和 ``gamma`` 属性），该值将与其它伽玛值相乘。

    此选项已过时，将来可能会被移除。

``--gamma-auto``
    根据环境照明条件自动修正伽马值（为明亮的房间添加一个伽马增强）。

    此选项已过时，将来可能会被移除。

    注意：只在macOS上实现。

``--image-lut=<file>``
    指定一个自定义的LUT文件（Adobe .cube格式），在图像解码过程中应用到颜色上。LUT的确切解释取决于 ``--image-lut-type`` 的值。（ ``--vo=gpu-next`` 独占）

``--image-lut-type=<value>``
    控制送入和送出指定为 ``--image-lut`` 的LUT的颜色值的解释。有效值是：

    auto
        从标记的元数据中自动选择LUT的解释，否则就回退到 ``native`` （默认）
    native
        在解码为RGB之前，在其原始色彩空间中应用于原始图像内容。例如，对于HDR10图像，这将是在0.0 - 1.0的范围内输入PQ编码的YCbCr值
    normalized
        应用于标准化的RGB图像内容，从其原始色彩编码解码后，但在线性化之前
    conversion
        完全取代了颜色解码。这种类型的LUT应该摄入图像的原生色彩空间，并输出标准化的非线性RGB

``--target-colorspace-hint``
    如果可能的话，自动设置显示器的输出色彩空间，来传递流的输入值（例如，用于HDR直通）。需要一个支持的驱动程序和 ``--vo=gpu-next``

``--target-prim=<value>``
    指定显示器的色彩原色。当不使用ICC色彩管理时，视频色彩将被适应到这个色彩空间。有效值是：

    auto
        禁用任何适应，除了非典型的色彩空间。具体而言，宽/非典型色域会自动适应BT.709，而标准色域（即BT.601和BT.709）的内容不会被触及（默认）
    bt.470m
        ITU-R BT.470M
    bt.601-525
        ITU-R BT.601（525线标清系统，如NTSC），SMPTE 170M/240M
    bt.601-625
        ITU-R BT.601（625线标清系统，如PAL/SECAM），ITU-R BT.470 B/G
    bt.709
        ITU-R BT.709（高清），IEC 61966-2-4（sRGB），SMPTE RP177 Annex B
    bt.2020
        ITU-R BT.2020 (UHD)
    apple
        苹果RGB
    adobe
        Adobe RGB (1998)
    prophoto
        ProPhoto RGB (ROMM)
    cie1931
        CIE 1931 RGB (不要与CIE XYZ混淆)
    dci-p3
        DCI-P3 (Digital Cinema Colorspace), SMPTE RP431-2
    v-gamut
        松下 V-Gamut (VARICAM) primaries
    s-gamut
        索尼 S-Gamut (S-Log) primaries

``--target-trc=<value>``
    指定显示器的转换特性（伽玛）。当不使用ICC色彩管理时，视频色彩将被调整到此曲线。有效值是：

    auto
        禁用任何适应，除了非典型的转换。具体来说，HDR或线性光源材料会自动转换为伽玛2.2，而SDR内容则不被触及（默认）
    bt.1886
        ITU-R BT.1886曲线（假定对比度为无限）
    srgb
        IEC 61966-2-4（sRGB）
    linear
        线性亮度输出
    gamma1.8
        纯功率曲线（伽玛1.8），也被用于苹果RGB
    gamma2.0
        纯功率曲线（伽玛2.0）
    gamma2.2
        纯功率曲线（伽玛2.2）
    gamma2.4
        纯功率曲线（伽玛2.4）
    gamma2.6
        纯功率曲线（伽玛2.6）
    gamma2.8
        纯功率曲线（伽玛2.8），也被用于BT.470-BG
    prophoto
        ProPhoto RGB (ROMM)
    pq
        ITU-R BT.2100 PQ（感知量化器）曲线，又名SMPTE ST2084
    hlg
        ITU-R BT.2100 HLG（混合对数伽马）曲线，又名ARIB STD-B67
    v-log
        松下V-Log（VARICAM）曲线
    s-log1
        索尼S-Log1曲线
    s-log2
        索尼S-Log2曲线

    .. note::

        当使用HDR输出格式时，mpv将按照指定的曲线进行编码，但它不会设置任何HDMI标志或其它信号，这些信号可能是目标设备正确显示HDR信号所需的。用户在使用这些信号格式进行显示之前，应该独立保证这一点。

``--target-peak=<auto|nits>``
    指定输出显示器的测量峰值亮度，单位是cd/m^2（又名尼特）。这个亮度的解释取决于设置的 ``--target-trc`` 。在所有情况下，它对将被发送到显示器的信号值施加了一个限制。如果信号源超过了这个亮度水平，将插入一个色调映射滤镜。对于HLG来说，它还有一个额外的作用，就是对逆向OOTF进行参数化，以便获得与母版显示器一致的色度结果。对于SDR，或者当使用ICC profile（ ``--icc-profile`` ）时，将其设置为高于203的值，基本上会使显示器被视为变相的HDR显示器。（参见下方的注意）

    在 ``auto`` 模式下（默认），所选择的峰值是基于使用中的TRC的一个适当的值。对于SDR曲线，它使用203。对于HDR曲线，它使用203 * 转换函数的额定峰值。

    .. note::

        当使用SDR转换函数时，通常不需要这样做，而且设置它可能会导致非常意外的结果。 *它* 有用的一个场景是如果你想用传统的转换函数和校准设备来校准HDR显示器。在这种情况下，你可以将你的HDR显示器设置为高亮度，如800cd/m^2，然后将其校准到一个标准曲线，如gamma2.8。将这个值设置为800，然后指示mpv将其作为一个具有给定峰值的HDR显示器。在不可能向显示器输入PQ或HLG的环境中，这可能是一个很好的选择，并且使mpv有可能使用HDR显示，而不管操作系统是否支持HDMI HDR元数据。

        在这样的设置中，我们强烈推荐将 ``--tone-mapping`` 设置为 ``mobius`` 或甚至 ``clip``

``--target-lut=<file>``
    指定一个自定义的LUT文件（Adobe .cube格式），在屏幕上显示之前应用于颜色。这个LUT是在编码到目标色彩空间后，以标准化的RGB值输入的，所以在应用 ``---target-trc`` 之后。（ ``--vo=gpu-next`` 独占）

``--tone-mapping=<value>``
    指定用于将图像色调映射到目标显示上的算法。这与HDR->SDR转换和降低色域有关（例如，在标准色域显示器上播放BT.2020内容）。有效值是：

    auto
        根据内部启发式方法选择最佳曲线（默认）
    clip
        硬性裁切任何超出范围的数值。当你关心范围内值的完美色彩准确性时，使用这个方法，代价是完全扭曲范围外的值。一般不推荐使用
    mobius
        Reinhard对具有线性截面的Möbius变换的推广。平滑地映射范围外的值，同时尽可能地保留范围内材料的对比度和颜色。当你关心颜色的准确性而不是细节的保留时，使用它。这介于 ``clip`` 和 ``reinhard`` 之间，取决于 ``--tone-mapping-param``
    reinhard
        Reinhard色调映射算法。非常简单的连续曲线。保留了图像的整体亮度，但使用了非线性对比度，这导致了细节的扁平化和色彩精度的下降
    hable
        类似于 ``reinhard`` ，但更好地保留了暗部和亮部的细节（略带sigmoidal），代价是所有东西都略微变暗/变不饱和。由John Hable开发，用于视频游戏中。当你关心细节的保存而不是颜色/亮度的准确性时，就使用它个。这大致相当于 ``--tone-mapping=reinhard --tone-mapping-param=0.24`` 。如果可能的话，你还应该启用 ``--hdr-compute-peak`` 以获得最佳效果
    bt.2390
        ITU-R报告BT.2390中指定的感知色调映射曲线（EETF）
    gamma
        拟合色调曲线之间的对数转换
    linear
        将整个参考色域线性地拉伸（线性倍数）到显示
    spline
        感知线性单轴多项式（ ``--vo=gpu-next`` 独占）
    bt.2446a
        在ITU-R报告BT.2446中指定的HDR<->SDR映射，方法A。这推荐用于精心制作的内容（ ``--vo=gpu-next`` 独占）
    st2094-40
        SMPTE ST2094-40 附件B中规定的动态HDR10+色调映射方法。在没有元数据的情况下，回退到与输入/输出平均亮度特性相匹配的固定spline（ ``--vo=gpu-next`` 独占）
    st2094-10
        SMPTE ST2094-10 附件B.2中规定的动态色调映射方法。在概念上比ST2094-40简单，但通常产生的结果更差（ ``--vo=gpu-next`` 独占）

``--tone-mapping-param=<value>``
    设置色调映射参数。默认情况下，它被设置为特殊的字符串 ``default`` ，它映射到一个特定算法的默认值。如果色调映射算法不可调则忽略。这影响到下列色调映射算法：

    clip
        指定一个额外的线性系数，在裁剪前乘以信号。默认： 1.0
    mobius
        指定从线性到莫比乌斯变换的过渡点。低于这个点的每一个值都被保证为1:1的映射。这个值越高，结果就越精确，但代价是失去明亮的细节。默认： 0.3，由于初始斜率很陡，它仍然相当准确地保留了范围内的颜色
    reinhard
        指定显示峰值处的局部对比度系数。默认： 0.5，这表示in-gamut值的亮度将是裁切时的一半左右
    bt.2390
        指定knee点的偏移量。默认： 1.0，高于原始ITU-R规范的值0.5（ ``--vo=gpu-next`` 独占）
    gamma
        指定函数的指数。默认： 1.8
    linear
        指定拉伸时使用的缩放系数。默认： 1.0
    spline
        指定knee点（在PQ空间中）。默认： 0.30
    st2094-10
        指定knee点的对比度（斜率）。默认： 1.0

``--inverse-tone-mapping``
    如果设置，允许反转色调映射（将SDR扩展到HDR）。不是所有的色调映射曲线都支持。请谨慎使用。（ ``--vo=gpu-next`` 独占）

``--tone-mapping-max-boost=<1.0..10.0>``
    允许色调映射算法通过过曝提高图像平均亮度的上限。默认： 1.0，不允许额外提高亮度。2.0的值允许过曝2倍，以此类推。提高这个设置可以帮助揭示黑暗场景中隐藏的细节，但提高得太高会使黑暗场景显得不自然地明亮。（ ``--vo=gpu`` 独占）

``--tone-mapping-mode``
    控制色调映射函数如何应用到颜色上。

    auto
        自动选择最佳模式（默认）
    rgb
        每个通道的色调映射（RGB）。有严重扭曲颜色的倾向，使高光部分不饱和，一般不大推荐。然而，这是许多显示器和电视（特别是早期的）使用的模式，所以有时需要它来再现电影的艺术意图
    max
        对视频中最亮的部分进行色调映射。有一种导致奇怪的过饱和颜色，以及黑暗细节损失的倾向
    hybrid
        一种混合方法，对中间色调使用线性色调映射，对高光使用每通道色调映射
    luma
        基于亮度的方法，来自ITU-R BT.2446a，包括固定的色域减少，来考量与亮度有关的感知不均匀性（ ``--vo=gpu-next`` 独占）

``--tone-mapping-visualize``
    显示色调映射LUT（PQ-PQ）的活动图。仅用于调试目的。X轴显示PQ输入值，Y轴显示PQ输出值。色调映射曲线显示为绿色/黄色。黄色意味着亮度从源头上被提高了，深蓝色区域显示亮度被降低的地方。额外的彩色区域和线条表示各种显示器限制，以及参考对角线（中性色调映射）和源场景平均亮度信息（如果有的话）。（ ``--vo=gpu-next`` 独占）

``--gamut-mapping-mode``
    在完成任何色调映射后，指定用于降低目标显示的图像色域的算法。

    auto
        自动选择最佳模式（默认）
    clip
        硬性裁切到色域（每个通道）。非常低质量，但极低性能损耗
    perceptual
        使用软拐点函数来进行平衡感知的色域映射，以消除裁切区域，并使用色调变换函数来保持饱和度（ ``--vo=gpu-next`` 独占）
    relative
        执行相对比色法，同时保持亮度和色度之间的指数关系（ ``--vo=gpu-next`` 独占）
    saturation
        执行简单的RGB->RGB饱和度映射。输入的R/G/B通道被直接映射到输出的R/G/B通道。不会出现裁切，但会扭曲所有的色调且/或导致褪色的观感（ ``--vo=gpu-next`` 独占）
    absolute
        执行绝对色度剪裁。与 ``relative`` 类似，但不适应白点（ ``--vo=gpu-next`` 独占）
    desaturate
        执行恒定亮度比色法，使颜色向白色褪色，直到它们在色域范围内
    darken
        均匀地使输入略微变暗，以防止高光部分被削掉，然后将色度钳制在输入色域边界，略微偏向于保留色度而不是亮度（ ``--vo=gpu-next`` 独占）
    warn
        不进行色域映射，而只是高亮色域外的像素
    linear
        线性/均匀地使图像去饱和，以使整个图像进入目标色域（ ``--vo=gpu-next`` 独占）

``--hdr-compute-peak=<auto|yes|no>``
    计算每一帧HDR峰值和帧平均亮度，而不是依赖标记的元数据。这些值是局部区域以及几帧的平均值，以防止数值抖动太大。这个选项基本上为你提供了动态的、每个场景的色调映射。需要计算着色器，这是一个相当新的OpenGL特性，而且在某些驱动上可能会表现得很糟糕，所以启用时要自己承担风险。如果支持计算着色器和SSBO，特殊值 ``auto`` （默认）将自动启用HDR峰值计算。

``--allow-delayed-peak-detect``
    当使用 ``--hdr-compute-peak`` 时，如果对性能有利，允许将检测到的峰值延迟一帧。特别是，当不需要高级渲染时，需要这样做以避免不必要的FBO介入。如果已经有一个indirect传递，例如启用高级缩放时，则没有影响。默认为开。（ ``--vo=gpu-next`` 独占，注意 ``--vo=gpu`` 始终延迟峰值。）

``--hdr-peak-decay-rate=<1.0..1000.0>``
    用于HDR峰值检测算法的衰减率（默认： 100.0）。这只与 ``--hdr-compute-peak`` 启用时有关。更高的值使峰值衰减得更慢，导致更稳定的数值，但代价是更多类似"eye adaptation"的效果（尽管这在一定程度上被 ``--hdr-scene-threshold`` 缓解）。1.0的值（可能的最低值）可以禁止所有的平均化，这意味着每一帧的值都直接作为测量值使用，但是对于"noisy"源不推荐这样做，因为它可能导致过度的闪烁。（在信号理论方面，这控制了IIR低通滤波器的时间常数"tau"。）

``--hdr-scene-threshold-low=<0.0..100.0>``, ``--hdr-scene-threshold-high=<0.0..100.0>``
    亮度差异被认为是场景变化的最低和最高阈值（单位：dB）（默认：5.5低，10.0高）。这只有在启用 ``--hdr-compute-peak`` 时才相关。通常情况下，画面亮度的小波动会被峰值平均机制补偿，但对于亮度的大跳动，会导致画面过亮或过暗长达几秒钟，这取决于 ``--hdr-peak-decay-rate`` 的值。为了解决这个问题，当运行中的平均值和当前帧之间的亮度超过低阈值时，mpv将使averaging filter更加积极，直到高阈值的极限（此时filter会变得即时）。

``--use-embedded-icc-profile``
    加载媒体文件（如PNG图像）中的内嵌ICC profile（默认： yes）。请注意，这个选项只有在同时使用显示ICC profile（ ``--icc-profile`` 或 ``--icc-profile-auto`` ）时才有效，而且还需要LittleCMS 2支持。

``--icc-profile=<file>``
    加载一个ICC profile，并使用它来转换视频RGB到屏幕输出。需要LittleCMS 2的编译支持。它覆盖了 ``--target-prim``, ``--target-trc`` 和 ``--icc-profile-auto`` 选项。

``--icc-profile-auto``
    自动选择当前由操作系统的显示设置指定的ICC显示profile。

    注意：在Windows上，默认profile必须是一个ICC profile。不支持WCS profiles。

    使用libmpv和渲染API的应用程序需要通过 ``MPV_RENDER_PARAM_ICC_PROFILE`` 提供ICC profile。

``--icc-cache``
    是否存储和加载从ICC profile中创建的3D LUTs缓存。这可以用来加快加载速度，因为LittleCMS 2创建一个3D LUT可能需要一段时间。请注意，这些文件包含了未压缩的LUTs。它们的大小取决于 ``--icc-3dlut-size`` ，而且可能非常大。

    注意：这不是自动清理的，所以旧的、未使用的缓存文件可能会无限期地存在。

``--icc-cache-dir``
    储存icc缓存的目录。如果未设置，缓存将被存储在系统的缓存目录下（通常是 ``~/.cache/mpv`` ）。

``--icc-intent=<value>``
    指定用于颜色转换的ICC意图（当使用 ``--icc-profile`` 时）。

    0
        感知的
    1
        相对色度（默认）
    2
        饱和度
    3
        绝对色度

``--icc-3dlut-size=<r>x<g>x<b>``
    从ICC profile生成的3D LUT在每个维度的大小。默认是64x64x64。大小范围从2到512。

``--icc-force-contrast=<no|0-1000000|inf>``
    用一个特定的值覆盖目标设备的检测对比度。如果可能的话，这是从profile中自动检测出来的，但对于某些profile来说，它可能会丢失，导致对比度被认为是无限的。因此，视频可能看起来比预期的更暗。如果是这种情况，设置这个选项可能有帮助。这只影响BT.1886内容。默认的 ``no`` 表示使用profile的值。特殊值 ``inf`` 会使BT.1886曲线被当作纯功率的伽玛2.4函数处理。

``--icc-use-luma``
    使用ICC配置文件内的亮度值。（ ``--vo=gpu-next`` 独占）

``--lut=<file>``
    指定一个自定义的LUT（Adobe .cube格式），作为颜色转换的一部分应用到颜色上。具体解释取决于 ``--lut-type`` 的值。（ ``--vo=gpu-next`` 独占）

``--lut-type=<value>``
    控制送入和送出指定为 ``--lut`` 的LUT的颜色值的解释。有效值是：

    auto
        从标记的元数据中自动选择LUT的解释，否则就退回到 ``native`` （默认）
    native
        在转换到输出色彩空间之前，应用于原始RGB色彩空间的原始图像内容（非线性亮度）
    normalized
        在转换到输出色彩空间之前，应用于线性亮度下的标准化RGB图像内容
    conversion
        完全取代了从图像色彩空间到输出色彩空间的转换。如果有这样的LUT，它具有最高的优先权，并优先于任何ICC profile，以及与色调映射和输出比色有关的选项（ ``--target-prim``, ``--target-trc`` 等）。

``--blend-subtitles=<yes|video|no>``
    在插值和/或色彩管理之前，将字幕直接混合到放大后的视频帧上（默认： no）。启用这个功能会使字幕受到 ``--icc-profile``, ``--target-prim``, ``--target-trc``, ``--interpolation``, ``--gamma-factor`` 和 ``--glsl-shaders`` 的影响。当使用 ``--interpolation`` 时，它还能提高字幕的性能。

    启用这个功能的缺点是它将字幕限制在视频的可见部分，所以（例如）你不能让字幕存在于视频下面的黑边上。

    如果选择 ``video`` ，行为类似于 ``yes`` ，但字幕是以视频的原始分辨率绘制的，并随着视频的缩放而缩放。

    .. warning:: 这改变了处理字幕颜色的方式。通常情况下，字幕的颜色被假定为sRGB，并按此进行色彩管理。启用这个选项后，它们将被视为在视频的色彩空间中。如果你想让softsubbed ASS signs与视频颜色相匹配，这样做很好，但可能会导致SRT字幕或类似的东西看起来有点不对劲。

``--alpha=<blend-tiles|blend|yes|no>``
    决定在输入有alpha成分的情况下如何处理。

    blend-tiles
        在16x16的灰色/白色tiles背景下混合帧（默认）
    blend
        将帧与背景颜色（ ``--background`` ，通常是黑色）混合
    yes
        尝试创建一个有alpha成分的帧缓冲区。这只有在视频包含alpha信息时才有意义（这极为罕见），或者你让背景颜色透明。可能不是所有平台都支持。如果alpha帧缓冲器不可用，它就会默默地回到正常的帧缓冲器上。注意，如果你把 ``--fbo-format`` 选项设置为非默认值，必须指定一个带alpha的格式，否则这将无法工作。这是否真的有效，取决于窗口系统和桌面环境
    no
        忽略alpha成分

``--opengl-rectangle-textures``
    强制使用矩形纹理（默认： no）。通常情况下，这不应该比普通纹理有任何优势。请注意，硬件解码会覆盖这个标志。可能在任何时候被移除。

``--background=<color>``
    用来绘制mpv窗口中没有被视频覆盖的部分的颜色。参见 ``--sub-color`` 选项关于如何定义颜色。

``--gpu-tex-pad-x``, ``--gpu-tex-pad-y``
    将视频源的纹理放大的像素量。仅用于调试（通常纹理的大小是准确的，但由于硬件解码的interop，我们可能需要用额外的填充interop ，这可以用这些选项来测试）。可能在任何时候被移除。

``--opengl-early-flush=<yes|no|auto>``
    在渲染完一帧后，在试图显示之前调用 ``glFlush()`` （默认： auto）。在某些情况下可以解决卡顿问题，在其它情况下可能会导致卡顿。 ``auto`` 模式只有在渲染器在渲染后要等待一段时间时才会调用 ``glFlush()`` ，而不是立即翻转GL前后缓冲区（也就是说，在显示同步模式下不会调用）。

    在macOS上，这个功能始终被停用，因为它只会导致性能问题和其它倒退。

``--gpu-dumb-mode=<yes|no|auto>``
    这种模式是非常受限制的，并将禁用大多数扩展功能。这包括高质量的缩放器和自定义着色器！

    它适用于不支持FBOs的硬件（包括GLES，它对FBOs的支持不足），或者从坏的或旧的硬件中获得更高的性能。

    如果有需要的话，这个模式会自动强制执行，这个选项在调试时非常有用。如果没有使用需要FBO的功能，默认的 ``auto`` 会自动启用它。

    这个选项在未来可能会被默默移除。

``--gpu-shader-cache``
    是否存储和加载已编译的GLSL着色器。通常情况下，着色器的编译速度非常快，所以一般不需要这样做。对于需要在内部重新编译着色器到其他语言的GPU API来说，这一点非常重要，例如任何基于ANGLE或Vulkan的语言。启用它可以提高这些平台的启动性能。

    注意：这不是自动清理的，所以旧的、未使用的缓存文件可能会无限期的存在。

``--gpu-shader-cache-dir``
    存储gpu着色器缓存的目录。如果未设置，缓存将被存储在系统的缓存目录（通常是 ``~/.cache/mpv`` ）。

杂项
----

``--display-tags=tag1,tags2,...``
    设置应在终端上显示的标签列表。列表中但播放文件中不存在的标签将不会显示。如果一个值以 ``*`` 结尾，所有的标签都按前缀匹配（尽管没有通用的globbing）。仅仅传递 ``*`` 本质上是过滤。

    默认包括一个通用的标签列表，用 ``--list-options`` 调用mpv来查看它。

    这是一个字符串列表选项。详见 `列表选项`_

``--mc=<seconds/frame>``
    每一帧的最大A-V同步修正（以秒为单位）

``--autosync=<factor>``
    根据音频延迟测量结果逐渐调整A/V同步。指定 ``--autosync=0`` ，默认情况下，将导致帧计时完全基于音频延迟测量。指定 ``--autosync=1`` 将做同样的事情，但会巧妙地改变A/V修正算法。如果在 ``--no-audio`` 的情况下视频帧数不均匀，通常可以通过将其设置为大于1的整数来解决。该值越高，计时就越接近 ``--no-audio`` 。尝试 ``--autosync=30`` 以平滑那些没有实现完美音频延迟测量的声音驱动的问题。有了这个值，如果发生大的A/V同步偏移，它们只需要1或2秒就可以解决。这种对突然的A/V偏移的反应时间的延迟应该是打开这个选项的唯一副作用，对所有的声音驱动都是如此。

``--video-timing-offset=<seconds>``
    控制在视频显示目标时间之前多久应该渲染该帧（默认： 0.050）。如果一个视频帧应该在某个时间显示，视频输出驱动将提前开始渲染该帧，然后将执行一个阻塞等待，直到显示时间，然后才“交换”该帧进行显示。渲染不能在前一帧显示之前开始，所以该值隐含受到视频帧率的限制。在正常的视频帧率下，默认值将确保渲染始终在前一帧显示完后立即开始。另一方面，设置一个太高的值会减少低FPS值的响应速度。

    这个选项对于使用渲染API的client API用户来说很有意思，因为你可以阻止它限制你的FPS（参见 ``mpv_render_context_render()`` 文档）。

    这只应用于音频计时模式（例如 ``--video-sync=audio`` ）。在其它模式下（ ``--video-sync=display-...`` ），视频计时依赖于垂直同步阻塞，不使用此选项。

``--video-sync=<audio|...>``
    播放器如何使音频和视频同步。

    如果你使用这个选项，你通常想把它设置为 ``display-resample`` 以启用一种计时模式，例如在24Hz的屏幕上播放24fps的视频时尽量不跳帧或重复。

    以 ``display-`` 开头的模式尝试完全同步输出视频帧到显示上，使用检测到的显示器垂直刷新率作为提示，显示帧的平均速度。这些模式会稍微改变视频速度以匹配显示。参见 ``--video-sync-...`` 选项进行微调。这种模式的稳健性因做了一些理想化的假设而进一步降低，这些假设在现实中可能并不总是适用。行为可能取决于视频输出驱动和系统的视频和音频驱动。媒体文件必须使用恒定的帧速率。片段式的VFR可能对某些容器格式也有效（但如mkv无效）。

    在某些情况下，播放器会在一段时间内自动恢复到 ``audio`` 模式或永久地恢复。这可能发生在帧率很低的视频上，或者帧率无法被检测到。

    同样在显示同步模式下，视频播放的打断（比如切换全屏模式，或者简单地调整窗口大小）会跳过本应显示的视频帧，而 ``audio`` 模式会在渲染器恢复后显示它们（通常会导致短暂的A/V不同步和视频的“追赶”）。

    在mpv0.30.0之前，在严重的A/V不同步时会回退到 ``audio`` 模式。这已被改变，因为它不会零星地停止。现在， ``display-desync`` 做了它所承诺的事情，并可能以任意的数量与音频不同步，直到它通过跳转被手动修复。

    这些模式也需要一个垂直同步阻塞的呈现模式。对于OpenGL来说，这被翻译成 ``--opengl-swapinterval=1`` 。对于Vulkan，它被翻译成 ``--vulkan-swap-mode=fifo`` （或 ``fifo-relaxed`` ）。

    名称中带有 ``desync`` 的模式并不试图保持音频/视频的同步。它们会缓慢（或快速）地取消同步，直到例如下一次跳转发生。这些模式是用来测试的，而非用于认真使用。

    :audio:                   将视频帧计时到音频。这是最稳健的模式，因为播放器不需要对显示器的行为进行任何假设。缺点是它可能会导致偶尔的丢帧或重复。如果音频被禁用，这将使用系统时钟。这是默认模式。
    :display-resample:        对音频重新采样以匹配视频。这种模式也将尝试调整音频速度来补偿其它漂移（这表示它将每隔一段时间以不同的速度播放音频，以减少A/V差异）。
    :display-resample-vdrop:  重新采样音频以匹配视频。丢弃视频帧以补偿漂移。
    :display-resample-desync: 与之前的模式一样，但没有A/V补偿。
    :display-tempo:           类似于 ``display-resample`` ，但是将音频速度变化应用到音频滤镜而不是重采样，以避免音调的变化。注意，一些音频滤镜在速度接近1时表现不佳。建议使用一个附带条件的自动配置预设，当速度过于接近1时，自动切换到 ``display-resample`` ，以适应你的滤镜设定。使用 (speed * video_speed_correction) 来获得该条件下的实际播放速度。详见 `附带条件的自动配置预设`_
    :display-vdrop:           丢弃或重复视频帧，以补偿不同步的视频（虽然它应该有与 ``audio`` 相同的效果，但实现却非常不同）。
    :display-adrop:           丢弃或重复音频数据以补偿不同步的视频。如果真实的显示器刷新率与报告的或强制的刷新率相差太大，这种模式将引起严重的音频瑕疵。从mpv0.33.0开始，这个模式作用于整全部音频帧，而不是单个采样。
    :display-desync:          同步视频到显示，并让音频自行播放。
    :desync:                  同步视频到系统时钟，并让音频自行播放。

``--video-sync-max-factor=<value>``
    尝试将视频的FPS与显示的FPS相匹配的最大倍数（默认： 5）。

    例如，如果设置为1，只要速度变化不超过 ``--video-sync-max-video-change`` 设置的值，视频的FPS就会被强制为显示FPS的整数倍。

    关于该选项如何影响插值，请参见 ``--interpolation-threshold``

``--video-sync-max-video-change=<value>``
    应用于 ``--video-sync=display-...`` 的视频的最大速度差，以百分比为单位（默认： 1）。如果显示器和视频刷新方式在给定范围内不匹配，显示同步模式将被禁用。它还会尝试倍数：在60赫兹的屏幕上播放30帧的视频，每隔一帧就会重复一次。在60赫兹的屏幕上播放24帧的视频将以2-3-2-3-...的模式播放视频。

    默认设置不够宽松，无法将23.976帧的视频加速到25帧。我们认为音调变化过于极端，默认情况下不允许这种行为。将这个选项设置为 ``5`` 的值来启用它。

    注意， ``--video-sync=display-tempo`` 可避免这种音调的变化。

    另注意，在 ``--video-sync=display-resample`` 或 ``--video-sync=display-tempo`` 模式下，如果需要A/V同步，音频速度将额外被改变一点。参见 ``--video-sync-max-audio-change``

``--video-sync-max-audio-change=<value>``
    在 ``--video-sync=display-...`` 的情况下，应用于音频的最大 *附加* 速度差，以百分比为单位（默认： 0.125）。通常情况下，播放器会以视频的速度播放音频。但如果音频和视频的位置差异太大，例如，由于漂移或其它计时错误，它将试图通过这个额外的系数来加快或减慢音频的速度。如果A/V不同步不能得到补偿，那么太低的值可能会导致视频丢帧或重复，太高的值可能会导致混乱的丢帧，原因是音频“过冲”和在同步逻辑能反应之前跳过多个视频帧。

``--mf-fps=<value>``
    当用 ``mf://`` 从多个PNG或JPEG文件解码时使用的帧速率（默认： 1）。

``--mf-type=<value>``
    ``mf://`` 的输入文件类型（可用：jpeg, png, tga, sgi）。默认情况下，这是从文件扩展名猜测出来的。

``--stream-dump=<destination-filename>``
    读取文件的字节流并将其写入给定的目标文件，而不是播放。目标文件被覆盖。对测试网络相关的行为可能很有用。

``--stream-lavf-o=opt1=value1,opt2=value2,...``
    在用libavformat打开的流上设置AVOptions。未知或拼写错误的选项会被默默地忽略。（它们会在终端输出的verbose模式下被提及，即 ``--v`` 。一般而言，我们因为其它的选项，比如用户代理并不是所有的协议都可以使用的，不能输出错误 ，而输出未知选项的错误最终会显得过于嘈杂。）

    这是一个按键/值列表选项。详见 `列表选项`_

``--vo-mmcss-profile=<name>``
    （Windows独占）为视频渲染器线程设置MMCSS profile（默认： ``Playback`` ）。

``--priority=<prio>``
    （Windows独占）根据Windows下的预定义优先级，设置mpv进程的优先级。

    ``<prio>`` 的可能值： idle|belownormal|normal|abovenormal|high|realtime

    .. warning:: 使用realtime优先级会导致系统锁死。

``--force-media-title=<string>``
    强制将 ``media-title`` 属性的内容变成这个值。对于想要设置标题的脚本很有用，而不需要覆盖用户在 ``--title`` 中的设置。

``--external-files=<file-list>``
    加载一个文件并添加其所有的轨道。这对一起播放不同的文件很有用（例如来自一个文件的音频与来自另一个文件的视频），或用于高级的 ``--lavfi-complex`` （就像同时播放两个视频文件）。

    与 ``--sub-files`` 和 ``--audio-files`` 不同，它包括所有轨道，不会导致默认流选择在“正确的”文件上。这使得它稍微不那么具有侵入性。（在mpv0.28.0及以前，这一点并没有严格执行。）

    这是一个路径列表选项。详见 `列表选项`_

``--external-file=<file>``
    CLI/设置文件中的 ``--external-files-append`` 的专用别名。每次使用该选项将添加一个新的外部文件。

``--cover-art-files=<file-list>``
    在播放音频时使用一个外部文件作为封面图。这使得它出现在轨道列表上，并受制于自动轨道选择。像 ``--audio-display`` 这样的选项控制是否应该选择这样的轨道。

    （与用 ``--external-files`` 加载文件的区别是，视频轨将被标记为图片，这影响了自动选择的方式。如果传递的文件是视频，只有第一帧会被解码和显示。如果源文件是视频，在播放过程中启用封面图轨道可能会显示一个随机帧。通常情况下，你不应该把视频传递给这个选项，因此本段描述了由实现细节巧合导致的行为。）

    这是一个路径列表选项。详见 `列表选项`_

``--cover-art-file=<file>``
    CLI/设置文件中的 ``--cover-art-files-append`` 的专用别名。每次使用该选项将添加一个新的外部文件。

``--cover-art-auto=<no|exact|fuzzy|all>``
    是否自动加载 _外部的_ 封面图。类似于 ``--sub-auto`` 和 ``--audio-file-auto`` 。如果一个视频已经有轨道（没有标记为封面），外部封面将不会被加载。

    :no:    不自动加载封面图
    :exact: 加载带有图像文件扩展名的媒体文件（默认）
    :fuzzy: 加载所有包含媒体文件名的封面图
    :all:   加载当前目录下的所有图像

    详见 ``--cover-art-files`` 了解封面图的组成。

    参见 ``--audio-display`` 关于如何控制封面图的显示（这可用来禁用属于文件一部分的封面图）。

``--cover-art-whitelist=<no|yes>``
    是否加载内部白名单中的文件名，比如 ``cover.jpg`` 作为封面图。如果 ``cover-art-auto`` 被设置为 ``no`` ，即使这个选项被设置为 ``yes`` ，白名单上的文件名也不会被加载。

    默认： ``yes``

``--autoload-files=<yes|no>``
    自动加载/选择外部文件（默认： yes）。

    如果设置为 ``no`` ，则不自动加载由 ``--sub-auto`` , ``--audio-file-auto`` 和 ``--cover-art-auto`` 指定的外部文件。如果外部文件被强制添加（如 ``--sub-files`` ），它们将不会被自动选择。

    这不影响播放列表的扩展、重定向或其它参考文件的加载，比如有序章节。

``--record-file=<file>``
    已过时，使用 ``--stream-record`` ，或 ``dump-cache`` 命令。

    记录当前流到给定的目标文件。目标文件将总是被覆盖而不询问。

    这因为它不是很好用而过时。首先，在启用这个功能时，跳转会直接反映在输出中，这无用且烦人。

``--stream-record=<file>``
    将从解复用器接收/读取的数据写入给定的输出文件。输出文件将总是被覆盖而不询问。输出格式由输出文件的扩展名决定。

    在录制过程中切换数据流或跳转可能会导致录制被停止和/或文件被破坏。请小心使用。

    在解复用器缓存之外跳转会导致输出文件的“跳跃”，但在解复用器缓存内跳转应该不会影响录制。一个例外是，当你向前跳转到足够远的距离，超过了前向缓冲区的大小，在这种情况下，缓冲区停止主动读取。如果是实时流，这将导致数据丢失。

    如果这是在运行时设置的，则旧文件被关闭，而新文件被打开。注意，这将只在缓存末尾写入附加的数据，已经缓存的数据不能被写入。你可以尝试使用 ``dump-cache`` 命令作为替代。

    外部文件（ ``--audio-file`` 等）会被忽略，它只对“主”文件起作用。对使用有序章节的文件或EDL文件使用这个命令，一般而言也不能正确工作。

    因为它使用FFmpeg的libavformat来写入输出文件，所以会有一些小问题。例如，典型的情况是，只有当输出格式与输入格式相同时，它才能工作。即使使用 ``ffmpeg`` 工具也是这种情况。其中一个原因是 ``ffmpeg`` 和它的库包含了某些针对这些问题的hacks和变通方法，外部用户无法使用。

    这取代了 ``--record-file`` 。它类似于古老的/被移除的 ``--stream-capture`` / ``--capture`` 选项，并在大多数情况下提供更好的行为（例如实际工作）。

``--lavfi-complex=<string>``
    设置一个“复合的”libavfilter滤镜，这表示单个graph滤镜可以接受来自多个音视频源轨道的输入。该graph可以产生单一的音频或视频输出（或两者）。

    目前，该graph滤镜的标签被用来选择参与的输入轨道和音频/视频输出。以下规则适用：

    - 一个形式为 ``aidN`` 的标签选择音频轨道N作为输入（例如 ``aid1`` ）
    - 一个形式为 ``vidN`` 的标签选择视频轨道N作为输入
    - 一个名为 ``ao`` 的标签将被连接到音频输出
    - 一个名为 ``vo`` 的标签将被连接到视频输出

    每个标签只能使用一次。如果你想把例如一个音频流用于多个滤镜，你需要使用 ``asplit`` 滤镜。多个视频或音频输出是不可能的，但你可以使用滤镜将它们合并成一个。

    在运行时不可能改变连接到滤镜的轨道，除非你明确改变 ``lavfi-complex`` 属性并设置新的轨道分配。当graph被改变时，轨道的选择也会根据使用的标签而改变。

    其它的轨道，只要它们没有连接到滤镜，且相应的输出也没有连接到滤镜，仍然可以用正常的方法自由改变。

    请注意，正常的滤镜链（ ``--af`` , ``--vf`` ）是应用在复合graphs（如 ``ao`` 标签）和实际输出之间。

    .. admonition:: 示例

        - ``--lavfi-complex='[aid1] [aid2] amix [ao]'`` 同时播放轨道1和2。
        - ``--lavfi-complex='[vid1] [vid2] vstack [vo]'`` 堆叠视频轨1和2并同时播放它们。注意，两个轨道需要有相同的宽度，否则滤镜初始化会失败（你可以在 ``vstack`` 滤镜之前添加 ``scale`` 滤镜来修正尺寸）。为了从其它文件加载视频轨道，你可以使用 ``--external-file=other.mkv``
        - ``--lavfi-complex='[aid1] asplit [t1] [ao] ; [t1] showvolume [t2] ; [vid1] [t2] overlay [vo]'`` 播放音轨1，并将每个扬声器的测量音量覆盖在视频轨1上。
        - ``null:// --lavfi-complex='life [vo]'`` 一个libavfilter的源独占滤镜（Conways' Life Game）。

    关于可用的滤镜，详见FFmpeg libavfilter文档。

``--metadata-codepage=<codepage>``
    各种输入元数据的代码页（默认： ``utf-8`` ）。这影响到文件标记、章节标题等的解析。例如，你可以把它设置为 ``auto`` 来启用代码页的自动检测。（这不是默认的，因为非UTF-8代码页是一种不明显的边缘使用情况。）

    参见 ``--sub-codepage`` 选项，关于如何指定代码页以及关于自动检测和代码页转换的进一步细节。（底层代码相同）

    转换不应用于在运行时更新的元数据。
