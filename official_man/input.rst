COMMAND INTERFACE
=================

mpv核心可以用命令和属性来控制。一些与播放器互动的方式使用它们：按键绑定（ ``input.conf`` ），OSD（用属性显示信息），JSON IPC，客户端API（ ``libmpv`` ），以及经典的从属模式。

input.conf
----------

input.conf文件由一个键绑定的列表组成，例如::

    s screenshot      # 用s键进行屏幕截图
    LEFT seek 15      # 将左箭头键映射为向前寻求15秒的时间

每一行将一个键映射到一个输入命令。键被指定为其字面价值（如果与 ``Shift`` 结合，则为大写），或者为特殊键指定一个名称。例如， ``a`` 映射到 ``a`` 键，不需要shift，而 ``A`` 映射到 ``a`` 键，需要shift。

该文件位于mpv配置目录下（通常在 ``~/.config/mpv/input.conf`` ，取决于平台）。默认的绑定在这里定义::

    https://github.com/mpv-player/mpv/blob/master/etc/input.conf

特殊键的列表可以通过以下方式获得

    ``mpv --input-keylist``

一般来说，按键可以与 ``Shift`` ``Ctrl`` ``Alt`` 组合::

    ctrl+q quit

**mpv** 可以在输入测试模式下启动，在OSD上显示键的绑定和它们所绑定的命令，而不是执行命令::

    mpv --input-test --force-window --idle

(只有关闭窗口才能使 **mpv** 退出，按普通的键只是显示绑定的命令，即使被映射为退出。)

也请看 `Key names`_

input.conf syntax
-----------------

``[Shift+][Ctrl+][Alt+][Meta+]<key> [{<section>}] <command> ( ; <command> )*``

注意，默认情况下，右键Alt可以用来创建特殊字符，因此不会注册为修改器。选项 ``--no-input-right-alt-gr`` 可以改变这一行为。

换行线总是开始一个新的绑定。 ``#`` 开始一个注释（在有引号的字符串参数之外）。为了将命令与 ``#`` 键绑定，可以使用 ``SHARP``

``<key>`` 是该键产生的字面字符（ASCII或Unicode字符），或者是一个符号名称（如由 ``--input-keylist`` 输出）。

``<section>`` （用 ``{`` 和 ``}`` 括起来）是这个命令的输入部分。

``<command>`` 是命令本身。它由命令名和多个（或没有）参数组成，所有参数都用空格隔开。字符串参数应加引号，一般用 ``"`` 。参见  ``Flat command syntax``

你可以将多个命令绑定到一个键上。例如：

| a show-text "command 1" ; show-text "command 2"

也可以将一个命令与一连串的键绑定：

| a-b-c show-text "command run after a, b, c have been pressed"

(这在一般的命令语法中没有显示)。

如果 ``a`` 或 ``a-b`` 或 ``b`` 已经被绑定，这将运行第一个匹配的命令，而多键命令将不会被调用。为了避免这个问题，可以将中间键重映射到 ``ignore`` 。组合键的最大数量（非修改器）目前是4。

Key names
---------

所有的鼠标和键盘输入都要转换为mpv特定的键名。键名要么是代表物理键的特殊符号标识，要么是文本键名，它是UTF-8编码的unicode码点。这些都是键盘输入通常会产生的，例如， ``a`` 代表A键。因此，mpv使用由当前操作系统键盘布局翻译的输入，而不是物理扫描代码。

目前有一个硬编码的假设，即每个文本键都可以表示为一个单一的unicode码点（NFKC形式）。

所有的键名都可以与修饰符 ``Shift``, ``Ctrl``, ``Alt``, ``Meta`` 结合。它们必须以实际的键名为前缀，每个修饰语后面都有一个 ``+`` （例如 ``ctrl+q`` ）。

``Shift`` 修饰符需要注意一下。例如， ``Shift+2`` 通常应该在 ``input.conf`` 中指定为键名 ``@`` ，同样， ``Alt+Shift+2`` 的组合通常为 ``Alt+@`` ，等等。特殊的键名，如 ``Shift+LEFT`` ，也能如期工作。如果有疑问--使用 ``--input-test`` 来检查mpv是如何看待一个键/组合的。

符号键名和修改器名称不区分大小写。Unicode键名是区分大小写的，因为输入绑定通常尊重shift键。

另一种类型的键名是十六进制键名，作为特殊键的后备键，既不是unicode，也没有特殊的mpv定义的名称。一旦mpv为它们添加了合适的名字，它们就会失效，但如果不这样做，你就可以使用一个键。

所有的符号名称都是由 ``--input-keylist`` 列出的。 ``--input-test`` 是一个特殊的模式，在OSD上打印出所有的输入。

对一些符号名称的注释：

``KP*``
    小键盘名称。行为因后端而异（是否实现，以及如何处理numlock），但通常情况下，mpv试图将键盘上的键映射到独立的名称，即使它们产生与普通键相同的文本。

``MOUSE_BTN*``, ``MBTN*``
    各种鼠标按钮。

    根据后端，鼠标滚轮也可能被表示为一个按钮。此外， ``MOUSE_BTN3`` 到 ``MOUSE_BTN6`` 是 ``WHEEL_UP``, ``WHEEL_DOWN``, ``WHEEL_LEFT``, ``WHEEL_RIGHT`` 的deprecated别名。

    ``MBTN*`` 是 ``MOUSE_BTN*`` 的别名。

``WHEEL_*``
    鼠标滚轮（通常）。

``AXIS_*``
    ``WHEEL_*`` 的别名，已Deprecated

``*_DBL``
    鼠标按键双击。

``MOUSE_MOVE``, ``MOUSE_ENTER``, ``MOUSE_LEAVE``
    由鼠标移动事件发出。当鼠标进入或离开mpv窗口（或当前鼠标区域，使用已deprecated的鼠标区域输入部分机制）时ENTER/LEAVE发生。

``CLOSE_WIN``
    当使用操作系统窗口管理器关闭mpv窗口时发出的伪键（例如，通过点击窗口标题栏的关闭按钮）。

``GAMEPAD_*``
    由SDL游戏手柄后端发出的键。

``UNMAPPED``
    匹配任何未映射的键的伪键。(如果可能的话，你应该避免这样做，因为它可能改变行为或在将来被删除)。

``ANY_UNICODE``
    匹配任何产生文本的键的伪键。(如果可能的话，你应该避免这样做，因为它可能会改变行为或在将来被删除。)

Flat command syntax
-------------------

这是在input.conf中使用的语法，并在其他一些地方被称为 "input.conf syntax"

|
| ``<command>  ::= [<prefixes>] <command_name> (<argument>)*``
| ``<argument> ::= (<unquoted> | " <double_quoted> " | ' <single_quoted> ' | `X <custom_quoted> X`)``

``command_name`` 是一个未加引号的字符串，包含命令名称本身。列表见 `List of Input Commands`_

参数之间用空格隔开，即使命令只期望有一个参数。带有空格或其他特殊字符的参数必须加引号，否则命令不能被正确解析。

双引号解释JSON/C风格的转义，如 ``\t`` 或 ``\"`` 或 ``\\`` 。JSON根据RFC 8259进行转义，减去代理对转义。这是唯一一种允许在值上加换行的形式--如 ``\n``

单引号从字面上理解内容，并且不能在值中包含单引号字符。

自定义引号也是按字面意思理解内容，但比单引号更灵活。它们以 ````` （反引号）开始，后面是任何ASCII字符，并以同一对的第一次出现为结束，顺序相反，例如： ```-foo-``` 或 ````bar```` 。最后一对序列的值不允许出现--在这些例子中分别是 ``-``` 和 `````` 。在第二个例子中，值的最后一个字符也不能是反引号。

同一个参数的混合引号，如 ``'foo'"bar"`` ，不被支持。

请注意，参数解析和属性扩展发生在不同的阶段。首先，参数如上所述被确定，然后，如果适用的话，属性被扩展--不管参数的引号是什么。然而，仍然可以用 ``raw`` 前缀或 ``$>`` 防止扩展。参见 `Input Command Prefixes`_ 和 `Property Expansion`_

Commands specified as arrays
----------------------------

这适用于某些API，例如Lua脚本中的 ``mp.commandv()`` 或 ``mp.command_native()`` （带数组参数），或C语言libmpv客户端API中的 ``mpv_command()`` 或 ``mpv_command_node()`` （带MPV_FORMAT_NODE_ARRAY）。

命令以及所有的参数都以一个数组的形式传递。类似于 `Flat command syntax`_ ，你可以先把前缀作为字符串传递（每个都是独立的数组项），然后把命令名称作为字符串，然后把每个参数作为字符串或本地值。

由于这些API将参数作为独立的字符串或本地值来传递，所以它们不期望引号，并且支持转义。在技术上，有一个input.conf解析器，它首先将命令字符串分割成参数，然后为每个参数调用参数解析器。input.conf解析器通常处理引号和转义。上面提到的数组命令API直接将字符串传递给参数解析器，或者可以通过传递非字符串值的能力绕过它们。

这些API的属性扩展默认是禁用的。这可以用 ``expand-properties`` 前缀来改变。参见 `Input Command Prefixes`_

有时候，命令的参数是字符串，而这些参数实际上是由其他组件解析的（例如，用 ``vf add`` 过滤字符串）--在这些情况下，你必须在input.conf中进行双击，但在数组API中则不需要。

对于复杂的命令，可以考虑使用 `Named arguments`_ 来代替，这样会有更多的兼容性。不过有些命令不支持命名参数，而是采用数组。

Named arguments
---------------

这适用于某些API，例如Lua脚本中的 ``mp.command_native()`` （有字符串键的表），或者C语言libmpv客户端API中的 ``mpv_command_node()`` （有MPV_FORMAT_NODE_MAP）。

命令的名称是用 ``name`` 字符串字段提供的。每个命令的名称在 `List of Input Commands`_ 中的每个命令描述中都有定义。 ``--input-cmdlist`` 也列出了它们。请看 ``subprocess`` 命令的例子。

有些命令不支持命名参数（例如 ``run`` 命令）。你需要使用以数组形式传递参数的API。

命名参数在 "flat" 的input.conf语法中不被支持，这意味着你根本无法在input.conf中使用它们作为键的绑定。

对于这些API，属性扩展默认是禁用的。这可以通过 ``expand-properties`` 前缀来改变。请看 `Input Command Prefixes`_

List of Input Commands
----------------------

有参数的命令的参数名称用 ``<`` / ``>`` 括起来。不要在实际命令中加入这些参数。可选参数用 ``[`` / ``]`` 括起来。如果你不传递它们，它们将被设置为默认值。

记住在input.conf中引用字符串参数（参见 `Flat command syntax`_ ）。

``ignore``
    用它来 "block" 应该被取消绑定的键，而不做任何事情。对禁用默认绑定很有用，而不需要用 ``--no-input-default-bindings`` 禁用所有绑定。

``seek <target> [<flags>]``
    改变播放位置。默认情况下，以相对的秒数来寻找。

    第二个参数由控制寻求模式的标志组成：

    relative (默认)
        相对于当前位置寻道（一个负值向后寻道）。
    absolute
        寻址到一个给定的时间（负值从文件的末尾开始）。
    absolute-percent
        寻至一个给定的百分比位置。
    relative-percent
        相对于当前位置的百分比寻址。
    keyframes
        总是在关键帧的边界重新开始播放（快速）。
    exact
        总是做精确/小时/精确的搜索（慢）。

    多个标志可以合并，例如： ``absolute+keyframes``

    默认情况下， ``keyframes`` 用于 ``relative``, ``relative-percent`` 和 ``absolute-percent`` 的搜索，而 ``exact`` 用于 ``absolute`` 的搜索。

    在mpv 0.9之前， ``keyframes`` 和 ``exact`` 标志必须作为第3个参数传递（基本上是用空格代替 ``+``）。第3个参数仍然被解析，但被认为是deprecated

``revert-seek [<flags>]``
    撤销 ``seek`` 命令，以及其他一些寻找的命令（但不一定是所有的）。调用这个命令一次会跳到寻道前的播放位置。第二次调用它将撤销 ``revert-seek`` 命令本身。这只在一个文件中起作用。

    第一个参数是可选的，它可以改变行为：

    mark
        标记当前的时间位置。下一次正常的 ``revert-seek`` 命令将返回到这个点，不管上次之后发生了多少次搜索。
    mark-permanent
        如果设置，标记当前位置，在下一个设置了 ``mark`` 或 ``mark-permanent`` 的 ``revert-seek`` 命令之前（或当前文件的播放结束），不要改变标记位置。在这之前, ``revert-seek`` 将一直寻找到被标记的点. 这个标志不能与 ``mark`` 结合使用。

    在没有任何参数的情况下使用它可以得到默认行为。

``frame-step``
    播放一帧，然后暂停。对纯音频播放没有任何作用。

``frame-back-step``
    后退一帧，然后暂停。注意，这可能非常慢（它试图精确，而不是快速），有时不能达到预期效果。这样做的效果如何，取决于精确搜索是否正常工作（例如，见 ``--hr-seek-demuxer-offset`` 选项）。视频过滤器或其他修改帧的时间的视频后处理（例如去隔行扫描）通常应该工作，但在角落里可能会使反向步进默默地表现得不正确。使用 ``--hr-seek-framedrop=no`` 应该会有帮助，尽管它可能会使精确搜索变慢。

    这在纯音频播放中不起作用。

``set <name> <value>``
    将给定的属性或选项设置为给定的值。

``add <name> [<value>]``
    向属性或选项添加给定的值。在溢出或下溢时，将属性夹到最大。如果省略了 ``<value>`` ，则假定为 ``1`` 。

``cycle <name> [<value>]``
    循环给定的属性或选项。第二个参数可以是 ``up`` 或 ``down`` 以设置循环方向。溢出时，将属性设回最小值，下溢时，将其设为最大值。如果省略了 ``up`` 或 ``down``  ，则假定为 ``up`` 。

    默认情况下是否启用按键重复取决于该属性。目前具有连续值的属性默认是可重复的（如 ``volume`` ），而离散值则不是（如 ``osd-level`` ）。

``multiply <name> <value>``
    类似于 ``add`` ，但将属性或选项与数值相乘。

``screenshot <flags>``
    拍摄一张屏幕截图。

    有多个标志可供选择（有些可与 ``+`` 组合）。

    <subtitles> (默认)
        保存视频图像，以其原始分辨率，并带有字幕。在某些情况下，一些视频输出可能仍然包括OSD的输出。
    <video>
        类似 ``subtitles``，但通常没有OSD或字幕。具体行为取决于所选的视频输出。
    <window>
        保存mpv窗口的内容。通常是按比例，有OSD和字幕。具体行为取决于所选的视频输出，如果没有支持，这将像 ``video`` 一样。
    <each-frame>
        每一帧拍一张屏幕。再次发出这个命令可以停止截图。注意，使用这种模式时，你应该禁用frame-dropping功能--否则在丢帧的情况下，你可能会收到重复的图像。这个标志可以和其他标志结合使用，例如 ``video+each-frame``

    旧的mpv版本需要把 ``single`` 和 ``each-frame`` 作为第二个参数传递（并且没有标志）。这种语法仍然可以被理解，但已经deprecated，将来可能会被删除。

    如果你把这个命令和另一个使用 ``;`` 的命令结合起来，你可以使用 ``async`` 标志来使编码/写入图像文件成为异步的。对于普通的独立命令，它总是异步的，这个标志没有影响。(这个行为在mpv 0.29.0中改变了。)

``screenshot-to-file <filename> <flags>``
    截图并保存到一个给定的文件。文件的格式将由扩展名来猜测（并且 ``--screenshot-format`` 被忽略--当扩展名丢失或未知时，行为是任意的）。

    第二个参数和 ``screenshot`` 的第一个参数一样，支持 ``subtitles``, ``video``, ``window``

    如果文件已经存在，它将被覆盖。

    像所有的输入命令参数一样，文件名要进行属性扩展，如 `Property Expansion`_ 中所述。

``playlist-next <flags>``
    转到播放列表的下一个条目。

    第一个参数：

    weak (默认)
        如果当前正在播放播放列表上的最后一个文件，则不做任何事情。
    force
        如果播放列表上没有更多的文件，就终止播放。

``playlist-prev <flags>``
    转到播放列表上的前一个条目。

    第一个参数：

    weak (默认)
        如果当前正在播放播放列表上的第一个文件，不做任何事情。
    force
        如果第一个文件正在播放，终止播放。

``playlist-play-index <integer|current|none>``
    开始（或重新开始）播放给定的播放列表索引。除了基于0的播放列表条目索引外，它还支持以下数值：

    <current>
        当前的播放列表条目（如 ``playlist-current-pos`` ）将被再次播放（卸载和重新加载）。如果没有设置，播放就会停止。(在角落里， ``playlist-current-pos`` 可以指向一个播放列表条目，即使当前的播放处于非活动状态。

    <none>
        播放被停止。如果空闲模式（ ``--idle`` ）被启用，播放器将进入空闲模式，否则将退出。

    这个comm和 ``loadfile`` 类似，它只操作下一个播放的状态，而不等待当前文件被卸载，下一个文件被加载。

    设置 ``playlist-pos`` 或类似的属性可以产生与此命令类似的效果。然而，它更明确，并保证重启播放，例如，新的播放列表条目与前一个相同。

``loadfile <url> [<flags> [<options>]]``
    加载给定的文件或URL并播放它。从技术上讲，这只是一个播放列表操作命令（它要么替换播放列表，要么给它添加一个条目）。实际的文件加载是独立发生的。例如，一个用新文件替换当前文件的 ``loadfile`` 命令会在当前文件停止之前返回，而新文件甚至开始加载。

    第二个参数：

    <replace> (默认)
        停止播放当前文件，并立即播放新文件。
    <append>
        将文件追加到播放列表中。
    <append-play>
        添加文件，如果当前没有播放，则开始播放。(总是从添加的文件开始，即使在运行这个命令之前，播放列表不是空的)。

    第三个参数是一个选项和值的列表，应该在文件播放时设置。它的形式是 ``opt1=value1,opt2=value2,..`` 。当使用客户端API时，这可以是一个 ``MPV_FORMAT_NODE_MAP`` （或一个Lua表），但目前值本身必须是字符串。这些选项在播放过程中设置，并在播放结束时恢复到之前的值（见 `Per-File Options`_ ）。

``loadlist <url> [<flags>]``
    加载给定的播放列表文件或URL（像 ``--playlist`` ）。

    第二个参数：

    <replace> (默认)
        停止播放，用新的播放列表替换内部的播放列表。
    <append>
        在当前内部播放列表的末尾追加新的播放列表。
    <append-play>
        追加新的播放列表，如果当前没有播放，则开始播放。(总是从新的播放列表开始，即使内部播放列表在运行这个命令之前不是空的。)

``playlist-clear``
    清除播放列表，除了当前播放的文件。

``playlist-remove <index>``
    删除指定索引的播放列表条目。索引值从0开始计算。 特殊值 ``current`` 删除当前条目。注意，删除当前条目也会停止播放并开始播放下一个条目。

``playlist-move <index1> <index2>``
    (矛盾的是，如果index1低于index2，移动后的播放列表条目将没有index2的索引值，因为index2指的是目标条目，而不是该条目移动后的索引。)

``playlist-shuffle``
    对播放列表进行洗牌。这与使用 ``--shuffle`` 选项时启动时的情况类似。

``playlist-unshuffle``
    试图恢复之前的 ``playlist-shuffle`` 命令。这只起一次作用（多个连续的 ``playlist-unshuffle`` 命令不起作用）。如果在 ``playlist-shuffle`` 命令之后，有新的递归播放列表被打开，可能无法正常工作。

``run <command> [<arg1> [<arg2> [...]]]``
    运行给定的命令。与MPlayer/mplayer2和mpv的早期版本（0.2.x和更早的版本）不同，这不会调用shell。相反，命令被直接运行，每个参数单独传递。每个参数都像 `Property Expansion`_ 中那样被扩展。

    这个命令的参数数量是可变的，不能与命名的参数一起使用。

    程序以分离的方式运行，mpv不等待命令的完成，而是在催生后立即继续播放。

    要获得旧的行为，使用 ``/bin/sh`` 和 ``-c`` 作为前两个参数。

    .. admonition:: 示例

        ``run "/bin/sh" "-c" "echo ${title} > /tmp/playing"``

        这不是一个特别好的例子，因为它没有处理转义，而一个特别准备的文件可能允许攻击者执行任意的shell命令。建议写一个小的shell脚本，然后用 ``run`` 来调用。

``subprocess``
    类似于 ``run`` ，但给调用者更多关于进程执行的控制权，并且不分离进程。

    你可以通过异步运行这个命令来避免阻塞，直到进程终止。(例如Lua脚本中的 ``mp.command_native_async()`` 。)

    这个命令有以下命名的参数。它们的顺序是不保证的，所以你应该总是用命名的参数来调用它们，见 `Named arguments`_

    ``args`` (``MPV_FORMAT_NODE_ARRAY[MPV_FORMAT_STRING]``)
        字符串的数组，命令是第一个参数，后面是后续的命令行参数。这就像 ``run`` 命令参数列表。

        第一个数组条目是可执行文件的绝对路径，或者是没有路径成分的文件名，在这种情况下，可执行文件会在 ``PATH`` 环境变量的目录中搜索。在Unix上，这相当于 ``posix_spawnp`` 和 ``execvp`` 行为。

    ``playback_only`` (``MPV_FORMAT_FLAG``)
        布尔值，表示当播放结束时，进程是否应该被杀死（可选，默认： yes）。如果启用，停止播放将自动杀死该进程，你不能在播放之外启动它。

    ``capture_size`` (``MPV_FORMAT_INT64``)
        整数，设置可以捕获的最大stdout加stderr字节数（可选，默认： 64MB）。如果字节数超过这个数字，捕获将被停止。这个限制是针对每个捕获的流。

    ``capture_stdout`` (``MPV_FORMAT_FLAG``)
        捕获进程输出到stdout的所有数据，并在进程结束后返回（可选，默认： no）。

    ``capture_stderr`` (``MPV_FORMAT_FLAG``)
        与 ``capture_stdout`` 相同，但针对stderr。

    ``detach`` (``MPV_FORMAT_FLAG``)
        是否以分离模式运行进程（可选，默认： no）。在这种模式下，进程会在一个新的进程会话中运行，命令不会等待进程终止。如果 ``capture_stdout`` 和 ``capture_stderr`` 都没有设置为yes，命令在新进程启动后立即返回，否则，只要管道打开，命令就会读取。

    ``env`` (``MPV_FORMAT_NODE_ARRAY[MPV_FORMAT_STRING]``)
        为新进程设置一个环境变量的列表（默认： 空）。如果传递了一个空列表，则使用mpv进程的环境来代替。(与底层操作系统机制不同，mpv命令不能以空环境启动一个进程。幸运的是，那是完全无用的）。列表的格式和 ``execle()`` 系统调用一样。每个字符串项都定义了一个环境变量，如 ``NANME=VALUE``

        在Lua上，你可以使用 ``utils.get_env_list()`` 来检索当前环境，如果你只是想添加一个新的变量。

    ``stdin_data`` (``MPV_FORMAT_STRING``)
        向新进程的stdin输入给定的字符串。由于这是一个字符串，你不能传递任意的二进制数据。如果进程在所有数据写入前终止或关闭管道，剩余的数据将被默默地丢弃。可能在win32上不工作。

    ``passthrough_stdin`` (``MPV_FORMAT_FLAG``)
        如果启用，将新进程的stdin连接到mpv的stdin（默认： no）。在mpv 0.33.0之前，这个参数不存在，但其行为就像设置为 yes一样。

    该命令返回以下结果（作为 ``MPV_FORMAT_NODE_MAP`` ）。

    ``status`` (``MPV_FORMAT_INT64``)
        该进程的原始退出状态。它在出错时将是负值。负值的意义未被定义，除了意味着错误（不对应操作系统的低级别退出状态值）。

        在Windows上，即使进程优雅地退出，也可能会返回一个负的返回值，因为win32的 ``UINT`` 退出代码在被设置为结果图中的 ``int64_t`` 字段之前被分配给一个``int`` 变量。这个问题以后可能会被修复。

    ``stdout`` (``MPV_FORMAT_BYTE_ARRAY``)
        捕获的stdout流，限制在 ``capture_size``

    ``stderr`` (``MPV_FORMAT_BYTE_ARRAY``)
        与 ``stdout`` 相同，但用于stderr。

    ``error_string`` (``MPV_FORMAT_STRING``)
        如果进程优雅地退出，则为空字符串。如果进程以不寻常的方式终止，则为字符串 ``killed`` . 如果进程不能被启动，则为字符串  ``init`` 。

        在Windows系统中，只有当进程被mpv杀死时， ``killed`` 才会被返回，因为 ``playback_only`` 被设置为yes

    ``killed_by_us`` (``MPV_FORMAT_FLAG``)
        进程是否被mpv杀死，例如，由于 ``playback_only`` 被设置为true，中止命令（例如，通过 ``mp.abort_async_command()`` ），或者玩家即将退出。

    注意，只要参数正确，命令本身将总是返回成功。进程是否可以被生成，或者是否以某种方式被杀死或返回错误状态，必须从结果值中查询。

    这个命令可以通过API异步中止。

    在所有情况下，子进程将在玩家退出时被终止。也请看 `Asynchronous command details`_ 。只有 ``run`` 命令可以以真正脱离的方式启动进程。

    .. admonition:: 警告

        如果你想在播放器处于空闲状态时运行命令，或者你不想让播放结束时杀死命令，不要忘记设置 ``playback_only`` 字段。

    .. admonition:: 示例

        ::

            local r = mp.command_native({
                name = "subprocess",
                playback_only = false,
                capture_stdout = true,
                args = {"cat", "/proc/cpuinfo"},
            })
            if r.status == 0 then
                print("result: " .. r.stdout)
            end

        这是一个相当无用的Lua例子，它演示了如何以阻塞的方式运行一个进程，并检索其stdout输出。

``quit [<code>]``
    退出播放器。如果给了一个参数，它将作为进程的退出代码。

``quit-watch-later [<code>]``
    退出播放器，并存储当前的播放位置。以后播放该文件时，将寻求到开始时的前一个位置。参数（可选）与 ``quit`` 命令完全一样。

``sub-add <url> [<flags> [<title> [<lang>]]]``
    加载给定的字幕文件或字幕流。默认情况下，加载后它被选为当前字幕。

     ``flags`` 参数是以下值之一：

    <select>

        立即选择字幕（默认）。

    <auto>

        不要选择字幕。(或者在某些特殊情况下，让默认的流选择机制决定）。

    <cached>

        选择字幕。如果已经添加了一个相同文件名的字幕，则选择该字幕，而不是加载一个重复的条目。(在这种情况下，标题/语言被忽略，如果在加载后发生了变化，这些变化将不会被反映出来）。

    ``title`` 参数设置用户界面中的曲目标题。

    ``lang`` 参数设置轨道语言，如果 ``flags`` 设置为 ``auto`` ，也会影响流的选择。

``sub-remove [<id>]``
    删除给定的字幕轨。如果缺少 ``id`` 参数，则删除当前轨道。(只对外部字幕文件起作用。)

``sub-reload [<id>]``
    重新加载给定的字幕轨道。如果缺少 ``id`` 参数，则重新加载当前轨道。(只对外部字幕文件起作用。)

    这通过卸载和重新添加字幕轨道来工作。

``sub-step <skip> <flags>``
    改变字幕时间，使下一个 ``<skip>`` 字幕事件之后的字幕事件被显示。 ``<skip>`` 可以是负数，以便向后退步。

    次要参数：

    primary (默认)
        在主要的字幕中步进。
    secondary
        通过二级字幕。

``sub-seek <skip> <flags>``
    寻找下一个（skip设置为1）或上一个（skip设置为-1）字幕。这类似于 ``sub-step`` ，只是它寻找视频和音频，而不是调整字幕延迟。

    次要参数：

    primary (默认)
        通过主字幕寻找。
    secondary
        寻找二级字幕。

    对于嵌入式字幕（如Matroska），这只适用于已经显示过的字幕事件，或在一个短的预取范围内。

``print-text <text>``
    输出文本到stdout。字符串可以包含属性（见 `Property Expansion`_ ）。注意把参数放在引号里。

``show-text <text> [<duration>|-1 [<level>]]``
    在OSD上显示文本。字符串可以包含属性，如 `Property Expansion`_ 中所述。这可以用来显示播放时间、文件名，等等。

    <duration>
        显示信息的时间，单位是ms。默认情况下，它使用与 ``--osd-duration`` 相同的值。

    <level>
        显示文本的最小OSD级别（见 ``--osd-level`` ）。

``expand-text <string>``
    对参数进行属性扩展，并返回扩展后的字符串。这只能通过客户端API或使用 ``mp.command_native`` 的脚本来使用。(见 `Property Expansion`_ )。

``expand-path "<string>"``
    将一个路径的双梯形占位符扩展为一个特定平台的路径。与 ``expand-text`` 一样，这只能通过客户端API或使用 ``mp.command_native`` 的脚本来使用。

    .. admonition:: 示例

        ``mp.osd_message(mp.command_native({"expand-path", "~~home/"}))``

        这一行Lua将显示用户的mpv配置目录在OSD上的位置。

``show-progress``
    在OSD上显示进度条、经过的时间和文件的总时间。

``write-watch-later-config``
    写下 ``quit-watch-later`` 命令所写的恢复配置文件，但继续正常播放。

``delete-watch-later-config [<filename>]``
    删除任何由 ``quit-watch-later`` 或 ``write-watch-later-config`` 写入的现有恢复配置文件。如果指定了文件名，那么删除的是该文件的配置；否则，就是在当前情况下由 ``quit-watch-later`` 或 ``write-watch-later-config`` 写入的配置。

``stop [<flags>]``
    停止播放并清除播放列表。在默认设置下，这基本上就像 ``quit`` 。对客户端的API很有用：可以在不终止播放器的情况下停止播放。

    第一个参数是可选的，并支持以下标志：

    keep-playlist
        不清除播放列表。


``mouse <x> <y> [<button> [<mode>]]``
    以给定的坐标（ ``<x>``, ``<y>`` ）发送一个鼠标事件。

    第二个参数：

    <button>
        被点击的鼠标按钮的按钮号。这应该是0-19中的一个。如果 ``<button>`` 被省略，只有位置会被更新。

    第三个参数：

    <single> (默认)
        鼠标事件代表常规的单次点击。

    <double>
        鼠标事件代表双击。

``keypress <name>``
    通过mpv的输入处理程序发送一个按键事件，触发为该按键配置的任何行为。 ``name`` 使用 ``input.conf`` 的命名方案来命名键和修改器。对客户端API很有用：键事件可以被发送到libmpv内部来处理。

``keydown <name>``
    类似于 ``keypress`` ，但设置了 ``KEYDOWN`` 标志，这样，如果键被绑定到一个可重复的命令，它将随着mpv的键重复计时重复运行，直到 ``keyup`` 命令被调用。

``keyup [<name>]``
    设置 ``KEYUP`` 标志，停止任何已经触发的重复行为。 ``name`` 是可选的。如果 ``name`` 没有给出或为空字符串， ``KEYUP`` 将被设置在所有键上。否则， ``KEYUP`` 将只设置在 ``name`` 指定的键上。

``keybind <name> <command>``
    将一个键与一个输入命令绑定。 ``command`` 必须是一个完整的命令，包含所有需要的参数和标志。 ``name`` 和 ``command`` 都使用 ``input.conf`` 的命名方式。这主要是对客户端的API有用。

``audio-add <url> [<flags> [<title> [<lang>]]]``
    加载给定的音频文件。见 ``sub-add`` 命令。

``audio-remove [<id>]``
    删除给定的音轨。见 ``sub-remove`` 命令。

``audio-reload [<id>]``
    重新加载给定的音轨。参见 ``sub-reload`` 命令。

``video-add <url> [<flags> [<title> [<lang> [<albumart>]]]]``
    加载给定的视频文件。常见选项见 ``sub-add`` 命令。

    ``albumart`` (``MPV_FORMAT_FLAG``)
        如果启用，mpv将加载给定视频作为专辑封面。

``video-remove [<id>]``
    删除给定的视频轨道。见 ``sub-remove`` 命令。

``video-reload [<id>]``
    重新加载给定的视频轨道。参见 ``sub-reload`` 命令。

``rescan-external-files [<mode>]``
    根据当前的 ``--sub-auto``, ``--audio-file-auto`` 和 ``--cover-art-auto`` 设置重新扫描外部文件。这可以用来自动加载外部文件，在文件被加载 *之后* 。

    ``mode`` 参数是以下之一：

    <reselect> (默认)
        选择默认的音频和字幕流，这通常会选择具有最高优先级的外部文件。(这个实现并不完美，可以根据要求进行改进)。

    <keep-selection>
        不改变当前的音轨选择。


Input Commands that are Possibly Subject to Change
--------------------------------------------------

``af <operation> <value>``
    改变音频过滤链。参见 ``vf`` 命令。

``vf <operation> <value>``
    改变视频过滤链。

    其语义与选项解析完全相同（见 `VIDEO FILTERS`_ ）。因此，下面的文字是一个多余的、不完整的总结。

    第一个参数决定发生什么：

    <set>
        用新的过滤器链覆盖以前的过滤器链。

    <add>
        将新的过滤器链附加到前一个过滤器链上。

    <toggle>
        检查给定的过滤器（有确切的参数）是否已经在视频链中。如果是，移除该过滤器。如果不是，则添加该过滤器。(如果有几个过滤器被传递到命令中，这是为每个过滤器做的。)

        一个特殊的变体是把它和标签结合起来，用 ``@name`` 不带过滤器名称和参数的过滤器条目。这样就可以切换启用/禁用标志。

    <remove>
        像 ``toggle`` 一样，但总是从链上删除给定的过滤器。

    <del>
        从视频链中删除给定的过滤器。与其他情况不同，第二个参数是一个逗号分隔的过滤器名称或整数索引列表。 ``0`` 将表示第一个过滤器。负的索引从最后一个过滤器开始， ``-1`` 表示最后一个过滤器。已Deprecated，使用 ``remove`` 。

    <clr>
        删除所有过滤器。注意，和其他子命令一样，这并不能控制自动插入的过滤器。

    参数总是需要的。例如，如果是 ``clr`` ，使用 ``vf clr ""``

    你可以通过在过滤器前加上 ``@name:`` （其中 ``name`` 是用户选择的任意标识符）为过滤器指定标签。标签可以用来在所有的过滤器链修改命令中用名字来指代过滤器。对于 ``add`` 来说，使用一个已经使用过的标签将取代现有的过滤器。

    ``vf`` 命令在修改滤波链后在OSD上显示所请求的滤波列表。这大致相当于 ``show-text ${vf}`` 。注意，用于格式转换的自动插入的过滤器不显示在列表中，只显示用户请求的内容。

    通常情况下，命令会检查视频链是否重新创建成功，失败时将撤销操作。如果命令在视频配置之前运行（如果命令在打开文件后，在视频帧被解码之前立即运行，就可能发生），这个检查就不能运行。那么就可能发生创建视频链失败的情况。

    .. admonition:: input.conf的示例

        - ``a vf set vflip`` ``a`` 键把视频倒过来
        - ``b vf set ""`` ``b`` 键删除上的所有视频过滤器
        - ``c vf toggle gradfun`` ``c`` 键上切换debanding。

    .. admonition:: 如何在运行时切换禁用的过滤器的示例

        - 在 ``mpv.conf`` 中加入类似 ``vf-add=@deband:!gradfun`` 的内容。 ``@deband:`` 是标签，是用户为这个过滤器条目任意起的名字。过滤器名称前的 ``!`` 默认情况下禁用该过滤器。之后的内容是正常的过滤器名称和可能的过滤器参数，就像正常的 ``--vf`` 语法。
        - 在 ``input.conf`` 中添加 ``a vf toggle @deband`` 。当按下 ``a`` 键时，这将切换标签为 ``deband`` 的过滤器的 "disable" 标志。

``cycle-values [<"!reverse">] <property> <value1> [<value2> [...]]``
    循环浏览一个值的列表。每次调用该命令将把给定的属性设置为列表中的下一个值。该命令将使用属性/选项的当前值，并利用它来确定当前在值列表中的位置。一旦找到它，它将设置列表中的下一个值（如果需要的话，将绕到第一个项目）。

    这个命令的参数数量不定，不能与命名参数一起使用。

    特殊参数 ``!reverse`` 可以用来反向循环数值列表。唯一的好处是，在添加第二个键绑定的时候，你不需要自己反转值列表进行循环。

``enable-section <name> [<flags>]``
    此命令已deprecated，除了mpv-internal使用。

    启用指定输入部分的所有键绑定。

    启用的输入部分形成一个堆栈。在堆栈顶部的部分的绑定比下部的部分优先。这条命令将该部分放在堆栈的顶部。如果该部分已经在堆栈上，它将被事先隐含地删除。(一个部分不能在堆栈中出现多次)。

    参数 ``flags`` 可以是下列标志的组合（用 ``+`` 分隔）：

    <exclusive>
        在新启用的部分之前启用的所有部分都被禁用。一旦它们上面的所有独占部分被移除，它们将被重新启用。换句话说，新的部分会影射所有以前的部分。
    <allow-hide-cursor>
        这个功能不能通过公共API使用。
    <allow-vo-dragging>
        相同。

``disable-section <name>````禁用章节
    这个命令已经废弃了，除了mpv-internal使用的情况。

    禁用指定的输入部分。撤销``enable-section'`。

``define-section <name> <contents> [<flags>]``定义section <name> <contents> <flags>。
    该命令已被废弃，除了mpv内部使用。

    创建一个命名的输入部分，或者替换一个已经存在的输入部分的内容。 ``contents`` 参数使用与 ``input.conf`` 文件相同的语法（除了不允许在其中使用节的语法），包括需要用换行符来分隔绑定的内容。

    如果 ``contents`` 参数是一个空字符串，则该部分被删除。

    名称为 ``default`` 的部分是正常的输入部分。

    一般来说，输入部分必须用 ``enable-section`` 命令启用，否则会被忽略。

    最后一个参数有如下含义：

    <default>（如果省略了参数，也可以使用）
        只有当用户还没有把这个键绑定到一个命令时，才使用这个部分定义的键绑定。
    <force>
        始终绑定一个键。(如果有歧义，最近被激活的输入部分获胜)。

    这个命令可以用来给脚本或客户端API用户分配任意的键。如果输入部分定义了 ``script-binding`` 的命令，也可以获得单独的键上/键下事件，以及相对详细的键状态信息。特殊的键名 ``unmapped`` 可以用来匹配任何未映射的键。

``overlay-add <id> <x> <y> <file> <offset> <fmt> <w> <h> <stride>``
    添加一个来自原始数据的OSD叠加。这对控制mpv的脚本和应用程序可能很有用，它们想在视频窗口上面显示东西。

    覆盖物通常是以屏幕分辨率显示的，但对于某些VO来说，分辨率会降低到视频的分辨率。你可以阅读 ``osd-width`` 和 ``osd-height`` 属性。至少对于 ``--vo-xv`` 和变形视频（如DVD）， ``osd-par`` 也应该被读取，并且覆盖层应该是宽高比的。

    这有以下命名的参数。它们的顺序是不保证的，所以你应该总是用命名的参数来调用它们，见 `Named arguments`_

    ``id`` 是一个介于0到63之间的整数，用于识别叠加元素。这个ID可以用来添加多个覆盖部分，通过使用这个命令更新一个已经存在的ID的部分，或者用 ``overlay-remove`` 来删除一个部分。使用一个先前未使用的ID将添加一个新的覆盖件，而重复使用一个ID将更新它。

    ``x`` 和 ``y`` 指定OSD应该显示的位置。

    ``file`` 指定从原始图像数据读取的文件。它可以是以 ``@`` 为前缀的数字UNIX文件描述符（例如： ``@4`` ），也可以是文件名。文件将被 ``mmap()`` 映射到内存中，被复制，并在命令返回前解除映射（在mpv 0.18.1中改变）。

    也可以通过传递内存地址作为整数前缀的 ``&`` 字符来传递原始内存地址作为位图内存使用。在这里传递错误的东西会使玩家崩溃。这种模式在与libmpv一起使用时可能很有用。 ``offset`` 参数被简单地添加到内存地址中（从mpv 0.8.0开始，之前被忽略）。

    ``offset`` 是源文件中第一个像素的字节偏移。(目前的实现总是将整个文件从位置0到图像的末端进行mmap，所以应该避免大的偏移量。在mpv 0.8.0之前，偏移量实际上是直接传递给 ``mmap`` 的，但为了使使用更方便，它被改变了）。

    ``fmt`` 是一个标识图像格式的字符串。目前，只有 ``bgra`` 被定义。这种格式每个像素有4个字节，每个组件有8位。最不重要的8位是蓝色，最重要的8位是阿尔法（在小恩典中，组件是B-G-R-A，B是第一个字节）。这使用了预乘α：每个颜色分量都已经与α分量相乘。这意味着每个分量的数值都等于或小于alpha分量。(违反这个规则会导致不同的VO的不同结果：由于混合破碎的alpha值而导致的数值溢出被认为是不应该发生的事情，因此，在这种情况下，实现并不能确保你得到可预测的行为)。

    ``w`` , `h`` 和 ``stride`` 指定覆盖的大小。 ``w`` 是覆盖层的可见宽度，而 ``stride`` 给出的是内存中的字节宽度。在简单的情况下，使用 ``bgra`` 格式， ``stride==4*w`` 。一般来说，访问的内存总量是 ``stride * h`` 。(从技术上讲，最小的大小是 ``stride * (h - 1) + w * 4`` ，但是为了简单起见，玩家将访问所有 ``stride * h`` 的字节)。

    .. note::

        在mpv 0.18.1之前，当更新一个覆盖层时，你必须手动进行 "双重缓冲"，用一个不同的内存缓冲区来替换它。从mpv 0.18.1开始，内存被简单地复制，并且在赞扬返回后不引用任何由命令参数指示的内存。如果你想在mpv 0.18.1之前使用这个命令，请阅读旧的文档，看看如何正确处理这个问题。

``overlay-remove <id>``
    删除用 ``overlay-add`` 添加的相同ID的覆盖层。如果没有这个ID的覆盖物，则不做任何处理。

``osd-overlay``
    添加/更新/删除一个OSD覆盖层。

    (尽管这听起来与 ``overlay-add`` 相似， ``osd-overlay`` 是用于文本覆盖，而 ``overlay-add`` 是用于位图。也许 ``overlay-add`` 将被合并到 ``osd-overlay`` 中，以消除这种奇怪的现象）。

    你可以用它来添加ASS格式的文本叠加。ASS有先进的定位和渲染标签，可以用来渲染几乎所有种类的矢量图形。

    这个命令接受以下参数：

    ``id``
        识别覆盖物的任意整数。用不同的 ``id`` 参数调用此命令，可以添加多个叠加。用相同的 ``id`` 调用这个命令，会替换之前设置的覆盖。

        每个libmpv客户端（即IPC连接、脚本）都有一个单独的命名空间，所以ID可以由API用户编排和分配，而不会与其他API用户冲突。

        如果libmpv客户端被销毁，所有与之相关的覆盖层也会被删除。特别是，通过 ``--input-ipc-server`` 连接，添加一个覆盖层，然后断开连接，将再次立即删除该覆盖层。

    ``format``
        给出覆盖物类型的字符串。接受以下值（HTML渲染已损坏，请查看生成的手册，或原始RST源）。

        ``ass-events``
            参数 ``data`` 是一个字符串。该字符串在换行符上被分割。每一行都被转化为 ``Dialogue`` ASS事件的 ``Text`` 部分。计时是不使用的（但依赖计时的ASS标签的行为可能会在未来的mpv版本中改变）。

            注意，最好把多行放入 ``data`` ，而不是添加多个OSD覆盖。

            这提供了2个ASS的 ``Styles`` 。 ``OSD`` 包含由当前 ``--OSD-...`` 选项定义的文本样式。 ``Default`` 也是类似的，包含 ``OSD`` 在所有选项都设置为默认情况下的风格。

            此外， ``res_x`` 和 ``res_y`` 选项指定 ASS ``PlayResX`` 和 ``PlayResY`` 头域的值。如果 ``res_y`` 被设置为0， ``PlayResY`` 将被初始化为一个任意的默认值（但注意这个命令的默认值是720，不是0）。如果 ``res_x`` 被设置为0， ``PlayResX`` 将根据 ``res_y`` 来设置，这样虚拟的ASS像素就有一个方形的像素长宽比。

        ``none``
            特殊值，导致覆盖物被移除。除了 ``id`` 和 ``format`` 以外的大多数参数都被忽略。

    ``data``
        根据 ``format`` 参数，定义覆盖内容的字符串。

    ``res_x`` , ``res_y``
        如果 ``format`` 被设置为 ``ass-events`` （见那里的描述），则使用。可选的，默认为0/720。

    ``z``
        叠加的Z顺序。可选的，默认为0。

        注意，不同格式的覆盖层之间的Z顺序是静态的，不能改变（目前，这意味着由 ``overlay-add`` 添加的位图覆盖层总是在由 ``osd-overlay`` 添加的ASS覆盖层之上）。此外，内置的OSD组件总是在任何自定义OSD的下面。(这包括任何形式的字幕以及由 ``show-text`` 渲染的文本）。

        未来的mpv版本可能会随机改变不同OSD格式和内置OSD之间的Z顺序的处理方式。

    ``hidden``
        如果设置为yes，就不显示这个（默认： no）。

    ``compute_bounds``
        如果设置为 yes，尝试确定边界并将其作为 ``x0``, ``x1``, ``y0``, ``y1`` 的矩形写入命令的结果值（默认： no）。如果矩形是空的，不知道，或者某种程度上是退化的，则不设置。 ``x1``/``y1`` 是矩形的底端独占角的坐标。

        结果值可能取决于VO窗口的大小，并且是基于调用时最后已知的窗口大小。这意味着结果可能与实际渲染的内容不同。

        对于 ``ass-events`` ，结果矩形被重新计算为 ``PlayRes`` 坐标（ ``res_x`` / ``res_y`` ）。如果窗口大小不知道，就会选择一个回退。

        你应该知道这个机制是非常低效的，因为它渲染了全部的结果，然后使用渲染的位图列表的边界框（即使 ``hidden`` 被设置）。它将刷新各种缓存。它的结果也取决于所使用的libass版本。

        这个功能是实验性的，可能会以某种方式再次改变。

    .. note::

        总是使用命名的参数（ ``mpv_command_node()`` ）。Lua脚本应该使用 ``mp.create_osd_overlay()`` 帮助器，而不是直接调用这个命令。

``script-message [<arg1> [<arg2> [...]]]``
    向所有客户端发送一条消息，并将以下参数列表传递给它。这个消息是什么意思，它需要多少个参数，以及这些参数是什么意思，完全由接收者和发送者决定。每个客户端都会收到这个消息，所以要注意名字的冲突（或者使用 ``script-message-to`` ）。

    这个命令的参数数量不定，不能与命名参数一起使用。

``script-message-to <target> [<arg1> [<arg2> [...]]]``
    与 ``script-message`` 相同，但只发送给名为 ``<target>`` 的客户端。每个客户端（脚本等）都有一个唯一的名字。例如，Lua脚本可以通过 ``mp.get_script_name()`` 获得其名称。注意，客户端的名字只能由字母数字字符和 ``_`` 组成。

    这个命令的参数数量不定，不能与命名参数一起使用。

``script-binding <name>``
    调用一个脚本提供的密钥绑定。这可以用来重新映射由外部Lua脚本提供的按键绑定。

    参数是绑定的名称。

    它可以选择以脚本的名称为前缀，使用 ``/`` 作为分隔符，例如 ``script-binding scriptname/bindingname`` 。注意，脚本名称只能由字母数字字符和 ``_`` 组成。

    为了完整起见，这里是这个命令的内部工作方式。细节可以随时改变。在任何匹配的按键事件中， ``script-message-to`` 或 ``script-message`` 被调用（取决于是否包含脚本名称），参数如下。

    1. 字符串 ``key-binding``
    2. 绑定的名称（如上所述）。
    3. 作为字符串的按键状态（见下文）。
    4. 按键名称（从mpv 0.15.0开始）。
    5. 该键将产生的文本，如果不适用，则为空字符串。

    第5个参数只有在没有修饰符的情况下才会被设置（使用字母的shift键通常不会被认为有修饰符，而会产生大写的文本，但有些后端可能会出现混乱）。

    键的状态由2个字符组成：

    1. ``d``（键被按下）， ``u`` （被释放）， ``r`` （键仍然在下，并且被重复；只有当此绑定的键重复被启用时）， ``p`` （键被按下；如果上/下不能被追踪，则发生）。
    2. 事件是否来自鼠标， ``m`` （鼠标按钮）或 ``-`` （其他东西）。

    未来的版本可以增加更多的参数和更多的按键状态字符，以支持更多的输入特殊性。

``ab-loop``
    在A-B循环状态中循环。第一条命令将设置 ``A`` 点（ ``ab-loop-a`` 属性）；第二条是 ``B`` 点，第三条将清除两个点。

``drop-buffers``
    删除音频/视频/解扰器的缓冲区，并从新开始。这可能有助于处理不同步的流。这个命令在将来可能会被修改或删除。

``screenshot-raw [<flags>]``
    在内存中返回一个屏幕截图。这只能通过客户端的API使用。这个命令返回的MPV_FORMAT_NODE_MAP的 ``w``, ``h``, ``stride`` 字段设置为明显的内容。 ``format`` 字段默认设置为 ``bgr0`` 。这个格式被组织为 ``B8G8R8X8`` （其中 ``B`` 是LSB）。填充物 ``X`` 的内容是未定义的。 ``data`` 字段是MPV_FORMAT_BYTE_ARRAY类型，包含实际图像数据。当结果mpv_node被释放时，图像也被释放。像通常的客户端API语义一样，你不允许写到图像数据。

    ``stride`` 是指从 ``(x0, y0)`` 的像素到 ``(x0, y0 + 1)`` 的像素的字节数。如果图像被裁剪，或者有填充物，这个数字可以大于 ``w * 4`` 。这个数字也可以是负数。你用 ``byte_index = y * stride + x * 4`` 访问一个像素（假设是 ``bgr0`` 格式）。

    ``flags`` 参数与 ``screenshot`` 的第一个参数一样，支持 ``subtitles``, ``video``, ``window``

``vf-command <label> <command> <argument>``
    向过滤器发送一个命令，给定的 ``<label>`` 。使用 ``all`` 可以一次性发送给所有过滤器。命令和参数字符串是针对过滤器的。目前，这只适用于 ``lavfi`` 过滤器 - 参见libavfilter文档，了解过滤器支持哪些命令。

    注意， ``<label>`` 是mpv过滤器的标签，不是libavfilter过滤器的名称。

``af-command <label> <command> <argument>``
    与 ``vf-command`` 相同，但用于音频过滤器。

``apply-profile <name> [<mode>]``
    应用一个命名的配置文件的内容。这就像在配置文件中使用 ``profile=name`` ，除了你可以把它映射到一个键绑定，在运行时改变它。

    模式参数：

    ``default``
        应用该配置文件。如果省略该参数，则为默认。

    ``restore``
        恢复以前的 ``apply-profile`` 命令为该配置文件设置的选项。只有当配置文件的 ``profile-restore`` 设置为相关模式时才有效。如果什么都做不了，则打印一个警告。详情见 `Runtime profiles`_

``load-script <filename>``
    加载一个脚本，类似于 ``--script`` 选项。这是否等待脚本完成初始化改变了多次，未来的行为未被定义。

    成功后，返回一个 ``mpv_node`` ，其 ``client_id`` 字段设置为新创建的脚本句柄的 ``mpv_client_id()`` API调用的返回值。

``change-list <name> <operation> <value>``
    该命令改变列表选项，如 `List Options`_ 中所述。 ``<name>`` 参数是普通的选项名称，而 ``<operation>`` 是选项的后缀或操作。

    有些操作不取值，但命令仍然需要值参数。在这些情况下，值必须是一个空字符串。

    .. admonition:: 示例

        ``change-list glsl-shaders append file.glsl``

        将一个文件名添加到 ``glsl-shaders`` 列表中。命令行相当于 ``--glsl-shaders-append=file.glsl`` 或者 ``--glsl-shader=file.glsl``

``dump-cache <start> <end> <filename>``
    将当前的缓存转储到给定的文件名。如果文件已经存在， ``<filename>`` 将被覆盖。 ``<start>`` 和 ``<end>`` 给出要转储的时间范围。如果在给定的时间范围内没有数据被缓存，则可能没有数据被转储（创建一个没有数据包的文件）。

    倾倒较大部分的缓存将冻结播放器。我们没有努力去解决这个问题，因为这个功能主要是为了创建小的节选。

    请看 ``--stream-record`` 的各种注意事项，这些注意事项大多也适用于这个命令，因为两者都使用相同的底层代码来编写输出文件。

    如果 ``<filename>`` 是一个空字符串，正在进行的 ``dump-cache`` 将被停止。

    如果 ``<end>`` 是 ``no`` ，则启用连续转储。然后，在转储现有的缓存部分后，从网络上读取的任何内容也会被追加到缓存中。这与 ``--stream-record`` 相似（尽管它与该选项不冲突，而且它们可以同时激活）。

    如果 ``<end>`` 时间在缓存之后，该命令将 _不_ 等待并将新收到的数据写入缓存。

    结果文件的结尾处可能会有轻微的损坏或不完整。(没有做出足够的努力来保证结尾的正常排布)。

    注意，这个命令只有在转储结束后才会结束。这意味着它的工作原理与 ``screenshot`` 命令类似，只是它可以阻挡更长的时间。如果使用连续转储，该命令将不会结束，直到停止播放、发生错误、运行另一个 ``dump-cache`` 命令，或者调用 ``mp.abort_async_command`` 这样的API来明确停止该命令。请看 `Synchronous vs. Asynchronous`_

    .. note::

        这主要是为网络流创建的。对于本地文件，可能有更好的方法来创建摘录之类的。有很多更友好的Lua脚本，通过催生一个单独的 ``ffmpeg`` 实例来重新编码文件的一部分。对于网络流，这不是那么容易做到的，因为流必须再次被下载。即使使用 ``--stream-record`` 将流记录到本地文件系统，也可能会有问题，因为记录的文件仍然被写入。

    这个命令是实验性的，关于它的所有细节在将来可能会改变。

``ab-loop-dump-cache <filename>``
    本质上是调用``dump-cache``，以当前AB环路点为参数。与 ``dump-cache`` 一样，这将覆盖 ``<filename>`` 的文件。同样地，如果B点被设置为 ``no`` ，它将在现有的缓存被转储后进入连续转储。

    如果发现有足够的动力将这个功能转移到一个微不足道的Lua脚本中，作者保留删除这个命令的权利。

``ab-loop-align-cache``
    在 ``ab-loop-dump-cache`` 命令将（可能）转储的缓存内，重新调整A/B循环点的起点和终点。基本上，它将关键帧上的时间对齐。猜测可能会有偏差，特别是在结尾处（由于重新转换带来的粒度问题）。如果缓存在此期间缩小了，该命令设置的点也不会是有效参数。

    这个命令的未来比 ``ab-loop-dump-cache`` 更不确定，如果作者认为它没有用，可能会消失而不被替换。

未记录的命令： ``ao-reload`` （实验性/内部）。

List of events
~~~~~~~~~~~~~~

这是一个部分的事件列表。本节描述了 ``mpv_event_to_node()`` 返回的内容，也就是脚本API和JSON IPC看到的内容。注意，C语言API有单独的C语言级别的声明与 ``mpv_event`` ，可能略有不同。

请注意，事件是异步的：当事件被传递给脚本和其他客户端时，播放器核心继续运行。在某些情况下，你可以用钩子来强制执行同步执行。

所有的事件都可以有以下字段：

``event``
    事件的名称（如由 ``mpv_event_name()`` 返回）。

``id``
    ``reply_userdata`` 字段（不透明的用户值）。如果 ``reply_userdata`` 是0，该字段不被添加。

``error``
    设置为一个错误字符串（如由 ``mpv_error_string()`` 返回）。如果没有发生错误，或者事件类型不报告错误，这个字段就会丢失。大多数事件不设置这个字段。

这个列表使用事件名称字段的值，以及括号中的C API符号。

``start-file`` (``MPV_EVENT_START_FILE``)
    发生在一个新文件被加载之前。当你收到它时，播放器正在加载文件（或者可能已经完成）。

    它有以下字段：

    ``playlist_entry_id``
        现在正在加载的文件的播放列表条目ID。

``end-file`` (``MPV_EVENT_END_FILE``)
    发生在一个文件被卸载后。通常情况下，播放器将立即加载下一个文件，如果这是最后一个文件，则退出。

    该事件有以下字段：

    ``reason``
        有这些值之一：

        ``eof``
            该文件已经结束。这可以（但不一定）包括不完整的文件或网络连接中断的情况。

        ``stop``
            播放被一个命令结束。

        ``quit``
            播放是通过发送退出命令结束的。

        ``error``
            发生了一个错误。在这种情况下，有一个 ``error`` 字段和错误字符串。

        ``redirect``
            发生在播放列表和类似的情况。详情见C API中的 ``MPV_END_FILE_REASON_REDIRECT``

        ``unknown``
            未知。通常不会发生，除非Lua的API与C的API不同步。(同样，也可能发生你的脚本得到的原因字符串在你写脚本的时候还不存在)。

    ``playlist_entry_id``
        正在播放或试图播放的文件的播放列表条目ID。这个值与相应的 ``start-file`` 事件中的 ``playlist_entry_id`` 字段相同。

    ``file_error``
        设置为mpv错误字符串，描述播放失败的大致原因。如果不知道错误，就不设置。(在Lua脚本中，这个值是直接设置在 ``error`` 字段上。从mpv 0.33.0开始，这已经被废弃了。在未来，这个 ``error`` 字段对于这个特定事件将被取消设置)。

    ``playlist_insert_id``
        如果加载结束，因为要播放的播放列表条目是例如一个播放列表，而当前的播放列表条目被一些其他条目所取代。这种情况至少在MPV_END_FILE_REASON_REDIRECT中可能发生（其他事件类型将来可能出于类似但不同的目的使用这个）。在这种情况下，playlist_insert_id将被设置为第一个插入条目的播放列表条目ID，而playlist_insert_num_entries则是插入的播放列表条目的总数。注意，在这种特定情况下，最后插入的条目的ID是playlist_insert_id+num-1。请注意，根据情况，你可能会在看到事件之前观察到新的播放列表条目（例如，在收到事件之前读取 "playlist" 属性或获得属性变化通知）。如果在C API中为0，这个字段就不会被添加。

    ``playlist_insert_num_entries``
        参见playlist_insert_id。只有当playlist_insert_id存在时才会出现。

``file-loaded``  (``MPV_EVENT_FILE_LOADED``)
    发生在一个文件被加载并开始播放之后。

``seek`` (``MPV_EVENT_SEEK``)
    发生在寻找时。(这可能包括播放器内部寻找的情况，即使没有用户互动。这包括例如播放有序章节的Matroska文件时的片段变化）。

``playback-restart`` (``MPV_EVENT_PLAYBACK_RESTART``)
    在寻路后或文件被加载后开始播放。

``shutdown`` (``MPV_EVENT_SHUTDOWN``)
    当播放器退出时发送，脚本应该终止。通常是自动处理。参见`Details on the script initialization and lifecycle`_

``log-message`` (``MPV_EVENT_LOG_MESSAGE``)
    接收用 ``mpv_request_log_messages()`` 启用的信息（Lua:  ``mp.enable_messages`` ）。

    除了默认的事件字段外，它还包含以下字段：

    ``prefix``
        模块前缀，识别消息的发件人。当使用 ``--v`` 选项时，这是终端播放器放在消息文本前面的东西，也是用于 ``--msg-level`` 的东西。

    ``level``
        日志级别为字符串。参见 ``msg.log`` ，了解可能的日志级别名称。请注意，mpv的后续版本可能会增加新的级别或删除（未记录的）现有级别。

    ``text``
        日志信息。该文本将以换行符结束。有时它可能包含多行。

    请记住，这些信息是为人类提供的提示。你不应该解析它们，而且信息的前缀/级别/文本可能随时改变。

``hook``
    该事件有以下字段：

    ``hook_id``
        要传递给 ``mpv_hook_continue()`` 的ID。Lua脚本包装器通过 ``mp.add_hook()`` 提供了一个更好的API。

``get-property-reply`` (``MPV_EVENT_GET_PROPERTY_REPLY``)
    参见C API.

``set-property-reply`` (``MPV_EVENT_SET_PROPERTY_REPLY``)
    参见C API.

``command-reply`` (``MPV_EVENT_COMMAND_REPLY``)
    这是 ```error`` 字段有意义的命令之一。

    JSON IPC和Lua以及可能的其他后端会特别处理这个问题，可能不会将实际的事件传递给用户。参见C API。

    该事件有以下字段：

    ``result``
        任何 ``mpv_node`` 类型的结果（成功时），如果有的话。

``client-message`` (`MPV_EVENT_CLIENT_MESSAGE``)
    Lua和可能的其他后端对其进行特殊处理，可能不会将实际事件传递给用户。

    该事件有以下字段：

    ``args``
        包含信息数据的字符串数组。

``video-reconfig`` (``MPV_EVENT_VIDEO_RECONFIG``)
    发生在视频输出或过滤器重新配置。

``audio-reconfig`` (``MPV_EVENT_AUDIO_RECONFIG``)
    发生在音频输出或过滤器的重新配置上。

``property-change`` (``MPV_EVENT_PROPERTY_CHANGE``)
    当被观察的属性改变值时发生。

    该事件有以下字段：

    ``name``
        属性的名称。

    ``data``
        该属性的新值。

以下事件也会发生，但已deprecated。 ``idle``, ``tick`` 使用 ``mpv_observe_property()``  (Lua:  ``mp.observe_property()`` ) 来代替。

Hooks
~~~~~

钩子是玩家核心和脚本或类似的东西之间的同步事件。这适用于客户端API（包括Lua脚本接口）。通常情况下，事件应该是异步的，而钩子API提供了一种笨拙而不明显的方式来处理需要更严格协调的事件。没有做出任何API稳定性的保证。不完全遵循协议会使玩家随机冻结。基本上，没有人应该使用这个API。

C语言的API在头文件里有描述。Lua API在Lua部分有描述。

在对API客户端实际调用钩子之前，它将尝试为所有在钩子之前被改变的观察到的属性返回新的值。这可能使应用程序更容易通过注册钩子在属性变化通知之间设置定义的 "障碍"。(这意味着这些钩子会有效果，即使你什么都不做，让它们立即继续。)

目前定义了以下钩子：

``on_load``
    当一个文件要被打开时，在实际做任何事情之前被调用。例如，你可以读写 ``stream-open-filename`` 属性来重定向一个URL到其他地方（考虑支持很少给用户一个直接的媒体URL的流媒体网站），或者你可以通过设置 ``file-local-options/<option name>`` 属性来设置每个文件选项。播放器将等待，直到所有钩子都运行。

    在 ``start-file`` 之后和 ``playback-restart`` 之前排序。

``on_load_fail``
    在文件被打开后调用，但失败了。这可以用来在本地解扰器无法识别文件的情况下提供一个回退，而不是像 ``on_load`` 那样总是在本地解扰器之前运行。只有当 ``stream-open-filename`` 被改变时，才会重试Demux。如果它再次失败，这个钩子就不会再被调用，并且加载肯定会失败。

    顺序在 ``on_load`` 之后， ``playback-restart`` 和 ``end-file`` 之前。

``on_preloaded``
    在文件被打开后，在轨道被选择和解码器被创建前被调用。如果API用户想根据可用的音轨集手动选择音轨，这有一定的用处。这对于通过API以特定方式初始化 ``--lavfi-complex`` 也很有用，而不必一开始就 "探测" 可用流。

    注意，这还没有应用默认的轨道选择。究竟哪些操作可以做，哪些不可以做，哪些信息可以用，哪些还不能用，都有待于改变。

    排序在 ``on_load_fail`` 等之后， ``playback-restart`` 之前。

``on_unload``
    在关闭文件之前运行，在实际取消一切初始化之前。在这种状态下不可能恢复播放。

    顺序在 ``end-file`` 之前。在错误的情况下也会发生（那么在 ``on_load_fail`` 之后）。

``on_before_start_file``
    在发送 ``start-file`` 事件之前运行。(如果任何客户端改变了当前的播放列表条目，或者向播放器发送了退出命令，相应的事件在钩子返回后将不会实际发生)。在加载新的文件之前，对排泄属性的变化很有用。

``on_after_end_file``
    在 ``end-file`` 事件后运行。有助于在文件结束后耗尽属性变化。

Input Command Prefixes
----------------------

这些前缀放在键名和实际命令之间。可以指定多个前缀。它们之间用空格隔开。

``osd-auto``
    使用该命令的默认行为。这是 ``input.conf`` 命令的默认值。一些libmpv/scripting/IPC APIs不使用这个作为默认，而是使用 ``no-osd``
``no-osd``
    不要为这个命令使用任何OSD。
``osd-bar``
    如果可能的话，用这个命令显示一个条。寻求命令将显示进度条，改变属性的命令可能会显示新设定的值。
``osd-msg``
    如果可能的话，用这个命令显示一个OSD信息。Seek命令会显示当前的播放时间，属性改变命令会以文本形式显示新设定的值。
``osd-msg-bar``
    结合osd-bar和osd-msg。
``raw``
    不在字符串参数中展开属性。(如 ``"${property-name}"`` 。)这是一些libmpv/scripting/IPC API的默认设置。
``expand-properties``
    所有的字符串参数都按照 `Property Expansion`_ 中的描述进行扩展。这是 ``input.conf`` 命令的默认设置。
``repeatable``
    对于某些命令来说，一直按着一个键不会重复运行命令。这个前缀在任何情况下都强制启用按键重复。对于一个命令列表：第一个命令决定了整个列表的可重复性（到0.33版本为止--一个列表总是可重复的）。
``async``
    允许异步执行（如果可能）。注意，只有少数命令会支持这一点（通常这一点有明确的记录）。有些命令默认是异步的（或者说，它们的效果可能会在命令完成后表现出来）。这个标志的语义在未来可能会改变。只有当你不依赖这个命令的效果在它返回时完全实现时才设置它。参见 `Synchronous vs. Asynchronous`_
``sync``
    允许同步执行（如果可能）。通常情况下，所有的命令默认都是同步的，但有些命令默认是异步的，以便与旧的行为兼容。

所有的osd前缀仍然被全局的 ``--osd-level`` 设置所覆盖。

Synchronous vs. Asynchronous
----------------------------

``async`` 和 ``sync`` 的前缀只关系到命令发出者如何等待命令的完成。通常情况下，它不会影响命令本身的行为方式。有以下几种情况：

- 正常的input.conf命令总是以异步方式运行。慢速运行的命令被排队或并行运行。
- "多个" input.conf命令（1个键绑定，用 ``;`` 串联）将被依次执行，但那些异步的命令除外（要么以 ``async`` 为前缀，要么某些命令默认为异步）。这些异步命令会以分离的方式运行，可能与列表中其余的同步命令并行。
- 普通的Lua和libmpv命令（例如 ``mpv_command()`` ）是以阻塞方式运行的，除非使用了 ``async`` 前缀，或者该命令默认为异步的。这意味着在同步的情况下，调用者会阻塞，即使核心继续播放。异步模式是以分离的方式运行命令。
- 异步libmpv命令API（例如 ``mpv_command_async()`` ）永远不会阻塞调用者，并且总是用消息通知他们完成。 ``sync`` 和 ``async`` 的前缀没有区别。
- Lua还提供了运行异步命令的API，其行为类似于C语言的对应命令。
- 在所有情况下，异步模式仍然可以以同步的方式运行命令，甚至在分离模式下。例如，当一个命令没有异步实现的时候，就会发生这种情况。在这种情况下，异步libmpv API仍然不会阻塞调用者。

在mpv 0.29.0之前， ``async`` 前缀只被截图命令使用，并使它们以分离的方式运行文件保存代码。现在这是默认的， ``async`` 只在上面提到的方面改变行为。

目前，以下命令在同步与异步下有不同的等待特性：sub-add, audio-add, sub-reload, audio-reload, rescan-external-files, screenshot, screenshot-to-file, dump-cache, ab-loop-dump-cache

Asynchronous command details
----------------------------

在API层面上，每个异步命令都与启动它的上下文绑定。例如，由 ``mpv_command_async`` 启动的异步命令被绑定到传递给函数的 ``mpv_handle`` 。只有这个 ``mpv_handle`` 能收到完成通知（ ``MPV_EVENT_COMMAND_REPLY`` ），而且只有这个句柄能直接中止仍在运行的命令。如果 ``mpv_handle`` 被销毁，由它启动的任何仍在运行的异步命令都会被终止。

脚本API和JSON IPC给每个脚本/连接提供了自己的隐式 ``mpv_handle``

如果播放器被关闭，核心可能会自行中止所有悬而未决的异步命令（就像代表API用户对每个悬而未决的命令强制调用 ``mpv_abort_async_command()`` 。这发生在发送 ``MPV_EVENT_SHUTDOWN`` 的同时，而且没有办法阻止它。

Input Sections
--------------

输入部分将一组绑定分组，并一次性启用或禁用它们。在 ``input.conf`` 中，每个键的绑定都被分配到一个输入区，而不是实际有明确的文本区。

也请参见： ``enable-section`` 和 ``disable-section`` 命令。

预定义的绑定：

``default``
    没有输入部分的绑定被隐含地分配给这个部分。它在正常播放时默认是启用的。
``encode``
    在编码模式下激活的部分。它被专门启用，所以在 ``default`` 部分的绑定被忽略。

Properties
----------

属性用于在运行时设置mpv选项，或者查询任意信息。它们可以用 ``set``/``add``/``cycle`` 命令操作，用 ``show-text`` 检索，或者其他任何使用属性扩展的方法。(参见 `Property Expansion`_ ）。

属性名称用RW注释，表示该属性是否一般可写。

如果一个选项被引用，该属性通常会采取/返回与该选项完全相同的值。在这些情况下，属性只是一种在运行时改变选项的方法。

Property list
-------------

.. note::

    大多数选项也可以通过属性在运行时设置。只需从选项名称中去掉前面的 ``--`` 。下面没有记录这些内容，请看 `OPTIONS`_ 。只有那些不存在同名的选项的属性，或者与选项有非常不同的行为的属性才会在下面记录。

    标记为(RW)的属性是可写的，而那些没有标记的是只读的。

``audio-speed-correction``, ``video-speed-correction``
    与播放器试图播放文件的 ``speed`` 相乘的系数。通常情况下，它正好是1。(显示同步模式将使其有用。)

    OSD格式将以 ``+1.23456%`` 的形式显示，数字是 ``(raw - 1) * 100`` ，用于给定的原始属性值。

``display-sync-active``
    ``--video-sync=display`` 是否实际激活。

``filename``
    当前播放的文件，路径已删除。如果这是一个URL，也尝试取消百分比编码。(结果不一定正确，但看起来更适合显示。使用 ``path`` 属性来获得未修改的文件名）。

    这有一个子属性：

    ``filename/no-ext``
        和 ``filename`` 属性一样，但如果文本中包含 ``.`` ，则剥离最后一个 ``.`` 后的所有文本。通常这将删除文件扩展名。

``file-size``
    源文件/流的长度，以字节为单位。(这与 ``${stream-end}`` 相同。对于分段/多部分的文件，这将返回主文件或清单文件的大小，不管它是什么)。

``estimated-frame-count``
    当前文件中的总帧数。

    .. note:: 这只是一个估计值。(它是由两个不可靠的数量计算出来的：帧数和流长。)

``estimated-frame-number``
    当前数据流中的当前帧数。

    .. note:: 这只是一个估计值。(它是由两个不可靠的数量计算出来的：fps和可能是四舍五入的时间戳)。

``pid``
    mpv的进程ID。

``path``
    当前播放文件的完整路径。通常这和你在mpv命令行或 ``loadfile`` 命令中传递的字符串完全一样，即使它是一个相对路径。如果你期望一个绝对路径，你将不得不自己确定，例如通过使用 ``working-directory`` 属性。

``stream-open-filename``
    当前播放的媒体的完整路径。这只在特殊情况下与 ``path`` 不同。特别是，如果使用了 ``--ytdl=yes`` ，并且URL是由 ``youtube-dl`` 检测的，那么脚本将把这个属性设置为实际的媒体URL。这个属性应该只在 ``on_load`` 或 ``on_load_fail`` 钩子期间设置，否则它将没有效果（或者可能在未来做一些执行定义的事情）。如果当前媒体的播放结束，该属性将被重置。

``media-title``
    如果当前播放的文件有一个 ``title`` 标签，则使用该标签。

    否则，返回 ``filename`` 属性。

``file-format``
    文件格式的符号名称。在某些情况下，这是一个用逗号分隔的格式名称列表，例如mp4是 ``mov,mp4,m4a,3gp,3g2,mj2`` （对于任何格式，这个列表在将来可能会增加）。

``current-demuxer``
    当前解复用器的名称。(这个没有用。)

    (由 ``demuxer`` 重命名)。

``stream-path``
    流层文件名（全路径）。(这可能是无用的，几乎不会与 ``path`` 不同)。

``stream-pos``
    源流中的原始字节位置。从技术上讲，它返回传递给解码器的最新数据包的位置。

``stream-end``
    源流中的原始结束位置（字节）。

``duration``
    当前文件的持续时间（秒）。如果持续时间未知，该属性不可用。注意，文件的持续时间并不总是准确的，所以这是一个估计值。

    它取代了 ``length`` 属性，该属性在mpv 0.9发布后deprecated。(语义是一样的)。

``avsync``
    最后的A/V同步差异。如果音频或视频被禁用，则不可用。

``total-avsync-change``
    完成的总A/V同步校正。如果音频或视频被禁用，则不可用。

``decoder-frame-drop-count``
    解码器放弃的视频帧数，因为视频落后于音频太多（当使用 ``--framedrop=decoder`` 时）。有时，在其他情况下，如视频数据包被损坏，或解码器不遵循通常的规则，这可能会被增加。如果视频被禁用，则不可用。

    ``drop-frame-count`` 是一个deprecated的别名。

``frame-drop-count``
    VO丢弃的帧数（当使用 ``--framedrop=vo`` 时）。

    ``vo-drop-frame-count`` 是一个deprecated的别名。

``mistimed-frame-count``
    为了保持A/V同步，在显示同步模式下没有正确计时的视频帧的数量。这不包括外部情况，如视频渲染太慢或图形驱动程序以某种方式跳过vsync。它也不包括四舍五入的错误（特别是在源时间戳不好的情况下可能发生）。例如，使用 ``display-desync`` 模式时，不应该把这个值从0改变。

``vsync-ratio``
    对于一个帧平均显示多少个vsyncs。这只在display-sync激活时可用。对于60Hz屏幕上的30FPS视频，这将是2。这是实际安排的移动平均数，所以60 Hz上的24 FPS永远不会精确地保持在2.5上，而是根据最后显示的帧来抖动。

``vo-delayed-frame-count``
    在显示同步模式下，由于外部环境造成的延迟帧数的估计。注意，一般来说，mpv必须猜测这种情况的发生，而且猜测可能不准确。

``percent-pos`` (RW)
    当前文件中的位置（0-100）。使用它而不是从其他属性中计算的好处是，如果文件的持续时间不知道，它可以正确地退回到从字节位置估计播放位置。

``time-pos`` (RW)
    当前文件中的位置，以秒为单位。

``time-start``
    Deprecated。在mpv 0.14之前，它用于返回文件的开始时间（可能影响到例如传输流）。参见 ``--rebase-start-time`` 选项.

``time-remaining``
    文件的剩余长度，以秒为单位。注意，文件的持续时间并不总是准确的，所以这是一个估计。

``audio-pts``
    当前文件中的音频播放位置（秒）。与时间位置不同，它的更新频率高于每帧一次。对于纯音频文件，它主要等同于时间位置，而对于纯视频文件，这个属性不可用。

``playtime-remaining``
    ``time-remaining`` 由当前 ``speed`` 缩放。

``playback-time`` (RW)
    在当前文件中的位置，以秒为单位。与 ``time-pos`` 不同，时间被钳制在文件的范围内。(不准确的文件持续时间等可能使它超出范围。在试图寻找文件以外的地方时很有用，因为寻找目标时间被认为是寻找过程中的当前位置）。

``chapter`` (RW)
    当前的章节编号。第一章的编号是0。

``edition`` (RW)
    当前的MKV版本号。将此属性设置为一个不同的值将重新开始播放。第一个版本的号码是0。

    在mpv 0.31.0之前，如果你没有手动设置选项或属性，这显示的是在运行时选择的实际版本。在mpv 0.31.0及以后的版本中，这严格地返回用户设置的选项或属性值，并且增加了 ``current-edition`` 属性来返回运行时选择的版本（这与 ``--edition=auto`` 有关，默认的）。

``current-edition``
    当前选择的版本。如果没有加载文件，或者文件没有版本，这个属性就不可用。(Matroska文件在没有版本和单一版本之间有区别，这将反映在该属性中，尽管在实践中并不重要)。

``chapters``
    章节的数量。

``editions``
    MKV版本的数量。

``edition-list``
    版本的列表，当前条目被标记。目前，原始属性值是无用的。

    这有许多子属性。用基于0的版本索引取代 ``N`` 

    ``edition-list/count``
        版本的数量。如果没有版本，它可以是0或1（1
        如果有一个无用的假版本，这个数字可以是0或1（如果有一个无用的假版本，就是1）。

    ``edition-list/N/id`` (RW)
        版本ID为整数。用它来设置 ``edition`` 属性。
        目前，这与版本索引相同。

    ``edition-list/N/default``
        这是否是默认版本。

    ``edition-list/N/title``
        存储在文件中的版本标题。不总是可用。

    当用客户端API使用 ``MPV_FORMAT_NODE`` 查询该属性时，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下。

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each edition)
                "id"                MPV_FORMAT_INT64
                "title"             MPV_FORMAT_STRING
                "default"           MPV_FORMAT_FLAG

``metadata``
    元数据键/值对。

    如果用Lua的 ``mp.get_property_native`` 访问该属性，这将返回一个元数据键与元数据值映射的表格。如果是通过客户端API访问，则返回一个 ``MPV_FORMAT_NODE_MAP`` ，其中标签键映射到标签值。

    对于OSD，它返回一个格式化的列表。试图以原始字符串的形式检索这个属性是行不通的。

    这有许多子属性：

    ``metadata/by-key/<key>``
        元数据条目 ``<key>`` 的值。

    ``metadata/list/count``
        元数据条目的数量。

    ``metadata/list/N/key``
        第N个元数据条目的键名。(第一个条目是 ``0`` )。

    ``metadata/list/N/value``
        第N个元数据条目的值。

    ``metadata/<key>``
        旧版本的 ``metadata/by-key/<key>`` 。不鼓励使用，因为元数据的关键字符串可能与其他子属性冲突。

    这个属性的布局可能会有变化。欢迎提出建议，这个属性到底应该如何工作。

    当使用客户端API使用 ``MPV_FORMAT_NODE`` 查询该属性时，或使用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_MAP
            (key and string value for each metadata entry)

``filtered-metadata``
    像 ``metadata`` 一样，但只包括 ``--display-tags`` 选项中列出的字段。这也是输出到终端的标签集。

``chapter-metadata``
    当前章节的元数据。作用类似于 ``metadata`` 属性。它也允许同样的访问方法（使用子属性）。

    每一章的元数据是非常罕见的。通常情况下，只有章节名称（ ``title`` ）被设置。

    对于访问其他信息，如章节开始，请看 ``chapter-list`` 属性。

``vf-metadata/<filter-label>``
    由视频过滤器添加的元数据。通过过滤器标签访问，如果没有使用 ``@filter-label:`` 语法明确指定，将是 ``<filter-name>NN``

    工作原理类似于 ``metadata`` 属性。它允许同样的访问方法（使用子属性）。

    这种元数据的一个例子是由 ``--vf=lavfi=cropdetect`` 添加的剪裁参数。

``af-metadata/<filter-label>``
    相当于 ``vf-metadata/<filter-label>`` ，但用于音频过滤器。

``idle-active``
    如果没有文件被加载，但由于 ``--idle`` 选项，播放器在附近停留，则返回 ``yes`` /true。

    (由 ``idle`` 改名而来)。

``core-idle``
    播放核心是否暂停。在特殊情况下，这可能与 ``pause`` 不同，例如当播放器由于网络缓存不足而自行暂停。

    如果播放正在重启或根本没有播放，这也会返回 ``yes`` /true。换句话说，只有在真正有视频播放的情况下，才会返回 ``no`` /false。(从mpv 0.7.0开始的行为。)

``cache-speed``
    缓存和下层（如网络）之间的当前I/O读取速度。这给出了1秒内的字节数（使用客户端API的 ``MPV_FORMAT_INT64`` 类型）。

    这与 ``demuxer-cache-state/raw-input-rate`` 相同。

``demuxer-cache-duration``
    在解扰器中缓冲的视频的大致持续时间，以秒为单位。这个猜测非常不可靠，通常这个属性根本无法使用，即使数据被缓冲了。

``demuxer-cache-time``
    视频在解复用器中缓冲的大致时间，以秒为单位。与 ``demuxer-cache-duration`` 相同，但返回demuxer中缓冲数据的最后时间戳。

``demuxer-cache-idle``
    解复器是否处于空闲状态，这意味着解复器的缓存已经填充到要求的数量，目前没有读取更多数据。

``demuxer-cache-state``
    ``seekable-ranges`` 中的每个条目代表了解扰器缓存中可以被搜索到的区域，其中的 ``start`` 和 ``end`` 字段包含各自的时间戳。如果有多个解扰器在运行，这只返回关于 "主 "解扰器的信息，但将来可能会改变，返回所有解扰器的统一信息。这些范围的顺序是任意的。通常情况下，范围在被连接之前会有一些重叠。在破碎的角落里，范围可能到处重叠。

    寻道范围的末端通常比 ``demuxer-cache-time`` 属性返回的值小，因为该属性返回的是猜测的缓冲量，而寻道范围代表的是实际可用于缓冲寻道的缓冲数据。

    ``bof-cached`` 表示具有最低时间戳的寻道范围是否指向流的开始（BOF）。这意味着你完全不能在这个位置之前寻道。 ``eof-cached`` 表示具有最高时间戳的搜索范围是否指向流的末端（EOF）。如果 ``bof-cached`` 和 ``eof-cached`` 都为真，并且只有一个缓存范围，则整个数据流都被缓存。

    ``fw-bytes`` 是在当前解码位置开始的范围内缓冲的数据包的字节数。这是一个粗略的估计（可能没有正确考虑到各种开销），并在解码器位置停止（它忽略了之后的搜索范围）。

    ``file-cache-bytes`` 是存储在文件缓存中的字节数。这包括所有的开销，以及可能的未使用的数据（如修剪的数据）。如果文件缓存没有用 ``--cache-on-disk=yes`` 启用，这个成员就没有。

    ``cache-end`` 是 ``demuxer-cache-time`` 。如果不可用，则缺失。

    ``reader-pts`` 是缓冲范围开始的大致时间戳。如果不可用则缺失。

    ``cache-duration``是`demuxer-cache-duration`` . 如果不可用则缺失。

    ``raw-input-rate`` 是网络层（或任何其他面向字节的输入层）的估计输入率，单位是字节/秒。可能不准确或丢失。

    当用客户端API用 ``MPV_FORMAT_NODE`` 查询该属性时，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下。

    ::

        MPV_FORMAT_NODE_MAP
            "seekable-ranges"   MPV_FORMAT_NODE_ARRAY
                MPV_FORMAT_NODE_MAP
                    "start"             MPV_FORMAT_DOUBLE
                    "end"               MPV_FORMAT_DOUBLE
            "bof-cached"        MPV_FORMAT_FLAG
            "eof-cached"        MPV_FORMAT_FLAG
            "fw-bytes"          MPV_FORMAT_INT64
            "file-cache-bytes"  MPV_FORMAT_INT64
            "cache-end"         MPV_FORMAT_DOUBLE
            "reader-pts"        MPV_FORMAT_DOUBLE
            "cache-duration"    MPV_FORMAT_DOUBLE
            "raw-input-rate"    MPV_FORMAT_INT64

    其他字段（将来可能被改变或删除）。

    ``eof``
        读取器线程是否达到了文件的末端。

    ``underrun``
        读者线程是否不能满足解码器对新数据包的请求.

    ``idle``
        线程是否目前没有阅读.

    ``total-bytes``
        整个数据包队列的数据包字节数之和（加上一些开销估计），包括缓存的可寻范围。

``demuxer-via-network``
    通过主解复用器解复用的流是否最可能通过网络播放。什么构成 "网络" 并不总是清楚的，可能用于其他类型的不可信任的流，在某些情况下可能是错误的，而且它的定义可能正在改变。另外，外部文件（如独立的音频文件或流）并不影响这个属性的值（目前）。

``demuxer-start-time``
    解复用器报告的开始时间，以小数秒为单位。

``paused-for-cache``
    播放是否因等待缓存而暂停。

``cache-buffering-state``
    缓存填充状态的百分比（0-100），直到播放器取消暂停（与 ``paused-for-cache`` 有关）。

``eof-reached``
    Whether the end of playback was reached. Note that this is usually interesting only if ``--keep-open`` 被启用时，这才有意义，因为否则播放器会立即播放下一个文件（或退出或进入空闲模式），在这些情况下， ``eof-reach`` 属性被设置后，逻辑上将立即被清除。

``seeking``
    播放器目前是否正在寻找，或以其他方式试图重新开始播放。(有可能在文件加载时返回 ``yes`` /true。这是因为相同的底层代码被用于寻找和重新同步）。

``mixer-active``
    音频混合器是否激活。

    这个选项相对来说是无用的。在mpv 0.18.1之前，它可以用来推断 ``volume`` 属性的行为。

``ao-volume`` (RW)
    系统体积。这个属性只有在mpv音频输出当前处于激活状态时才可用，并且只有在底层实现支持音量控制时才可用。这个选项的作用取决于API。例如，在ALSA上，这通常会改变整个系统的音频，而在PulseAudio上，这控制每个应用的音量。

``ao-mute`` (RW)
    与 ``ao-volume`` 相似，但控制静音状态。即使 ``ao-volume`` 起作用，也可能未被实施。

``audio-codec``
    选择用于解码的音频编解码器。

``audio-codec-name``
    音频编解码器。

``audio-params``
    由音频解码器输出的音频格式。这有许多子属性：

    ``audio-params/format``
        采样格式为字符串。这与mpv其他地方使用的名称相同。

    ``audio-params/samplerate``
        采样率。

    ``audio-params/channels``
        通道布局是一个字符串。这与 ``--audio-channels`` 接受的内容相似。

    ``audio-params/hr-channels``
        和 ``channels`` 一样，但不是发送至音频设备的可能的隐秘的实际布局，而是返回一个希望更容易被人阅读的形式。(通常只有 ``audio-out-params/hr-channels`` 有意义。)

    ``audio-params/channel-count``
        音频通道的数量。这与上面描述的 ``channels`` 字段是多余的。

    当用客户端API用 ``MPV_FORMAT_NODE`` 查询该属性，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_MAP
            "format"            MPV_FORMAT_STRING
            "samplerate"        MPV_FORMAT_INT64
            "channels"          MPV_FORMAT_STRING
            "channel-count"     MPV_FORMAT_INT64
            "hr-channels"       MPV_FORMAT_STRING

``audio-out-params``
    和 ``audio-params`` 相同，但写给音频API的数据格式。

``colormatrix``
    重定向到 ``video-params/colormatrix`` 。这个参数（以及类似的参数）可以用 ``format`` 视频过滤器覆盖。

``colormatrix-input-range``
    参见 ``colormatrix``

`·colormatrix-primaries``
    参见 ``colormatrix``

``hwdec`` (RW)
    反映 ``--hwdec`` 选项。

    如果可能的话，对它的写入可以改变当前使用的硬件解码器。(在内部，播放器可能会重新初始化解码器，并将执行一次寻道以正确刷新视频)。你可以观察其他的hwdec属性，看看这是否成功。

    与mpv 0.9.x及以前不同的是，这并不返回当前活动的硬件解码器。从mpv 0.18.0开始， ``hwdec-current`` 可用于此目的。

``hwdec-current``
    当前正在使用的硬件解码。如果解码是有效的，返回 ``hwdec`` 选项/属性所使用的值之一。 ``no`` /false表示软件解码。如果没有加载解码器，该属性不可用。

``hwdec-interop``
    这将返回当前加载的硬件解码/输出互操作驱动程序。这只有在VO打开后才知道（也可能是后来）。对于某些VO（如 ``gpu`` ），这可能永远不会事先知道，而只是在解码器试图成功创建hw解码器时才知道。(使用 ``--gpu-hwdec-interop`` 可以急于加载它。) 如果有多个驱动程序被加载，它们将被 ``,`` 分开。

    如果没有VO被激活或没有已知的互操作驱动，这个属性就不可用。

    这不一定使用与 ``hwdec`` 相同的值。同一硬件解码器可以有多个互操作驱动，这取决于平台和VO。

``video-format``
    视频格式为字符串。

``video-codec``
    选择用于解码的视频编解码器。

``width``, ``height``
    视频大小。这使用解码后的视频尺寸，或者如果还没有解码的视频帧，则使用（可能不正确的）容器指示尺寸。

``video-params``
    视频参数，由解码器输出（应用长宽比等重写）。这有许多子属性：

    ``video-params/pixelformat``
        像素格式的字符串。这与mpv的其他地方使用的名称相同。

    ``video-params/hw-pixelformat``
        作为字符串的基本像素格式。这与某些硬件解码的情况有关，否则无法使用。

    ``video-params/average-bpp``
        每像素的平均比特数，为整数。子采样的平面格式使用不同的分辨率，这就是这个值有时会很奇怪或令人困惑的原因。在某些格式中可能不可用。

    ``video-params/w``, ``video-params/h``
        视频尺寸为整数，没有应用长宽比校正。

    ``video-params/dw``, ``video-params/dh``
        视频尺寸为整数，按正确的长宽比进行缩放。

    ``video-params/aspect``
        显示长宽比为浮点数。

    ``video-params/par``
        像素长宽比。

    ``video-params/colormatrix``
        使用中的颜色矩阵为字符串。(精确值可能会改变。)

    ``video-params/colorlevels``
        颜色等级的字符串。(精确值会有变化。)

    ``video-params/primaries``
        使用中的基色为字符串。(精确值可能会改变。)

    ``video-params/gamma``
        使用中的伽马函数，字符串。(精确值会有变化。)

    ``video-params/sig-peak``
        视频文件的标记信号峰值，以浮点数表示。

    ``video-params/light``
        使用中的灯光类型为字符串。(精确值可能会改变。)

    ``video-params/chroma-location``
        色度位置的字符串。(精确值可能会改变。)

    ``video-params/rotate``
        预期的显示旋转度数（顺时针）。

    ``video-params/stereo-in``
        源文件的立体3D模式。(见 ``format`` 视频过滤器的 ``stereo-in`` 选项)。

    ``video-params/alpha``
        阿尔法类型。如果格式没有阿尔法通道，这将是不可用的（但在未来的版本中，它可能变为 ``no`` ）。如果有阿尔法，这将被设置为 ``straight`` 或 ``premul``

    当用客户端API使用 ``MPV_FORMAT_NODE`` 查询该属性时，或者用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_MAP
            "pixelformat"       MPV_FORMAT_STRING
            "hw-pixelformat"    MPV_FORMAT_STRING
            "w"                 MPV_FORMAT_INT64
            "h"                 MPV_FORMAT_INT64
            "dw"                MPV_FORMAT_INT64
            "dh"                MPV_FORMAT_INT64
            "aspect"            MPV_FORMAT_DOUBLE
            "par"               MPV_FORMAT_DOUBLE
            "colormatrix"       MPV_FORMAT_STRING
            "colorlevels"       MPV_FORMAT_STRING
            "primaries"         MPV_FORMAT_STRING
            "gamma"             MPV_FORMAT_STRING
            "sig-peak"          MPV_FORMAT_DOUBLE
            "light"             MPV_FORMAT_STRING
            "chroma-location"   MPV_FORMAT_STRING
            "rotate"            MPV_FORMAT_INT64
            "stereo-in"         MPV_FORMAT_STRING
            "average-bpp"       MPV_FORMAT_INT64
            "alpha"             MPV_FORMAT_STRING

``dwidth``, ``dheight``
    视频显示尺寸。这是应用了过滤器和长宽比之后的视频尺寸。实际的视频窗口大小仍可能与此不同，例如，如果用户手动调整视频窗口的大小。

    这些值与 ``video-out-params/dw`` 和 ``video-out-params/dh`` 相同。

``video-dec-params``
    与 ``video-params`` 完全一样，但不应用重写。

``video-out-params``
    与 ``video-params`` 相同，但在视频过滤器被应用后。如果没有使用视频过滤器，这将包含与 ``video-params`` 相同的值。请注意，这仍然不一定是视频窗口所使用的，因为用户可以改变窗口的大小，所有真正的VO都是独立于过滤器链做自己的缩放的。

    拥有与 ``video-params`` 相同的子属性。

``video-frame-info``
    当前帧的近似信息。请注意，如果在OSD上使用这些信息，由于OSD重绘和帧显示有些脱节，信息可能会有几帧的偏差，你可能不得不暂停并强制重绘。

    这有许多子属性：

    ``video-frame-info/picture-type``
        图片的类型。它可以是 "I"（内部）、"P"（预测）、"B"（双向预测）或不可用。

    ``video-frame-info/interlaced``
        帧的内容是否是交错的。

    ``video-frame-info/tff``
        如果内容是隔行扫描，是否先显示最上面的字段。

    ``video-frame-info/repeat``
        解码时是否必须延迟帧数。

``container-fps``
    容器FPS。这很容易包含假的数值。对于使用现代容器格式或视频编解码器的视频，这往往是不正确的。

    (从 ``fps`` 重新命名。)

``estimated-vf-fps``
    视频过滤链输出的估计/测量的FPS。(如果没有使用滤波器，这对应于解码器输出。) 这使用过去10个帧的平均时间来计算FPS。如果涉及到丢帧，它将是不准确的（比如当明确启用了丢帧，或在精确寻址之后）。具有不精确时间戳的文件（如Matroska）可能导致不稳定的结果。

``window-scale`` (RW)
    窗口大小的乘数。设置它将调整视频窗口的大小，使之与 ``dwidth`` 和 ``dheight`` 中包含的值相乘，并与此属性设置的值相乘。设置 ``1`` 将调整到原始视频尺寸（或者准确地说，视频过滤器输出的尺寸）。 ``2`` 将设置双倍大小， ``0.5`` 将大小减半。

    注意，设置一个与之前相同的值不会调整窗口的大小。这是因为这个属性反映了 ``window-scale`` 选项，设置一个选项到它之前的值会被忽略。如果这个值是在窗口处于全屏状态时设置的，那么乘数不会被应用，直到窗口从该状态中被取出。在一个最大化的窗口中写入这个属性，可以使窗口取消最大化，这取决于操作系统和窗口管理器。如果该窗口没有取消最大化，那么如果用户以后取消最大化，倍数将被应用。

    参见 ``current-window-scale`` 以了解从实际窗口大小得出的数值。

    从mpv 0.31.0开始，这总是返回先前设置的值（或默认值），而不是实际窗口大小所暗示的值。在mpv 0.31.0之前，在窗口创建后，它返回 ``current-window-scale`` 的值。

``current-window-scale`` (RW)
    根据当前窗口大小计算的 ``window-scale`` 值。如果窗口大小在设置选项后没有改变，并且窗口大小没有受到其他方面的限制，那么这个值与 ``window-scale`` 相同。如果窗口是全屏的，这将返回从窗口的最后一次非全屏尺寸计算出来的比例值。如果没有视频被激活，该属性不可用。

    在全屏或最大化状态下设置该属性时，其行为与window-scale相同。在所有这些情况下，设置该属性的值将始终调整窗口的大小。这不影响 ``window-scale`` 的值。

``focused``
    窗口是否有焦点。可能不被所有的VO支持。

``display-names``
    mpv窗口所覆盖的显示器的名称。在X11上，这些是xrandr名称（LVDS1, HDMI1, DP1, VGA1, 等等）。在Windows上，这些是GDI名称（\\.\DISPLAY1，\\.\DISPLAY2，等等），列表中的第一个显示器将是Windows认为与该窗口相关的（由MonitorFromWindow API决定）。 在macOS上，这些是系统信息中使用的显示产品名称，只有一个显示名称被返回，因为一个窗口只能在一个屏幕上。

``display-fps``
    当前显示器的刷新率。目前，这是视频覆盖的任何显示器的最低FPS，由底层系统API检索（例如X11的xrandr）。它不是测量的FPS。它不一定在所有平台上都可用。注意，任何列出的事实都可能在没有警告的情况下随时改变。

    写入此属性已deprecated。它与写入 ``overrid-display-fps`` 的效果相同。从mpv 0.31.0开始，如果没有显示FPS的报告，这个属性就不可用（例如，如果没有视频被激活），而在旧版本中，它返回 ``--display-fps`` 选项值。

``estimated-display-fps``
    显示屏刷新的实际速度，由系统时间衡量。只有在显示同步模式（由 ``--video-sync`` 选择）激活时才可用。

``vsync-jitter``
    vsync持续时间的估计偏差系数。

``display-width``, ``display-height``
    当前显示器的水平和垂直分辨率，像素。这些值是否在mpv窗口改变显示时更新，取决于窗口化后端。它可能不是在所有平台上都可用。

``display-hidpi-scale``
    由视窗后端报告的HiDPI比例因子。如果没有VO被激活，或者VO没有报告一个值，这个属性是不可用的。报告一个绝对的DPI可能更合理，然而，这是大多数操作系统API实现HiDPI支持的方式。请参阅 ``--hidpi-window-scale``

``video-aspect`` (RW)
    已废弃。该选项与 ``--video-aspect-override`` 相关，但如果视频处于活动状态，则总是报告当前的视频角度。

    这个选项的读和写部分可以分别拆分为 ``--video-params/aspect`` 和 ``--video-aspect-override``

``osd-width``, ``osd-height``
    最后已知的OSD宽度（可以是0）。如果你想使用 ``overlay-add`` 命令，就需要这个。它给你实际的OSD/窗口尺寸（不包括操作系统窗口管理器绘制的装饰）。

    对 ``osd-dimensions/w`` 和 ``osd-dimensions/h`` 的别名。

``osd-par``
    最后一个已知的OSD显示像素长宽（可以是0）。

    与 ``osd-dimensions/osd-par`` 的别名相同。

``osd-dimensions``
    最后已知的OSD尺寸。

    有以下子属性(可以作为 ``MPV_FORMAT_NODE`` 或Lua表用 ``mp.get_property_native`` 读取)。

    ``osd-dimensions/w``
        VO窗口的尺寸，以OSD渲染单位（通常是像素，但也可以用VO如 ``xv`` 缩放像素）。

    ``osd-dimensions/h``
        VO窗口的尺寸，以OSD渲染单位计算。

    ``osd-dimensions/par``
        OSD的像素长宽比（通常为1）。

    ``osd-dimensions/aspect``
        VO窗口的显示长宽比。(从上面的属性计算)。

    ``osd-dimensions/mt``, ``osd-dimensions/mb``, ``osd-dimensions/ml``, ``osd-dimensions/mr``
        OSD到视频的边缘（上、下、左、右）。这描述了视频被渲染到的区域。

    如果VO窗口没有被创建或可见，这些属性中的任何一个都可能不可用或被设置为假值。

``mouse-pos``
    只读 - 最后一个已知的鼠标位置，根据OSD尺寸正常化。

    有以下子属性（可以作为 ``MPV_FORMAT_NODE`` 或用 ``mp.get_property_native`` 读取Lua表）：

    ``mouse-pos/x``, ``mouse-pos/y``
        鼠标指针的最后已知坐标。

    ``mouse-pos/hover``
        布尔值 - 鼠标指针是否悬停在视频窗口上。当此值为false时，坐标应被忽略，因为视频后端只有在指针悬停窗口时才会更新坐标。

``sub-text``
    当前的字幕文本，不管副标题是否可见。格式化被剥离。如果字幕不是基于文本的（即DVD/BD字幕），将返回一个空字符串。

    这个属性是试验性的，将来可能被删除。

``sub-text-ass``
    和 ``sub-text`` 一样，但返回ASS格式的文本。其他格式的文本字幕会被转换。对于原生的ASS字幕，不包含任何文本（但是矢量图等）的事件不会被过滤掉。如果多个事件与当前播放时间相匹配，它们会用换行符连接起来。只包含事件的 "文本" 部分。

    这个属性不足以正确呈现ASS字幕，因为ASS头和每个事件的元数据没有被返回。你可能需要对返回的字符串做进一步的过滤以使其有用。

    这个属性是试验性的，将来可能会被删除。

``secondary-sub-text``
    与 ``sub-text`` 相同，但用于二级字幕。

``sub-start``
    当前字幕的开始时间（以秒为单位）。如果有多个当前字幕，返回第一个开始时间。如果没有当前的字幕，将返回空值。

``secondary-sub-start``
    与 ``sub-start`` 相同，但针对副标题。

``sub-end``
    当前字幕的结束时间（以秒为单位）。如果有多个当前字幕，返回最后的结束时间。如果没有当前的字幕，或者有字幕但持续时间未知或不正确，则返回null。

``secondary-sub-end``
    与 ``sub-end`` 相同，但用于副标题。

``playlist-pos`` (RW)
    当前在播放列表中的位置。第一个条目是在0的位置。

    在某些情况下，这不一定是当前播放的文件。请看  ``playlist`` 中的 ``current`` 和 ``playing``  标志的解释。

    如果播放列表是空的，或者如果它不是空的，但没有条目是 "current" 的，这个属性就会返回-1。同样，写-1将使播放器进入空闲模式（如果没有启用空闲模式则退出播放）。(在mpv 0.33.0之前，如果没有播放列表条目是当前的，这个属性就不能返回-1。)

    将当前值写回该属性是有可能改变的。目前，它将重新启动播放列表条目的播放。但在未来，写回当前值将被忽略。使用 ``playlist-play-index`` 命令来获得保证行为。

``playlist-pos-1`` (RW)
    与 ``playlist-pos`` 相同，但基于1。

``playlist-current-pos`` (RW)
    播放列表中的 "current" 项目的索引。这通常是，但不一定是当前正在播放的项目（见 ``playlist-playing-pos`` ）。根据播放器的确切内部状态，它可能指的是下一个要播放的播放列表项目，或者用于决定下一个播放内容的播放列表项目。

    对于读取，这与 ``playlist-pos`` 完全相同。

    对于写，这 *只* 设置 "current" 项目的位置，而不停止当前文件的播放（或者开始播放，如果这是在空闲模式下进行的）。使用-1来删除当前标志。

    这个属性只是隐约有用。如果在播放过程中设置，它通常会导致播放列表中 *后* 的条目被接下来播放。另一个可能很奇怪的观察状态是，如果在播放过程中运行 ``playlist-next`` ，这个属性会被设置为下一个要播放的播放列表条目（与前面的情况不同）。有一个内部标志来决定是播放当前的播放列表条目还是下一个，这个标志目前对API用户来说是不可访问的。(这种行为是否会被保留，可能会有变化)。

``playlist-playing-pos``
    播放列表中 "正在播放" 的项目的索引。如果一个播放列表项目正在加载、实际播放或正在卸载，它就是 "playing" 。这个属性在 ``MPV_EVENT_START_FILE`` (``start-file``) 和 ``MPV_EVENT_START_END`` (``end-file``) 事件中被设置。除此以外，它返回-1。如果播放列表条目在播放过程中被移除，但播放还没有停止，或正在停止，它也会返回-1。(这至少在状态转换时可能发生）。

    在 "播放" 状态下，这通常与 ``playlist-pos`` 相同，除了在状态转换时，或者如果 ``playlist-current-pos`` 被明确写入。

``playlist-count``
    总的播放列表条目的数量。

``playlist``
    播放列表，当前标记的条目。目前，原始属性值是无用的。

    这有许多子属性。用基于0的播放列表条目索引代替 ``N``

    ``playlist/count``
        播放列表条目的数量（与 ``playlist-count`` 相同）。

    ``playlist/N/filename``
        第N个条目的文件名。

    ``playlist/N/playing``
        如果 ``playlist-playing-pos`` 属性指向此条目，则为 ``yes`` /true，否则为  ``no`` /false或不可用。

    ``playlist/N/current``
        如果 ``playlist-current-pos`` 属性指向此条目，则为 ``yes`` /true，否则为 ``no``/false或不可用。

    ``playlist/N/title``
        第N个条目的名称。只有当播放列表文件包含这样的字段时才可用，并且只有当mpv的分析器支持给定的播放列表格式时才可用。

    ``playlist/N/id``
        这个条目的唯一ID。这是一个自动分配的整数ID，在当前mpv核心实例的整个生命期中是唯一的。其他命令、事件等使用这个作为 ``playlist_entry_id`` 字段。

    当用客户端API使用 ``MPV_FORMAT_NODE`` 查询该属性时，或者用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下。

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each playlist entry)
                "filename"  MPV_FORMAT_STRING
                "current"   MPV_FORMAT_FLAG (might be missing; since mpv 0.7.0)
                "playing"   MPV_FORMAT_FLAG (same)
                "title"     MPV_FORMAT_STRING (optional)
                "id"        MPV_FORMAT_INT64

``track-list``
    音频/视频/子轨道的列表，当前条目被标记。目前，原始属性值是无用的。

    这有许多子属性。用基于0的轨道索引代替 ``N``

    ``track-list/count``
        轨的总数。

    ``track-list/N/id``
        用于 ``-sid``/``--aid``/``--vid`` 的ID。这在同一类型的轨道中是唯一的（子/音频/视频），但在其他方面不是。

    ``track-list/N/type``
        描述媒体类型的字符串。 ``audio``, ``video``, ``sub`` 之一。

    ``track-list/N/src-id``
        源文件中使用的轨道ID。不总是可用的。(如果格式没有本地ID，如果轨道是一个伪轨道，在实际文件中不存在这种方式，或者如果格式由libavformat处理，而格式没有被列入有轨道ID的白名单，它就会丢失。)

    ``track-list/N/title``
        储存在文件中的曲目标题。并非总是可用。

    ``track-list/N/lang``
        文件中标识的曲目语言。不总是可用的。

    ``track-list/N/image``
        如果这是一个由单一图片组成的视频轨道，则为 ``yes`` /true，否则为 ``no`` /false或不可用。用来确定一个流是否是图像的启发式方法并不试图检测通常用于视频的编解码器中的图像。否则，它是可靠的。

    ``track-list/N/albumart``
        如果这是一个嵌入音频文件或外部封面的图像，则为 ``yes`` /true，否则为 ``no`` /false或不可用。

    ``track-list/N/default``
        如果该曲目在文件中设置了默认标志，则为 ``yes`` /true，否则为 ``no`` /false或不可用。

    ``track-list/N/forced``
        如果文件中设置了强制标志，则为 ``yes`` /true，否则为 ``no`` /false或不可用。

    ``track-list/N/codec``
        该轨道使用的编解码器名称，例如 ``h264`` 。在某些罕见情况下不可用。

    ``track-list/N/external``
        如果该轨道是一个外部文件，则为 ``yes`` /true，否则为 ``no`` /false或不可用。这是为独立的字幕文件设置的。

    ``track-list/N/external-filename``
        如果轨道来自外部文件，则为文件名，否则不可用。

    ``track-list/N/selected``
        ``yes`` /true，如果该轨道目前已被解码，``no`` /false或不可用。

    ``track-list/N/main-selection``
        它表示同一类型的轨道的选择顺序。如果一个音轨没有被选中，或被 ``--lavfi-complex`` 选中，它就不可用。对于字幕轨道， ``0`` 代表 ``sid`` ， ``1`` 代表 ``secondary-sid``

    ``track-list/N/ff-index``
        通常由FFmpeg工具使用的流索引。注意，如果使用libavformat（ ``--demuxer=lavf`` ）以外的解复用器，可能会出现错误。对于mkv文件，即使使用默认（内置）的解复用器，索引通常也会匹配，但并不能保证。

    ``track-list/N/decoder-desc``
        如果这个轨道正在被解码，则是人类可读的解码器名称。

    ``track-list/N/demux-w``, ``track-list/N/demux-h``
        容器显示的视频尺寸提示。(不一定准确。)

    ``track-list/N/demux-channel-count``
        容器显示的音频通道数量。(并不总是准确的 - 特别是，音轨可能被解码为不同数量的通道。)

    ``track-list/N/demux-channels``
        容器所指示的通道布局。(不一定准确。)

    ``track-list/N/demux-samplerate``
        容器显示的音频采样率。(不总是准确的。)

    ``track-list/N/demux-fps``
        容器显示的视频FPS。(不总是准确的。)

    ``track-list/N/demux-bitrate``
        音频平均比特率，以每秒比特为单位。(不总是准确的。)

    ``track-list/N/demux-rotation``
        视频顺时针旋转元数据，单位是度。

    ``track-list/N/demux-par``
        像素长宽比。

    ``track-list/N/audio-channels`` (deprecated)
        deprecated的 ``track-list/N/demux-channel-count`` 的别名。

    ``track-list/N/replaygain-track-peak``, ``track-list/N/replaygain-track-gain``
        每条轨道的重播增益值。只适用于源文件中存储有相应信息的音轨。

    ``track-list/N/replaygain-album-peak``, ``track-list/N/replaygain-album-gain``
        每张专辑的重放增益值。如果文件有每个音轨但没有每个专辑的信息，每个专辑的值将从目前的每个音轨的值中复制。在这种情况下，未来的mpv版本有可能使这些属性反而不可用。

    当用客户端API用 ``MPV_FORMAT_NODE`` 查询该属性时，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each track)
                "id"                MPV_FORMAT_INT64
                "type"              MPV_FORMAT_STRING
                "src-id"            MPV_FORMAT_INT64
                "title"             MPV_FORMAT_STRING
                "lang"              MPV_FORMAT_STRING
                "image"             MPV_FORMAT_FLAG
                "albumart"          MPV_FORMAT_FLAG
                "default"           MPV_FORMAT_FLAG
                "forced"            MPV_FORMAT_FLAG
                "selected"          MPV_FORMAT_FLAG
                "main-selection"    MPV_FORMAT_INT64
                "external"          MPV_FORMAT_FLAG
                "external-filename" MPV_FORMAT_STRING
                "codec"             MPV_FORMAT_STRING
                "ff-index"          MPV_FORMAT_INT64
                "decoder-desc"      MPV_FORMAT_STRING
                "demux-w"           MPV_FORMAT_INT64
                "demux-h"           MPV_FORMAT_INT64
                "demux-channel-count" MPV_FORMAT_INT64
                "demux-channels"    MPV_FORMAT_STRING
                "demux-samplerate"  MPV_FORMAT_INT64
                "demux-fps"         MPV_FORMAT_DOUBLE
                "demux-bitrate"     MPV_FORMAT_INT64
                "demux-rotation"    MPV_FORMAT_INT64
                "demux-par"         MPV_FORMAT_DOUBLE
                "audio-channels"    MPV_FORMAT_INT64
                "replaygain-track-peak" MPV_FORMAT_DOUBLE
                "replaygain-track-gain" MPV_FORMAT_DOUBLE
                "replaygain-album-peak" MPV_FORMAT_DOUBLE
                "replaygain-album-gain" MPV_FORMAT_DOUBLE

``current-tracks/...`
    这可以访问当前选择的曲目。它重定向到 ``track-list`` 中的正确条目。

    定义了以下子条目： ``video``, ``audio``, ``sub``, ``sub2``

    例如， ``current-tracks/audio/lang`` 返回当前音轨的语言字段（与 ``track-list/N/lang`` 的值相同）。

    如果通过 ``--lavfi-complex`` 选择了所要求的类型的音轨，将返回第一个。

``chapter-list``
    章节列表，当前条目被标记。目前，原始属性值是无用的。

    这有许多子属性。用基于0的章节索引代替 ``N``

    ``chapter-list/count``
        章节的数量。

    ``chapter-list/N/title``
        存储在文件中的章节标题。不总是可用。

    ``chapter-list/N/time``
        章节开始时间，单位是浮动的秒。

    当用客户端API使用 ``MPV_FORMAT_NODE`` 查询该属性，或用Lua  ``mp.get_property_native`` 查询时，这将返回一个mpv_node，内容如下。

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each chapter)
                "title" MPV_FORMAT_STRING
                "time"  MPV_FORMAT_DOUBLE

``af``, ``vf`` (RW)
    参见 ``--vf``/``--af`` 和 ``vf``/``af`` 命令。

    当用客户端API使用 ``MPV_FORMAT_NODE`` 查询该属性，或用Lua ``mp.get_property_native`` 查询时，这将返回一个mpv_node，内容如下。

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each filter entry)
                "name"      MPV_FORMAT_STRING
                "label"     MPV_FORMAT_STRING [optional]
                "enabled"   MPV_FORMAT_FLAG [optional]
                "params"    MPV_FORMAT_NODE_MAP [optional]
                    "key"   MPV_FORMAT_STRING
                    "value" MPV_FORMAT_STRING

    也可以用这种格式来写属性。

``seekable``
    一般来说是否可以在当前文件中寻找。

``partially-seekable``
    当前文件是否被认为是可寻的，但只是因为缓存是活动的。这意味着小的相对搜索可能是好的，但较大的搜索可能会失败。寻道是否会成功，一般来说是不能事先知道的。

    如果这个属性返回 ``yes`` /true，那么 ``seekable``也会返回。

``playback-abort``
    播放是否已经停止或将要停止。(在不明显的情况下很有用，比如在 ``on_load`` 钩子处理过程中，用户可以停止播放，但脚本必须明确结束处理。)

``cursor-autohide`` (RW)
    参见 ``--cursor-autohide`` 。将此设置为一个新的值将总是更新光标，并重置内部的计时器。

``osd-sym-cc``
    将当前的OSD符号作为不透明的OSD控制代码（cc）插入。这只对 ``show-text`` 命令或设置OSD信息的选项有意义。控制代码是具体实施的，对其他事情没有用处。

``osd-ass-cc``
    ``${osd-ass-cc/0}`` 在OSD中禁止转义ASS序列的文本， ``${osd-ass-cc/1}`` 再次启用。默认情况下，ASS序列被转义以避免意外的格式化，该属性可以禁用这一行为。注意，这些属性会返回一个不透明的OSD控制代码，这只对 ``show-text`` 命令或设置OSD信息的选项有意义。

    .. admonition:: 示例

        - ``--osd-msg3='This is ${osd-ass-cc/0}{\\b1}bold text'``
        - ``show-text "This is ${osd-ass-cc/0}{\\b1}bold text"``

    任何由libass理解的ASS覆盖标签都可以使用。

    注意，你需要转义 ``\`` 字符，因为字符串在传递给OSD代码之前会被处理为C转义序列。详见 `Flat command syntax`_

    标签的列表可以在这里找到： http://docs.aegisub.org/latest/ASS_Tags/

``vo-configured``
    VO现在是否被配置了。通常这与视频窗口是否可见相对应。如果使用了 ``--force-window`` 选项，通常总是返回``yes`` /true。

``vo-passes``
    包含对VO的活动渲染通道及其执行时间的反省。不是所有的虚拟机都能实现。

    这被进一步细分为两种帧类型， ``vo-passes/fresh`` 用于新鲜的帧（必须被上传、缩放等）， ``vo-passes/redraw`` 用于重新绘制的帧（只需要重新绘制）。任何给定的子类型的通过次数可以从一帧到另一帧发生变化，因此不应依赖。

    每个框架类型都有一些进一步的子属性。用框架类型代替 ``TYPE`` ， ``N`` 代替基于0的通过指数， ``M`` 代替基于0的采样指数。

    ``vo-passes/TYPE/count``
        通过的数量。

    ``vo-passes/TYPE/N/desc``
        通行证的人性化描述。

    ``vo-passes/TYPE/N/last``
        最后测量的执行时间，以纳秒为单位。

    ``vo-passes/TYPE/N/avg``
        该通道的平均执行时间，单位是纳秒。确切的时间范围是不同的，但一般应该是几秒钟。

    ``vo-passes/TYPE/N/peak``
        这个平均范围内的峰值执行时间（最高值），以纳秒为单位。

    ``vo-passes/TYPE/N/count``
        这个通道的样本数。

    ``vo-passes/TYPE/N/samples/M``
        该通道的特定样本的原始执行时间，以纳秒为单位。

    当用客户端API使用 ``MPV_FORMAT_NODE`` 查询该属性时，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下。

    ::

        MPV_FORMAT_NODE_MAP
        "TYPE" MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP
                "desc"    MPV_FORMAT_STRING
                "last"    MPV_FORMAT_INT64
                "avg"     MPV_FORMAT_INT64
                "peak"    MPV_FORMAT_INT64
                "count"   MPV_FORMAT_INT64
                "samples" MPV_FORMAT_NODE_ARRAY
                     MP_FORMAT_INT64

    注意，不支持通过子键直接访问这个结构，唯一的访问方式是通过前面提到的 ``MPV_FORMAT_NODE``

``perf-info``
    进一步的性能数据。查询这个属性会触发一些数据的内部收集，可能会拖慢播放器。每次查询都会重置一些内部状态。属性变化通知没有也不会起作用。所有这些都可能在未来改变，所以不要使用这个。内置的 ``stats`` 脚本应该是唯一的用户；因为它是和源代码捆绑在一起的，它可以使用mpv内部的知识来正确渲染信息。一些细节见 ``stats`` 脚本描述。

``video-bitrate``, ``audio-bitrate``, ``sub-bitrate``
    在数据包层面上计算的比特率值。它的工作原理是将两个关键帧之间的所有数据包的比特大小除以它们的演示时间戳距离。(这使用时间戳存储在文件中，所以例如播放速度不会影响返回值)。特别是，视频比特率将只在每个关键帧更新，并显示 "past" 的比特率。为了使该属性对用户界面更友好，对这些属性的更新会以某种方式进行节制。

    单位是比特/秒。OSD格式将这些值变成千比特（或兆比特，如果合适的话），这可以通过使用原始属性值来防止，例如，用 ``${=video-bitrate}``

    请注意，这些属性的准确性受到一些因素的影响。如果底层的解复用器在解复用时重写了数据包（对某些文件格式做了重写），比特率可能略有偏差。如果时间戳不好或抖动（如在Matroska中），即使是恒定的比特率流也可能显示波动的比特率。

    这些值到底是如何计算的，将来可能会改变。

    在mpv的早期版本中，这些属性使用一个完全不同的方法返回一个静态（但不好）的猜测。

``packet-video-bitrate``, ``packet-audio-bitrate``, ``packet-sub-bitrate``
    ``video-bitrate``, ``audio-bitrate``, ``sub-bitrate`` 的旧的和deprecated的属性。它们的行为完全相同，但返回的是以千比特为单位的值。另外，它们没有任何OSD格式，尽管同样可以用例如 ``${=video-bitrate}`` 来实现。

    这些属性不应该再被使用。

``audio-device-list``
    已发现的音频设备的列表。这主要是用于客户端API，并反映了命令行播放器的``--audio-device=help`` 返回的内容。

    当用客户端API查询属性时，使用 ``MPV_FORMAT_NODE`` ，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下。

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each device entry)
                "name"          MPV_FORMAT_STRING
                "description"   MPV_FORMAT_STRING

    ``name`` 是要传递给 ``--audio-device`` 选项的东西（通常是一个相当神秘的音频API特定ID），而 ``description`` 是人类可读的自由格式文本。如果没有描述，或者描述本来就是一个空字符串，那么描述将被设置为设备名称（减去mpv特有的 ``<driver>/`` 前缀）。

    名称设置为 ``auto`` 的特殊条目选择默认的音频输出驱动和默认设备。

    该属性可以通过客户端API和Lua脚本中的属性观察机制进行观察。(从技术上讲，在第一次读取这个属性时就会启用变化通知)。

``audio-device`` (RW)
    设置音频设备。这直接读/写 ``--audio-device`` 选项，但在写访问时，音频输出将被安排重新加载。

    在没有音频输出的情况下写这个属性，不会自动启用音频。(在以前写访问 ``audio-device`` 后，由于重新初始化失败而禁用音频的情况下也是如此)。

    这个属性也不会告诉你哪个音频设备在实际使用中。

    这些细节的处理方式在未来可能会改变。

``current-vo``
    当前的视频输出驱动（与 ``--vo`` 一起使用的名称）。

``current-ao``
    当前的音频输出驱动（名称与 ``--ao`` 一起使用）。

``shared-script-properties`` (RW)
    这是一个任意字符串的键/值映射，在脚本之间共享，供一般使用。播放器本身不使用其中的任何数据（尽管一些内置脚本可能会）。该属性在玩家重新启动时不会被保留。

    这是非常原始的，低效的，而且使用起来很烦人。这是一个临时的解决方案，随时可能消失（例如，当一个更好的解决方案出现时）。这也是为什么这个属性有一个令人讨厌的名字。你应该避免使用它，除非你绝对需要。

    Lua脚本有以 ``utils.shared_script_property_`` 开头的辅助工具。它们是没有文档的，因为你不应该使用这个属性。如果你仍然认为你必须使用，你应该使用帮助器而不是直接使用这个属性。

    你应该使用 ``change-list`` 命令来修改内容。如果两个脚本同时更新不同的键，由于缺乏同步性，手动读取、修改和写入属性可能会造成数据丢失。Lua帮助器可以解决这个问题。

    (如果两个脚本试图同时更新同一个键，则没有办法确保同步性)。

``working-directory``
    mpv进程的工作目录。对JSON IPC用户可能有用，因为命令行播放器通常使用相对路径。

``protocol-list``
    可能被播放器识别的协议前缀列表。它们被返回，没有尾部的 ``://`` 后缀（仍然总是需要）。在某些情况下，协议实际上是不被支持的（如果ffmpeg在编译时不支持TLS，可以考虑 ``https`` ）。

``decoder-list``
    支持的解码器的列表。这列出了可以传递给 ``--vd`` 和 ``--ad`` 的解码器。

    ``codec``
        典型的编解码器名称，用于识别解码器可以处理的格式。

    ``driver``
        解码器本身的名称。通常，这与 ``codec`` 相同。有时它可能不同。它用于区分同一编解码器的多个解码器。

    ``description``
        解码器和编解码器的可读描述。

    当用客户端API用 ``MPV_FORMAT_NODE`` 查询该属性，或用Lua ``mp.get_property_native`` 查询时，这将返回一个mpv_node，内容如下。

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each decoder entry)
                "codec"         MPV_FORMAT_STRING
                "driver"        MPV_FORMAT_STRING
                "description"   MPV_FORMAT_STRING

``encoder-list``
    libavcodec编码器的列表。这与 ``decoder-list`` 的格式相同。编码器名称（"driver"条目）可以传递给 ``--ovc`` 和 ``--oac`` （没有 ``--vd`` 和 ``--ad`` 要求的 ``lavc:`` 前缀）。

``demuxer-lavf-list``
    可用的libavformat demuxers名称的列表。这可以用来检查对特定格式的支持或与 ``--demuxer-lavf-format`` 一起使用。

``input-key-list``
    `Key names`_ 列表，与 ``--input-keylist`` 的输出相同。

``mpv-version``
    mpv版本/版权字符串。根据二进制文件的构建方式，它可能包含一个发布版本，或者只是一个git哈希值。

``mpv-configuration``
    传递给构建系统的配置参数（通常是调用 ``./waf configure ...`` 的方式）。

``ffmpeg-version``
    ``av_version_info()`` API调用的内容。这是一个以某种方式标识构建的字符串，可以是发布版本号，也可以是git哈希值。这也适用于Libav (这个属性的名字还是一样的。)如果mpv与较早的FFmpeg和Libav版本链接，这个属性就不可用。

``libass-version``
    ``ass_library_version()`` 的值。这是一个整数，以有点奇怪的形式编码（显然是 "hex BCD"），表示链接到mpv的libass库的发布版本。

``options/<name>`` (RW)
    选项 ``--<name>`` 的值。大多数选项可以在运行时通过写到这个属性来改变。请注意，许多选项需要重新加载文件以使更改生效。如果有同等的属性，最好设置该属性。

    应该没有任何理由访问 ``options/<name>`` 而不是 ``<name>`` ，除非这些属性有不同的行为或冲突的语义。

``file-local-options/<name>`` (RW)
    类似于 ``options/<name>`` ，但是当通过该属性设置一个选项时，一旦当前文件停止播放，该选项将被重置为旧值。当没有文件正在播放（或正在加载）时，试图写入一个选项会导致错误。

    (注意，如果一个选项被标记为文件本地，即使是 ``options/`` 也会访问本地值，而 ``old`` 值将在播放结束时被恢复，在播放结束前不能读或写。)

``option-info/<name>``
    每个选项的额外信息。

    这有许多子属性。用顶层选项的名称替换 ``<name>`` 。不保证这些子属性的稳定性 - 它们可能在功能中发生根本性变化。

    ``option-info/<name>/name``
        选项的名称。

    ``option-info/<name>/type``
        选项类型的名称，如 ``String`` 或 ``Integer`` 。对于许多复杂的类型，这并不是很准确。

    ``option-info/<name>/set-from-commandline``
        该选项是否从mpv命令行设置。如果选项在运行时被改变，这个选项将被设置为什么，是未定义的（意味着它可能在将来改变）。

    ``option-info/<name>/set-locally``
        该选项是否按文件设置。自动加载的配置文件、文件-目录配置和其他情况都是如此。这意味着当播放结束时，选项的值将被恢复到播放开始前的值。

    ``option-info/<name>/default-value``
        该选项的默认值。可能不总是可用。

    ``option-info/<name>/min``, ``option-info/<name>/max``
        选项允许的最小和最大整数值。只有在选项是数字的情况下才可用，并且最小/最大值已在内部设置。也有可能只设置了其中一个。

    ``option-info/<name>/choices``
        如果该选项是一个选择选项，可能的选择。整数的选择可能包括也可能不包括（它们可以由 ``min`` 和 ``max`` 暗示）。请注意，那些表现得像选项的选项，但内部不是实际的选项，可能没有这个信息。

``property-list``
    顶层属性的列表。

``profile-list``
    profile和其内容的列表。这是非常具体的实现，并可能随时改变。目前，它为每个profile返回一个选项数组。每个选项有一个名称和一个值，目前值总是一个字符串。请注意，选项数组不是一个地图，因为顺序很重要，有可能出现重复的条目。递归的profile不被展开，并显示为特殊的 ``profile`` 选项。

``command-list``
    输入命令的列表。这将返回一个地图数组，其中每个地图节点代表一个命令。这个地图目前只有一个条目。 ``name`` 代表命令的名称。(这个属性应该是对 ``--input-cmdlist`` 的替代。该选项转储了一些更多的信息，但如果需要的话，扩展这个属性是一个有效的功能请求）。

``input-bindings``
    当前输入键绑定的列表。这将返回一个数组，其中每个地图节点代表一个单一的键/命令的绑定。这个地图有以下条目。

    ``key``
        键的名称。这是标准化的，可能与源文件中的指定方式略有不同（例如，在input.conf中）。

    ``cmd``
        映射到键上的命令。(目前，这与源文件中指定的字符串完全相同，只是删除了空白和注释。将来有可能被规范化）。

    ``is_weak``
        如果设置为 yes，任何现有的和活跃的用户绑定将被优先考虑。

    ``owner``
        如果此条目存在，则是添加此绑定的脚本（或类似）的名称。

    ``section``
        这个绑定属于哪个部分的名称。这是一个很少使用的机制。这个条目可能会被删除或在将来改变含义。

    ``priority``
        一个数字。数值高的绑定比数值低的绑定优先。如果该值为负数，这个绑定是不活跃的，不会被输入触发。注意，mpv内部不使用这个值，在某些情况下，绑定的匹配工作可能略有不同。此外，这个值是动态的，可以在运行时改变。

    ``comment``
        如果有的话，在同一行的命令后面的注释。(例如，input.conf条目 ``f cycle bla # toggle bla`` 会产生一个条目 ``comment = "toggle bla", cmd = "cycle bla"`` ）

    这个属性是只读的，不支持更改通知。目前，除了脚本添加或删除自己的绑定外，没有任何机制可以在运行时改变键绑定。

Inconsistencies between options and properties
----------------------------------------------

你可以把（几乎）所有的选项作为属性来访问，尽管有些属性有一些注意事项（由于历史原因）。

``vid``, ``aid``, ``sid``
    当播放处于活动状态时，这些属性返回实际活动的轨道。例如，如果你设置了 ``aid=5`` ，而当前播放的文件不包含ID为5的音轨， ``aid`` 属性将返回 ``no``

    在mpv 0.31.0之前，你只能在运行时设置现有音轨。

``display-fps``
    这种不一致的行为已deprecated。弃用后，报告值和选项值被干净地分开（选项值为 ``overrid-display-fps`` ）。

``vf``, ``af``
    如果你在播放过程中设置了这些属性，而过滤器链未能重新初始化，选项将被设置，但运行时的过滤器链不会改变。另一方面，下一个要播放的视频会失败，因为初始的过滤链不能被创建。

    这种行为在mpv 0.31.0中有所改变。在此之前，新的值被拒绝*iff*一个视频（对于 ``vf`` ）或一个音频（对于 ``af`` ）轨道是活动的。如果播放没有激活，行为与当前相同。

``playlist``
    该属性是只读的，返回当前的内部播放列表。该选项是为了在命令行解析时加载播放列表。对于客户端API的使用，你应该使用 ``loadlist`` 命令代替。

``profile``, ``include``
    这些都是只写的，并将执行被写入的动作，就像在mpv CLI命令行上使用一样。它们唯一的用途是在 ``mpv_initialize()`` 之前使用libmpv，而这可能只在编码模式下有用。普通的libmpv用户应该使用其他机制，比如 ``apply-profile`` 命令，以及 ``mpv_load_config_file`` API函数。避免使用这些属性。

Property Expansion
------------------

所有输入命令的字符串参数以及某些选项（如 ``--term-playing-msg`` ）都要进行属性扩展。需要注意的是，属性扩展在一些地方不起作用，例如，数字参数被期待。(例如， ``add`` 命令不做属性扩展。 ``set`` 命令是一个例外，而不是一般规则）。

.. admonition:: input.conf的示例

    ``i show-text "Filename: ${filename}"``
        当按下 ``i`` 键时显示当前文件的文件名。

属性扩展是否默认启用取决于使用哪种API（见 `Flat command syntax`_ `Commands specified as arrays`_ `Named arguments`_），但它总是可以用  ``expand-properties`` 前缀启用，或用 ``raw`` 前缀禁用，如 `Input Command Prefixes`_ 所述。

支持以下扩展：

``${NAME}``
    展开到属性 ``NAME`` 的值。如果检索该属性失败，则扩展为错误字符串。(使用 ``${NAME:}`` 带尾巴的 ``:`` 来扩展到一个空字符串)。如果 ``NAME`` 前缀为 ``=`` ，则展开为该属性的原始值（见下文）。
``${NAME:STR}``
    展开到属性 ``NAME`` 的值，如果不能检索到该属性，则展开到 ``STR`` 。 ``STR`` 是递归展开的。
``${?NAME:STR}``
    如果有 ``NAME`` 属性，则扩展到 ``STR`` （递归）。
``${!NAME:STR}``
    如果不能检索到 ``NAME`` 属性，则扩展为 ``STR`` （递归）。
``${?NAME==VALUE:STR}``
    如果属性 ``NAME`` 扩展为等于 ``VALUE`` 的字符串，则扩展为 ``STR`` (递归)。你可以在 ``NAME`` 前加上 ``=`` ，以便比较一个属性的原始值（见下文）。如果该属性不可用，或者在检索时发生其他错误，该值永远不会被视为相等。注意， ``VALUE`` 不能包含任何字符 ``:`` 或 ``}`` 。另外，如果有需要，将来可能会增加用 ``"`` 或 ``%`` 的转义功能。
``${!NAME==VALUE:STR}``
    与 ``?`` 变体相同，但是如果值不相等， ``STR`` 将被展开。(使用与 ``?`` 相同的语义)。
``$$``
    展开为 ``$``
``$}``
    展开为 ``}`` 。(要在递归扩展中产生这个字符。)
``$>``
    禁用属性扩展和对字符串其余部分的 ``$`` 的特殊处理。

在允许属性扩展的地方，通常也接受C-style转义。例如。

    - ``\n`` 成为一个换行符
    - ``\\`` 扩展为 ``\``

Raw and Formatted Properties
----------------------------

通常情况下，属性被格式化为人类可读的文本，旨在显示在OSD或终端上。通过在属性名称前加上 ``=`` ，可以从一个属性中获取未格式化的（原始）值。这些原始值可以被其他程序解析，并遵循与属性相关的选项相同的惯例。

.. admonition:: 示例

    - ``${time-pos}`` 扩展到 ``00:14:23`` （如果播放位置在14分23秒）
    - ``${=time-pos}``扩展为 ``863.4`` （同样的时间，加上400毫秒--毫秒通常不显示在格式化的情况下）

有时，原始属性值和格式化属性值所携带的信息量的差异可能相当大。在某些情况下，原始值有更多的信息，比如比秒更精确的 ``time-pos`` 。有时情况正好相反，例如 ``aid`` 在格式化的情况下显示音轨标题和语言，但如果是原始值，则只显示音轨号码。
