OPTIONS
=======

Track Selection
---------------

``--alang=<languagecode[,languagecode,...]>``
    指定要使用的音频语言的优先列表。不同的容器格式采用不同的语言编码。DVD使用ISO 639-1两个字母的语言编码，Matroska、MPEG-TS和NUT使用ISO 639-2三个字母的语言编码，而OGM使用自由格式的标识符。也请看``--aid``

    这是一个字符串列表选项。详见 `List Options`_

    .. admonition:: 示例

        - ``mpv dvd://1 --alang=hu,en`` 在DVD上选择匈牙利语轨道，如果没有匈牙利语，则回到英语。
        - ``mpv --alang=jpn example.mkv``播放日语音频的Matroska文件。

``--slang=<languagecode[,languagecode,...]>``
    指定一个优先使用的字幕语言列表。不同的容器格式采用不同的语言编码。DVD使用ISO 639-1两个字母的语言编码，Matroska使用ISO 639-2三个字母的语言编码，而OGM使用自由格式的标识符。也请看 ``--sid``

    这是一个字符串列表选项。详见 `List Options`_

    .. admonition:: 示例

        - ``mpv dvd://1 --slang=hu,en`` 选择DVD上的匈牙利语字幕轨，如果没有匈牙利语，则返回到英语。
        - ``mpv --slang=jpn example.mkv``播放带有日文字幕的Matroska文件。

``--vlang=<...>``
    相当于 ``--alang`` 和 ``--slang`` ，用于视频轨道。

    这是一个字符串列表选项。详见 `List Options`_

``--aid=<ID|auto|no>``
    选择音轨。 ``auto`` 选择默认值， ``no`` 禁用音频。See also ``--alang``. mpv通常在开始播放文件时在终端打印出可用的音轨。

    ``--audio`` 是 ``--aid`` 的别名。

    ``--aid=no`` 或 ``--audio=no`` 或 ``--no-audio`` 禁止音频播放。(后一种变体在客户端API中不起作用)。

    .. note::

        音轨选择选项（ ``--aid`` 但也包括 ``--sid`` 和其他选项）有时会暴露出可能出现的奇怪行为。而且，这种行为往往随着每个mpv版本的发布而改变。

        轨道选择属性将返回播放之外的选项值（如预期），但在播放过程中，影响性的轨道选择被返回。例如，在 ``--aid=auto`` 的情况下， ``aid`` 属性会在播放初始化后突然返回 ``2`` （假设文件至少有2个音轨，而且第二个是默认的）。

        在mpv0.32.0（和之前的一些版本），如果你传递的音轨值不存在对应的音轨（例如 ``--aid=2`` ，只有一个音轨）， ``aid`` 属性会返回 ``no`` 。然而，如果在播放过程中增加了另一个音轨，你试图将 ``aid`` 属性设置为 ``2`` ，什么也不会发生，因为 ``aid`` 选项的值仍然是 ``2`` ，而写入相同的值是没有效果的。

        在mpv0.33.0中，这个行为被改变了。现在轨道选择选项在播放初始化时被重置为`自动'，如果该选项试图选择一个不存在的轨道。如果轨道存在，但未能初始化，也会这样做。其后果是，与mpv0.33.0之前不同，用户的轨道选择参数在某些情况下被忽略了。

        另外，从mpv0.33.0开始，试图通过数字来选择一个轨道将严格选择这个轨道。在这个变化之前，试图选择一个不存在的轨道，在播放初始化时，会退回到轨道默认选择。新的行为更加一致。

        在运行时设置一个轨道选择属性，然后播放一个新文件，如果新文件的轨道列表的指纹不同，可能会将轨道选择重置为默认值。

        要注意上述所有的棘手组合：例如， ``mpv --aid=2 file_with_2_audio_tracks.mkv file_with_1_audio_track.mkv`` 会先播放正确的轨道，而第二个文件没有音频。如果你再回头看第一个文件，它的第一个音轨将被播放，而第二个文件则被播放了音频。如果你再做同样的事情，但不是使用 ``--aid=2`` ，而是在文件播放时运行 ``set aid 2`` ，那么换到第二个文件将播放它的音轨。这是因为运行时选择启用了指纹启发式。

        最有可能的是这不是终点。

``--sid=<ID|auto|no>``
    显示由 ``<ID>`` 指定的字幕流。 ``auto`` 选择默认， ``no`` 禁用字幕。

    ``--sub`` 是 ``--sid`` 的别名。

    ``--sid=no`` 或 ``--sub=no`` 或 ``--no-sub`` 禁用字幕解码。(后一种变体在客户端API中不起作用)。

``--vid=<ID|auto|no>``
    选择视频频道。 ``auto`` 选择默认， ``no`` 禁用视频。

    ``--video`` 是 ``--vid`` 的一个别名。

    ``--vid=no`` 或 ``--video=no`` 或 ``--no-video`` 禁用视频播放。(后一种变体在客户端API中不起作用)。

    如果视频被禁用，mpv将尝试下载音频，只有当媒体是用youtube-dl串流时，因为这样可以节省带宽。这是通过在ytdl_hook.lua脚本中将ytdl_format设置为 "bestaudio/best" 来实现的。

``--edition=<ID|auto>``
    (仅Matroska文件) 指定要使用的版本（章节集），其中0是第一个。如果设置为 ``auto`` (默认值)，mpv将选择被声明为默认的第一个版本，如果没有默认值，则选择定义的第一个版本。

``--track-auto-selection=<yes|no>``
    启用默认的曲目自动选择（默认：yes）。启用它将使播放器根据 ``--aid``, ``--alang`` 和其他选择流。如果它被禁用，则不会选择任何曲目。此外，如果没有选择曲目，播放器将不会退出，而是等待（这种等待模式类似于暂停，但没有设置暂停选项）。

    这对 ``--lavfi-complex`` 很有用：你可以在这种模式下开始播放，然后在运行时通过设置过滤图来设置选择轨道。注意，如果 ``--lavfi-complex`` 在播放开始前被设置，被引用的轨道总是被选中的。

``--subs-with-matching-audio=<yes|no>``
    当自动选择字幕轨时，即使所选的音频流与你喜欢的字幕语言相匹配，也会选择一个非强制的字幕轨（默认：yes）。如果你想只为外国音频或屏幕上的文字显示字幕，请禁用此功能。


Playback Control
----------------

``--start=<relative time>``
    寻找到给定的时间位置。

    时间的一般格式是 ``[+|-][[hh:]mm:]ss[.ms]`` 。如果时间的前缀是 ``-`` ，则时间被认为是相对于文件的末尾而言的（由解扰器/文件发出信号）。 ``+`` 通常会被忽略（但见下文）。

    以下是可识别的替代时间规格：

    ``pp%`` 寻求百分比位置pp（0-100）。

    ``#c`` 寻求到章节编号c. (章节从1开始。)

    ``none`` 重置任何先前设置的选项（对libmpv有用）。

    如果给了 ``--rebase-start-time=no`` ，那么在时间前加上 ``+`` ，使时间相对于文件的起始时间。没有前缀的时间戳被认为是绝对时间，也就是说，应该寻找到文件中包含时间戳的帧。作为一个错误，但也是一个隐藏的功能，在 ``+`` 或 ``-`` 前放1个或多个空格总是将时间解释为绝对时间，这可以用来寻求负的时间戳（最多用于调试）。

    .. admonition:: 示例

        ``--start=+56``, ``--start=00:56``
            查询到开始时间+56秒。
        ``--start=-56``, ``--start=-00:56``
            查询到结束时间-56秒。
        ``--start=01:10:00``
            查询到1小时10分。
        ``--start=50%``
            查询到文件的中间部分。
        ``--start=30 --end=40``
            查询到30秒，播放10秒，然后退出。
        ``--start=-3:20 --length=10``
            查询到文件结束前的3分20秒，播放10秒，然后退出。
        ``--start='#2' --end='#4'``
            播放第2章和第3章，然后退出。

``--end=<relative time>``
    在给定的时间停止。如果时间是相对于 ``--start`` 的，则使用 ``--length`` 。有效的选项值和例子见 ``--start``

``--length=<relative time>``
    在相对于开始时间的一个给定时间后停止。有效的选项值和例子见 ``--start``

    如果同时提供了 ``--end`` 和 ``--length`` ，播放将在到达两个端点中的任何一个时停止。

    隐蔽性说明：如果 ``--rebase-start-time=no`` ，并且指定的时间不是 "绝对 "时间，如 ``--start`` 选项描述中定义的那样，则不能正确工作。

``--rebase-start-time=<yes|no>``
    是否将文件的开始时间移到 ``00:00:00`` （默认：yes）。这对于以随机时间戳开始的文件来说不那么突兀，比如传输流。另一方面，如果有时间戳重置，产生的行为可能相当奇怪。出于这个原因，如果你真的对真实的时间戳感兴趣，可以用 ``no`` 来禁用这种行为。

``--speed=<0.01-100>``
    按参数给定的系数减慢或加快播放速度。

    如果使用了 ``--audio-pitch-correction`` （默认打开），以高于正常速度播放会自动插入 ``scaletempo2`` 音频过滤器。

``--pause``
    在暂停状态下启动播放器。

``--shuffle``
    以随机顺序播放文件。

``--playlist-start=<auto|index>``
    设置从内部播放列表的哪个文件开始播放。索引是一个整数，0表示第一个文件。值 ``auto`` 意味着选择要播放的条目是留给播放恢复机制的（默认）。如果一个具有给定索引的条目不存在，行为是未指定的，在未来的mpv版本中可能会改变。如果播放列表包含更多的播放列表，也是同样的情况（不要期待任何合理的行为）。不过，把播放列表文件传给mpv应该可以用这个选项。例如， ``mpv playlist.m3u --playlist-start=123`` 将按预期工作，只要 ``playlist.m3u`` 不链接到其他播放列表。

    值 ``no`` 是 ``auto`` 的一个deprecated的别名。

``--playlist=<filename>``
    根据一个播放列表文件播放文件。支持一些常见的格式。如果没有检测到格式，它将被视为文件列表，用换行符分开。你可能需要这个选项来加载纯文本文件作为播放列表。注意，不支持XML播放列表格式。

    这个选项强迫 ``--demuxer=playlist`` 来解释播放列表文件。一些播放列表格式，特别是CUE和光盘格式，需要使用不同的解扰器，不能使用这个选项。它们仍然可以直接播放，不需要使用这个选项。

    你可以直接播放播放列表，不需要这个选项。在mpv0.31.0版本之前，这个选项禁用了任何可能存在的安全机制，但从0.31.0开始，它使用与直接播放播放列表文件相同的安全机制。如果你信任播放列表文件，你可以用 ``--load-unsafe-playlists`` 禁用任何安全检查。因为播放列表可以加载其他播放列表条目，考虑只对播放列表本身而不是其条目应用这个选项，使用类似的方法。

        ``mpv --{ --playlist=filename --load-unsafe-playlists --}``

    .. warning::

        旧版本的mpv通过 ``--playlist`` 播放播放列表文件的方式对恶意构建的文件不安全。这样的文件可能引发有害的行为。在0.31.0之前的所有mpv版本和所有MPlayer版本都是如此，但不幸的是，这个事实在早期没有得到很好的记录，有些人甚至错误地推荐使用 ``--playlist`` ，使用不值得信任的来源。如果你不确定你的mpv至少是0.31.0，请不要用 ``--playlist`` 与随机的互联网来源或你不信任的文件。

        特别是，播放列表可以包含使用本地文件以外的协议的条目，例如像 ``avdevice://`` 这样的特殊协议（这本身就不安全）。

``--chapter-merge-threshold=<number>``
    合并几乎连续的有序章节部分的阈值，以毫秒为单位（默认：100）。一些具有有序章节的Matroska文件有不准确的章节结束时间戳，导致一个章节的结束和下一个章节的开始之间有一个小间隙，而它们应该是匹配的。如果一个播放部分的结束与下一个部分的开始之间的距离小于给定的阈值，那么就在章节的变化上继续正常播放视频，而不是做一个搜索。

``--chapter-seek-threshold=<seconds>``
    从一章开始到后退一章的距离，在这个距离内，后退一章将进入前一章（默认：5.0）。超过这个阈值，向后寻章将转到当前章节的开头。一个负值意味着总是回到前一章。

``--hr-seek=<no|absolute|yes|default>``
    选择何时使用不限于关键帧的精确搜索。这种搜索需要从上一个关键帧到目标位置的视频解码，因此可能需要一些时间，取决于解码性能。对于某些视频格式，精确寻像被禁用。这个选项选择了用于搜索的默认选择；在定义键绑定和输入命令时，可以明确地覆盖该默认值。

    :no:       从不使用精确寻址。
    :absolute: 如果在文件中寻找一个绝对位置，如章节寻找，则使用精确寻找，但不使用相对寻找，如方向键的默认行为（默认）。
    :default:  和 ``absolute`` 一样，但在仅有音频的情况下启用hr-seeks。具体的行为是具体实施的，可能会随着新版本的发布而改变。
    :yes:      尽可能使用精确搜索。
    :always:   与 ``yes`` 相同（为了兼容）。

``--hr-seek-demuxer-offset=<seconds>``
    这个选项的存在是为了解决由于某些文件格式的解复用器的错误或限制而导致的精确寻址失败（如 ``--hr-seek`` ）。有些解复用器不能在给定的目标位置之前寻找关键帧，而是去寻找一个较晚的位置。这个选项的值将从给定的解复用器的时间戳中减去。因此，如果你把这个选项设置为1.5，并试图做一个精确到60秒的寻像，解复用器被告知要寻像到时间58.5，这希望能减少它错误地寻像到比60秒晚的某个时间的机会。设置这个选项的坏处是，精确搜索的速度会变慢，因为早期的解复用器位置和真正的目标之间的视频可能被不必要地解码。

``--hr-seek-framedrop=<yes|no>``
    允许视频解码器在寻找过程中丢弃帧，如果这些帧在寻找目标之前。如果启用这个功能，精确搜索会更快，但如果你使用修改时间戳或添加新帧的视频过滤器，会导致精确搜索跳过目标帧。例如，当启用去隔行扫描时，这可能会破坏帧的反步法。

    默认： ``yes``

``--index=<mode>``
    控制如何在文件中寻找。请注意，如果文件中缺少索引，默认情况下将在飞行中建立，所以你不需要改变这个。但它可能对一些破碎的文件有帮助。

    :default:   如果文件有索引，就使用一个索引，如果缺失，就建立索引
    :recreate:  不读取或使用该文件的索引

    .. note::

        这个选项只有在底层媒体支持寻址的情况下才有效（即不使用stdin、pipe等）。

``--load-unsafe-playlists``
    从播放列表中加载被认为不安全的URL（默认：否）。这包括特殊协议和任何不指向正常文件的东西。另一方面，本地文件和HTTP链接总是被认为是安全的。

    此外，如果在设置时加载了一个播放列表，添加的播放列表条目不会被标记为来自网络或潜在的不安全位置。(相反，其行为就像播放列表条目直接提供给mpv命令行或 ``loadfile`` 命令一样）。

``--access-references=<yes|no>``
    遵循正在打开的文件中的任何引用（默认：yes）。如果文件被自动扫描，禁用这个功能是有帮助的（例如，缩略图生成）。例如，如果缩略图扫描器遇到一个包含网络URL的播放列表文件，而扫描器不应该打开这些文件，启用这个选项就可以防止它。这个选项还可以禁止有序的章节，mov参考文件，打开档案，以及其他一些功能。

    在旧的FFmpeg版本上，这在某些情况下将无法工作。一些FFmpeg解扰器可能不尊重这个选项。

    这个选项并不妨碍打开成对的字幕文件等。使用 ``--autoload-files=no`` 来防止这个。

    如果你打开非文件，该选项并不总是有效（例如，使用 ``dvd://directory`` 会打开指定目录下的一大堆文件）。如果文件名不是以 ``./`` 开头，就用 ``/`` 作为前缀，可以避免这种情况。

``--loop-playlist=<N|inf|force|no>``, ``--loop-playlist``
    循环播放 ``N`` 次。值为 ``1`` 时播放一次（默认）， ``2`` 时播放两次，等等。 ``inf`` 意味着永远。 ``no`` 与 ``1`` 相同，禁止循环播放。如果在命令行上指定了几个文件，整个播放列表将被循环播放。 ``--loop-playlist`` 与 ``--loop-playlist=inf`` 相同。

   ``force`` 模式与 ``inf`` 相同，但不会跳过已被标记为失败的播放列表条目。这意味着播放器可能会浪费CPU时间，试图循环播放一个不存在的文件。但它对在非常糟糕的网络条件下播放网络广播可能是有用的。

``--loop-file=<N|inf|no>``, ``--loop=<N|inf|no>``
    循环一个文件N次。 ``inf`` 表示永远， ``no`` 表示正常播放。为了兼容， ``--loop-file`` 和 ``--loop-file=yes`` 也被接受，并且与 ``--loop-file=inf`` 相同。

    与 ``--loop-playlist`` 的区别是，它不循环播放列表，只是文件本身。如果播放列表只包含一个文件，这两个选项的区别是，这个选项在循环中执行寻道，而不是重新加载文件。

    .. note::

        ``--loop-file`` 计算的是使播放器寻找文件开头的次数，而不是完全播放的次数。这意味着 ``--loop-file=1`` 最终会播放该文件两次。与 ``--loop-playlist`` 对比，它计算完整播放的次数。

    ``--loop`` 是这个选项的一个别名。

``--ab-loop-a=<time>``, ``--ab-loop-b=<time>``
    设置循环点。如果播放通过了 ``b`` 的时间戳，它将寻求到 ``a`` 的时间戳。超过 ``b`` 点的寻找不会循环（这是故意的）。

    如果 ``a`` 在 ``b`` 之后，行为就像按正确顺序给出的点一样，玩家将在穿过 ``a`` 后寻找到 ``b`` 。这与旧的行为不同，旧的行为是禁止循环的（作为一个错误，在文件的末端循环到 ``a`` ）。

    如果任何一个选项被设置为 ``no`` （或未设置），循环被禁用。这与以前的行为不同，以前未设置的 ``a`` 意味着文件的开始，而未设置的 ``b`` 意味着文件的结束。

    循环点可以在运行时通过相应的属性来调整。参见 ``ab-loop`` 命令。

``--ab-loop-count=<N|inf>``
    只运行A-B循环N次，然后忽略A-B循环点（默认：inf）。每完成一次循环迭代，该选项将递减1（除非它被设置为 ``inf`` 或0）。 ``inf`` 意味着循环会一直进行下去。如果这个选项被设置为0，A-B循环将被忽略，甚至 ``ab-loop`` 命令也不会再次启用循环（如果两个循环点都被设置，但 ``ab-loop-count`` 为0，该命令将在OSD信息中显示 ``(disabled)`` ）。

``--ordered-chapters``, ``--no-ordered-chapters``
    默认启用。停用对Matroska有序章节的支持。mpv不会加载或搜索其他文件的视频片段，也会忽略为主文件指定的任何章节顺序。

``--ordered-chapters-files=<playlist-file>``
    将给定的文件作为播放列表加载，并在打开使用有序章节的Matroska文件时，尝试使用其中包含的文件作为参考文件。这推翻了通过扫描主文件所在的同一目录加载参考文件的正常机制。

    对于加载不在本地文件系统上的有序章节文件，或如果被引用的文件在不同的目录中，这很有用。

    注意：播放列表可以是一个简单的文本文件，包含用换行符分隔的文件名。

``--chapters-file=<filename>``
    从这个文件加载章节，而不是使用主文件中的章节元数据。

    这可以接受一个媒体文件（如mkv）或甚至一个伪格式（如ffmetadata），并使用其章节来替换当前文件的章节。这不能直接与OGM或XML章节一起工作。

``--sstep=<sec>``
    在每一帧后跳过<sec>秒。

    .. note::

        如果没有 ``--hr-seek`` ，跳过的时间将扣在关键帧上。

``--stop-playback-on-init-failure=<yes|no>``
    如果音频或视频初始化失败，停止播放（默认：no）。如果使用 ``no`` ，在其中一个失败时，将继续以纯视频或纯音频模式播放。这不影响播放纯音频或纯视频的文件。

``--play-dir=<forward|+|backward|->``
    控制播放方向（默认：forward）。设置 ``backward`` 将尝试以反向播放文件，播放时间递减。如果在播放开始时设置，播放将从文件的末端开始。如果在播放过程中改变它，将发出一个hr-seek来改变方向。

    ``+`` 和 ``-`` 是 ``forward`` 和 ``backward`` 的别名。

    这个选项的其他描述与 ``backward`` 模式有关。

    .. note::

        后向播放是非常脆弱的。它不一定能工作，比正向播放慢得多，而且会破坏某些其他功能。它的工作效果如何主要取决于正在播放的文件。一般来说，只有在众星捧月的情况下，它才能显示出良好的效果（或效果）。

    mpv，以及大多数媒体格式，被设计成只用于向前播放。向后播放是栓在mpv上面的，并试图做出中等程度的努力来使向后播放工作。根据你的使用情况，另一个工具可能工作得更好。

    后向回放并不完全是一个一流的功能。在实现上做了一些取舍，这些取舍对回放不利，但反过来又不会对正常回放造成不利影响。为了降低复杂性，各种可能的优化都没有实现。通常情况下，媒体播放器是高度流水线化的（未来的数据是在独立的线程中准备的，所以当下一阶段需要它时，它是实时可用的），但后向播放基本上会在各种随机点上停滞流水线。

    例如，对于只在内部的编解码器是微不足道的可向后播放的，围绕它们建立的工具可能会有效地利用它们（考虑视频编辑器或相机查看器）。mpv在这种情况下不会有效率，因为它使用其通用的向后播放算法，在它上面不是非常优化。

    如果你只是想快速倒退视频并显示 "关键帧"，只需使用向前播放，并按住左光标键（在默认配置的CLI上会发送许多小的相对寻址命令）。

    实现主要由3部分组成。

    - 后向解复用。这依赖于Demuxer缓存，所以Demuxer缓存应该（或必须，没有测试）被启用，它的大小会影响性能。如果缓存过小或过大，可能会导致二次运行时的行为。

    - 向后解码。使用的解码器库（libavcodec）不支持这个。它是通过向前输入数据位，将结果放入队列，反向返回队列数据给VO，然后在较早的位置重新开始来模拟的。这可能需要缓冲大量的解码数据，也会完全破坏流水线。

    - 后向输出。这相对简单，因为解码器按需要的顺序返回帧。然而，这可能会引起各种问题，因为过滤器会看到音频和视频向后移动。

    已知的问题：

    - 它很脆弱。如果有什么东西不工作，可能会出现随机的无用的行为。在简单的情况下，播放器将只是播放无意义的东西和假象。在其他情况下，它可能会被卡住或加热CPU。(超过内存使用量明显超过用户设定的限制将是一个错误，虽然)。

    - 性能和资源使用情况并不理想。这在一定程度上是正常媒体格式向后播放所固有的，在一定程度上是由于实现选择和权衡。

    - 这极其依赖于良好的解复用器行为。尽管后向解复用不需要特殊的解复用器支持，但需要解复用器可靠地执行寻求，满足一些关于数据包元数据的特殊要求，并具有确定性的行为。

    - 准确地从结尾开始播放可能会也可能不会成功，这取决于搜索行为和文件持续时间检测。

    - 一些容器格式、音频和视频编解码器由于其行为而不被支持。没有列表，而且播放器通常不检测它们。某些直播流（包括电视捕获）可能会表现出特别的问题，以及一些有损的音频编解码器。已知h264内部刷新由于libavcodec的问题而无法工作。WAV和其他一些原始音频格式往往有问题--有一些处理它们的黑客，可能有效也可能无效。

    - 不支持字幕的向后解复用。字幕显示仍然适用于一些外部文本字幕格式。(这些是完全读入内存的，只需要向后显示。) 缓存在字幕渲染器中的文本字幕也有机会被正确显示。

    - 一些处理播放破损或难以处理的文件的功能将不能完全工作（如时间戳校正）。

    - 如果通过后向回放执行解复用器的低级寻址（即寻址实际的解复用器，而不仅仅是在解复用器的缓存内），创建的寻址范围可能无法连接，因为没有达到足够的重叠度。

    - 试图用硬件视频解码来使用这个方法可能会耗尽你所有的GPU内存，然后崩溃一两件事情。或者会失败，因为 ``--hwdec-extra-frames`` 肯定会被设置得太低。

    - 流记录被破坏了。如果你只在缓存区域内倒退播放， ``--stream-record`` 可能会继续工作。

    - 相对搜索可能表现得很奇怪。小规模的向后搜索（向小的时间，即 ``seek -1`` ）可能不会真正正确搜索，音频将保持静音一段时间。建议使用hr-seek，它应该不会有这些问题。

    - 有些事情就是很奇怪。例如，虽然寻道命令以预期的方式操纵播放时间（只要它们能正常工作），但帧步命令是换位的。反步法将执行非常昂贵的工作来向前迈进1帧。

    调试：

    - 删除所有你设置的 ``--vf``/``--af`` 过滤器。禁用硬件解码。禁用像SPDIF直通这样愚蠢的废话。

    - 增加 ``--video-reversal-buffer`` 可能有助于逆转队列的溢出，这可能发生在高比特率视频或大GOP的视频。硬件解码大多会忽略这一点，你需要增加 ``--hwdec-extra-frames`` ，而不是（直到你得到没有记录错误的播放）。

    - 解码器缓存对后向解码至关重要。确保设置 ``--cache=yes`` 。缓存的大小可能很重要。如果它太小，队列溢出将被记录，后向播放不能继续，或者它执行了太多的低级搜索。如果太大，实现的权衡可能会导致一般的性能问题。使用 ``--demuxer-max-bytes`` 可能会增加demuxer层可以排队进行反向demuxing的数据包的数量（基本上是相当于demuxer层的 ``--video-reversal-buffer`` ）。

    - 设置 ``--vd-queue-enable=yes`` 可以使播放更加流畅（一旦成功）。

    - ``--demuxer-backward-playback-step`` 也是影响可能进行多少次搜索的因素，以及后向解复用是否会因队列溢出而中断。如果它设置得太高，即使缓存足够大，后退操作也需要一直搜索更多的数据包。

    - 设置 ``--demuxer-cache-wait`` 可能有助于将整个文件缓存到demuxer缓存中。设置 ``--demuxer-max-bytes`` 到一个大的尺寸，以确保它能读取整个缓存； ``--demuxer-max-back-bytes`` 也应该设置到一个大的尺寸，以防止那个试图修剪缓存的行为。

    - 如果可以听到音频伪影，即使AO没有欠费，增加 ``--audio-backward-overlap`` 在某些情况下可能有帮助。

``--video-reversal-buffer=<bytesize>``, ``--audio-reversal-buffer=<bytesize>``
    用于后向解码。后向解码是按步骤向前解码，然后反转解码器的输出。这些选项控制了可以缓冲的最大字节数的近似值。它的主要用途是避免无限制的资源使用；在正常的后向播放过程中，它不应该达到极限，如果它达到了，它就会丢帧并抱怨。

    如果你在倒放过程中得到反转队列溢出的错误，请使用这个选项。增加大小，直到警告消失。通常，视频缓冲区会首先溢出，尤其是高分辨率的视频。

    如果使用视频硬件解码，这就不能正常工作。视频帧的大小将不包括引用的GPU和驱动内存。一些硬件解码器也可能受到 ``--hwdec-extra-frames`` 的限制。

    队列大小需要多大，完全取决于媒体的编码方式。音频通常需要一个非常小的缓冲区，而视频可能需要过大的缓冲区。

    (技术上讲，这允许最后一帧超过限制。另外，这还没有考虑到其他缓冲帧，如解码器内部或视频输出）。

    这完全不影响demuxer的缓存行为。

    默认值和取值范围见 ``--list-options`` 。 ``<bytesize>`` 选项接受后缀，如 ``KiB`` 和 ``MiB`` 。

``--video-backward-overlap=<auto|number>``, ``--audio-backward-overlap=<auto|number>``
    用于后向解码的重叠关键帧范围的数量（默认：auto）（"关键帧 "应理解为mpv/ffmpeg的特定含义）。后向解码是通过小步向前解码来进行的。一些编解码器不能从任何数据包重新开始解码（即使它被标记为寻址点），这在后向解码中变得很明显（理论上这也是寻址的问题，但 ``--hr-seek-demuxer-offset`` 可以解决寻址的问题）。特别是，基于MDCT的音频编解码器受到影响。

    解决办法是每次给解码器送入一个前一个数据包，然后丢弃输出。这个选项控制要送多少个数据包。 ``auto`` 选项目前对视频来说硬编码为0，对有损音频使用1，对无损音频使用0。对于一些特定的有损音频编解码器，这被设置为2。

    ``--video-backward-overlap`` 有可能处理刷新内的视频，这取决于具体条件。你可能还需要使用 ``--vd-lavc-show-all`` 选项。

``--video-backward-batch=<number>``, ``--audio-backward-batch=<number>``
    后向解码时一次解码的关键帧范围的数量（默认：视频为1，音频为10）。另一个没有意义的调整参数，没有人应该使用。这应该只影响性能。理论上，为音频设置一个高于1的数字将减少开销，因为减少了频繁的后退操作，以及减少了因解码重叠帧而产生的冗余解码工作（见 ``--audio-backward-overlap`` ）。另一方面，它需要一个更大的反转缓冲区，并可能由于破坏流水线而使回放不顺畅（例如，通过解码很多，然后有一段时间什么都不做）。

    设置 ``--video-backward-batch`` 可能没有意义。但在理论上，它可以通过减少后退操作来帮助只在内部的视频编解码器。

``--demuxer-backward-playback-step=<seconds>``
    在回放过程中，解复用器应该回寻获得新数据包的秒数（默认：60）。这对调整回放是很有用的，详见 ``--play-dir``

    设置为一个非常低的值或0，可能会使播放器认为搜索被破坏，或可能使它执行多次搜索。

    将其设置为高值可能会导致运行时的四次方行为。

Program Behavior
----------------

``--help``, ``--h``
    显示选项的简短摘要。

    你也可以给这个选项传递一个字符串，它将列出所有名称中包含该字符串的顶级选项，例如， ``--h=scale`` 代表所有包含 ``scale`` 的选项。特殊字符串 ``*`` 列出所有顶层选项。

``-v``
    增加口令级别，在命令行上每发现一个 ``-v`` 就增加一个级别。

``--version, -V``
    打印版本字符串并退出。

``--no-config``
    不加载默认的配置文件。这将阻止加载用户级和系统级的 ``mpv.conf`` 和 ``input.conf`` 文件。其他的配置文件也会被阻止，例如恢复播放文件。

    .. note::

        由命令行选项明确要求的文件，如 ``--include`` 或 ``--use-filedir-conf`` ，仍将被加载。

    也请参见： ``--config-dir``

``--list-options``
    打印所有可用的选项。

``--list-properties``
    打印可用属性的列表。

``--list-protocols``
    打印所支持的协议的列表。

``--log-file=<path>``
    打开给定的路径进行写入，并打印日志信息到其中。现有的文件将被截断。日志级别至少是 ``-v -v`` ，但可以通过 ``--msg-level`` 提高（该选项不能降低到强制的最低日志级别以下）。

    一个特殊情况是macOS捆绑系统，它将在 ``~/Library/Logs/mpv.log`` 处创建一个默认的日志文件。

``--config-dir=<path>``
    强制使用不同的配置目录。如果设置了这个，给定的目录将被用来加载配置文件，而所有其他的配置目录都被忽略了。这意味着全局mpv配置目录以及每个用户的目录都被忽略，通过环境变量（ ``MPV_HOME`` ）的重写也被忽略。

    注意， ``--no-config`` 选项优先于该选项。

``--save-position-on-quit``
    在退出时总是保存当前的播放位置。当以后再次播放这个文件时，播放器会在开始时寻找到旧的播放位置。如果一个文件的播放以任何其他方式停止，而不是退出，这种情况不会发生。例如，进入播放列表中的下一个文件不会保存位置，而是在下次播放该文件时从头开始播放。

    这种行为默认是禁用的，但当用Shift+Q退出播放器时，总是可以使用的。

``--watch-later-directory=<path>``
    存储 "稍后观看 "临时文件的目录。

    默认是在配置目录下的一个名为 "watch_later "的子目录（通常是 ``~/.config/mpv/`` ）。

``--dump-stats=<filename>``
    将某些统计数据写入给定文件。该文件在打开时被截断。该文件将包含原始样本，每个样本都有一个时间戳。为了使这个文件变成可读的，可以使用脚本 ``TOOLS/stats-conv.py`` （目前它以图表形式显示）。

    这个选项只在调试时有用。

``--idle=<no|yes|once>``
    让mpv在没有文件可以播放时空闲等待而不是退出。主要在输入模式下有用，mpv可以通过输入命令来控制。(默认： ``no`` )

    ``once`` 将只在开始时空闲，一旦第一个播放列表播放完毕，就让播放器关闭。

``--include=<configuration-file>``
    指定配置文件，在默认文件之后进行解析。

``--load-scripts=<yes|no>``
    如果设置为 "no"，则不自动加载 ``scripts`` 配置子目录（通常是 ``~/.config/mpv/scripts/`` ）中的脚本。(默认： ``yes`` )

``--script=<filename>``, ``--scripts=file1.lua:file2.lua:...``
    加载一个Lua脚本。第二个选项允许你加载多个脚本，用路径分隔符（Unix下为 ``:`` ，Windows下为 ``;`` ）将它们分开。

    ``--scripts`` 是一个路径列表选项。详见 `List Options`_

``--script-opts=key1=value1,key2=value2,...``
    为脚本设置选项。脚本可以通过键来查询一个选项。如果一个选项被使用，以及该选项值具有什么样的语义，完全取决于所加载的脚本。没有被任何脚本要求的值会被忽略。

    这是一个按键/值列表选项。详见 `List Options`_

``--merge-files``
    假设所有传递给mpv的文件都被串联成一个大文件。这在内部使用timeline/EDL支持。

``--no-resume-playback``
    不要从`watch_later'配置子目录（通常是 ``~/.config/mpv/watch_later/`` ）恢复播放位置。参见 ``quit-watch-later`` 输入命令。

``--resume-playback-check-mtime``
    只恢复 ``watch_later`` 配置子目录（通常是 ``~/.config/mpv/watch_later/`` ）中的播放位置，如果文件的修改时间与保存时相同。这可以防止同名但内容不同的文件向前跳过。(默认： ``no`` )

``--profile=<profile1,profile2,...>``
    使用给定的配置文件， ``--profile=help`` 显示定义的配置文件列表。

``--reset-on-next-file=<all|option1,option2,...>``
    通常情况下，mpv在播放播放列表上的下一个文件时，会尝试保留所有的设置，即使用户在播放时改变了这些设置。(这种行为与MPlayer相反，MPlayer在开始播放下一个文件时试图重置所有设置)。

    默认：不重置任何东西。

    这可以通过这个选项来改变。它接受一个选项列表，mpv将在播放开始时把这些选项的值重置为初始值。初始值要么是默认值，要么是由配置文件或命令行设置的。

    在某些情况下，这可能不会像预期的那样工作。例如， ``--volume`` 只有在配置文件或命令行中明确设置时才会被重置。

    特殊名称 ``all`` 会重置尽可能多的选项。

    这是一个字符串列表选项。详见 `List Options`_

    .. admonition:: 示例

        - ``--reset-on-next-file=pause``
          在切换到下一个文件时重置暂停模式。
        - ``--reset-on-next-file=fullscreen,speed``
          重置全屏和播放速度设置，如果它们在播放过程中被改变。
        - ``--reset-on-next-file=all``
          尝试重置所有在播放过程中被改变的设置。

``--watch-later-options=option1,option2,...``
    保存在 "watch later "文件中的选项，如果它们在mpv启动后被改变。这些值将在下次播放文件时被恢复。播放位置总是保存为 ``start`` ，所以在这个列表中添加 ``start`` 没有影响。

    当删除选项时，现有的watch later数据不会被修改，仍然会被完全应用，但是新的watch later数据将不包含这些选项。

    这是一个字符串列表选项。详见 `List Options`_

    .. admonition:: 示例

        - ``--watch-later-options-remove=fullscreen``
          全屏状态不会被保存到稍后观看的文件中。
        - ``--watch-later-options-remove=volume``
          ``--watch-later-options-remove=mute``
          音量和静音状态不会被保存到以后观看的文件中。
        - ``--watch-later-options-clr``
          除了起始位置外，不会为以后的文件保存任何选项。

``--write-filename-in-watch-later-config``
    在稍后配置的文件前加上它们所指的文件名。这只是作为注释写在文件的顶部。

    .. warning::

        这个选项可能会暴露隐私敏感信息，因此默认情况下是禁用的。

``--ignore-path-in-watch-later-config``
    在使用watch later功能时忽略路径（即只使用文件名）。(默认：禁用)

``--show-profile=<profile>``
    显示一个配置文件的描述和内容。如果没有提供参数，则列出所有配置文件。

``--use-filedir-conf``
    在正在播放的文件的同一目录下寻找特定文件的配置文件。请看 `File-specific Configuration Files`_

    .. warning::

        如果从不被信任的媒体中播放可能会有危险。

``--ytdl``, ``--no-ytdl``
    启用youtube-dl钩子脚本。它将查看输入的URL，并播放位于该网站上的视频。这适用于许多流媒体网站，而不仅仅是该脚本所命名的网站。这需要在系统上安装一个最新版本的youtube-dl。(默认情况下是启用的。)

    如果脚本不能对一个URL做任何事情，它将什么也不做。

    它接受一组选项，可以通过 ``--script-opts`` 选项（使用 ``ytdl_hook-`` 作为前缀）传递给它。

    ``try_ytdl_first=<yes|no>``
        如果 "是"，将首先尝试用youtube-dl解析URL，而不是默认的在mpv失败后才打开。这主要取决于你的大部分URL是否需要youtube-dl解析。

    ``exclude=<URL1|URL2|...``
        一个 ``|`` 分开的URL模式列表，mpv不应该使用youtube-dl。这些模式在URL的 ``http(s)://`` 部分之后被匹配。

        ``^`` 匹配URL的开头， ``$`` 匹配其结尾，你应该在任何字符 ``^$()%|,.[]*+-?`` 之前使用 ``%`` 来匹配该字符。

        .. admonition:: 示例

            - ``--script-opts=ytdl_hook-exclude='^youtube%.com'``
              将排除任何以 ``http://youtube.com`` 或 ``https://youtube.com`` 开头的URL。
            - ``--script-opts=ytdl_hook-exclude='%.mkv$|%.mp4$'``
              将排除任何以 ``.mkv`` 或 ``.mp4`` 结尾的URL。

        在这里可以看到更多的lua模式：https://www.lua.org/manual/5.1/manual.html#5.4.1

    ``all_formats=<yes|no>``
        如果 "是"，将尝试添加所有由youtube-dl报告的格式（默认：no）。每种格式都作为一个单独的轨道被添加。此外，它们被延迟加载，实际上只有在选择轨道时才会打开（这应该能使加载时间和没有这个选项时一样短）。

        它增加了平均比特率元数据，如果有的话，这意味着你可以使用 ``--hls-bitrate`` 来决定选择哪条轨道。(HLS曾经是唯一的格式，其替代的质量流以类似的方式暴露出来，因此该选项名称)。

        代表youtube-dl默认选择的格式的音轨将被设置为默认标志。这意味着mpv通常仍应选择用 ``--ytdl-format`` 默认选择的格式。

        尽管这种机制使得在运行时切换流成为可能，但由于各种技术原因，它并不适合这个目的。(它很慢，这无法真正解决。)一般来说，这个选项没有用，只是为了显示它的可能性而添加的。

        在做质量/带宽选择时，有两种情况必须考虑。

            1. 完全独立的音频和视频流（类似DASH）。这些流中的每一个都只包含音频或视频，所以你可以不受限制地混合和组合音频/视频带宽。这在直觉上与按音轨选择质量的概念最匹配（ ``all_formats`` 应该做的）。

            2. 分开的混合音频和视频流的集合。每个版本的媒体都包含音频和视频流，而且它们是交错的。为了不浪费带宽，你应该只选择这些版本中的一个（例如，如果你选择了音频流，那么视频将被下载，即使你选择了不同流的视频）。

               mpv仍然将它们表示为单独的音轨，但会将每个音轨的标题设置为 ``muxed-N`` ，其中 ``N`` 被替换为原流的优酷dl格式的ID。

        有些网站会混合使用1.和2.，但我们认为他们这样做是出于兼容性的考虑，根本没有理由使用它们。

    ``force_all_formats=<yes|no>``
        如果设置为 "是"，并且 ``all_formats`` 也设置为 "是"，这将尝试将所有youtube-dl报告的格式表示为轨道，即使mpv通常会使用它报告的直接URL（默认：yes）。

        如果youtube-dl在一个主的HLS播放列表上工作，这通常会有区别。

        如果设置为 "no"，这种特定的流会被当作 ``all_formats`` 设置为 "no"，并使用youtube-dl（通过 ``-ytdl-format`` ）进行的流选择。

    ``use_manifests=<yes|no>``
        使mpv使用HLS和DASH等格式的主清单URL，如果有的话，允许在运行时选择视频/音频（默认：no）。由于性能原因，默认情况下是禁用的（"no"）。

    ``ytdl_path=youtube-dl``
        配置youtube-dl的可执行文件或兼容的分叉文件的路径。mpv在PATH和mpv的配置目录中依次寻找配置的路径。默认的是 "yt-dlp"，"yt-dlp_x86 "和 "youtube-dl"。在Windows上，后缀".exe "总是被附加的。

    .. admonition:: 为什么选项名称混合了 ``_`` 和 ``-`` ？

        我不知道。

``--ytdl-format=<ytdl|best|worst|mp4|webm|...>``
    直接传递给youtube-dl的视频格式/质量。可能的值是针对网站和视频的，对于一个给定的URL，可用的格式可以通过命令 ``youtube-dl --list-formats URL`` 找到。关于可用的别名，请看youtube-dl的文档。(默认： ``bestvideo+bestaudio/best`` )

    ``ytdl`` 的值根本没有向youtube-dl传递 `--format`` 选项，因此没有覆盖其默认值。注意，有时youtube-dl返回的格式是mpv无法使用的，在这种情况下，mpv的默认值可能会更好。

``--ytdl-raw-options=<key>=<value>[,<key>=<value>[,...]]``
    传递任意的选项给youtube-dl。参数应该以键值对的形式传递。没有参数的选项必须包括 ``=`` 。

    没有理智检查，所以有可能破坏事情（例如，将无效的参数传递给youtube-dl）。

    可以传递一个代理URL，让youtube-dl在解析网站时使用它。这对于有地理限制的URL很有用。在youtube-dl解析后，一些URL也需要代理来播放，所以这可以把代理信息传递给mpv。请注意，SOCKS代理不被支持，https的URL也会绕过代理。这是FFmpeg的一个限制。

    这是一个按键/值列表选项。详见 `List Options`_

    .. admonition:: 示例

        - ``--ytdl-raw-options=username=user,password=pass``
        - ``--ytdl-raw-options=force-ipv6=``
        - ``--ytdl-raw-options=proxy=[http://127.0.0.1:3128]``
        - ``--ytdl-raw-options-append=proxy=http://127.0.0.1:3128``

``--load-stats-overlay=<yes|no>``
    启用内置脚本，在一个键绑定上显示有用的播放信息（默认：yes）。默认情况下，使用 ``i`` 键（ ``I`` 键使叠加永久化）。

``--load-osd-console=<yes|no>``
    启用内置脚本，在按键绑定上显示控制台，让你输入命令（默认：yes）。在默认情况下， ``´`` 键用于显示控制台， ``ESC`` 键用于再次隐藏它。(这是基于一个名为 ``repl.lua`` 的用户脚本)。

``--load-auto-profiles=<yes|no|auto>``
    启用内置脚本，进行自动配置文件（默认： ``auto`` ）。详见 `Conditional auto profiles`_ 。 ``auto`` 将加载脚本，但如果没有条件性配置文件，则立即卸载它。

``--player-operation-mode=<cplayer|pseudo-gui>``
    用于启用 "伪GUI模式"，这意味着一些选项的默认值被改变。这个选项通常不应该直接使用，而应该由mpv内部使用，或者由mpv提供的脚本、配置文件或.desktop文件。详见 `PSEUDO GUI MODE`_

Video
-----

``--vo=<driver>``
    指定要使用的视频输出后端。请参阅 `VIDEO OUTPUT DRIVERS`_ 以了解可用驱动程序的细节和描述。

``--vd=<...>``
    根据视频解码器的系列和名称，指定要使用的视频解码器的优先列表。参见 ``--ad`` 以了解更多细节。这两个选项使用相同的语法和语义；唯一的区别是它们对不同的解码器列表进行操作。

    .. note::

        参见 ``--vd=help`` 了解可用解码器的完整列表。

``--vf=<filter1[=parameter1:parameter2:...],filter2,...>``
    指定一个视频过滤器的列表，应用于视频流。参见 `VIDEO FILTERS`_ 了解可用过滤器的细节和描述。选项变体 ``--vf-add``, ``--vf-pre``, ``--vf-del`` 和 ``--vf-clr`` 的存在是为了修改先前指定的列表，但在典型使用中应该不需要这些。

``--untimed``
    在输出视频帧时不休眠。当与 ``--no-audio`` 一起使用时，对基准有用。

``--framedrop=<mode>``
    在慢速系统上跳过显示一些帧以保持A/V同步，或者在有帧数上限的视频输出上播放高帧数的视频。

    该参数选择下降的方法，可以是下列之一：

    <no>
        禁用任何丢帧。不推荐，仅用于测试。
    <vo>
        在视频输出中丢弃晚期帧（默认）。这仍然是对所有帧进行解码和过滤，但不在VO上渲染它们。丢弃的帧在终端状态行中显示为 ``Dropped:`` 字段。

        在音频同步模式下，这将放弃在显示时已经过时的帧。如果解码器太慢，理论上所有的帧都会被丢弃（因为所有的帧都太晚了）--为了避免这种情况，如果有效帧率低于10FPS，则停止丢帧。

        在显示同步模式下（见 ``--video-sync`` ），这只影响A/V掉帧或重复掉帧的方式。如果这个模式被禁用，A/V去同步理论上不会再影响视频调度（很像 ``display-resample-desync`` 模式）。然而，即使禁用，帧仍然会根据视频和显示频率之间的比例被跳过（即放弃）。

        这是推荐模式，也是默认模式。
    <decoder>
        旧的、基于解码器的成帧模式。(这与mpv 0.5.x及以前的 ``--framedrop=yes`` 相同。)这告诉解码器跳过帧(除非需要它们来解码未来的帧)。可能对慢速系统有帮助，但可能产生无法观看的不稳定输出，甚至完全冻结显示。

        这使用了一种可能没有意义的启发式方法，而且一般来说不能取得良好的效果，因为解码器的丢帧不能以一种可预测的方式控制。不推荐。

        即使你想使用这个，也要选择 ``decoder+vo`` ，以获得更好的效果。

        ``--vd-lavc-framedrop`` 选项控制要丢掉哪些帧。
    <decoder+vo>
        启用两种模式。不推荐。比只有 ``decoder`` 模式好。

    .. note::

        ``--vo=vdpau`` 有自己的代码用于 ``vo`` 框架模式。与其他VO有可能有轻微的不同。

``--video-latency-hacks=<yes|no>``
    启用一些倾向于减少1或2帧视频延迟的东西（默认：no）。请注意，一旦播放器的计时代码不再需要做这些事情，这个选项可能会被删除而不另行通知。

    这样做的：

    - 使用demuxer报告的FPS进行丢帧。这避免了玩家需要提前解码1帧，有效地降低了总延迟。这也意味着，如果解复用器报告的FPS是错误的，或者视频过滤链改变了FPS（例如去隔行扫描），那么它就可能丢掉太多或不够的帧。
    - 禁用等待第一个视频帧。通常情况下，播放器会等待第一个视频帧被完全渲染后再开始正常播放。一些VO会在渲染第一帧时懒散地初始化一些东西，所以如果不这样做，如果渲染第一帧的时间超过需要，VO就有可能丢掉一些帧。

``--override-display-fps=<fps>``
    设置与 ``--video-sync=display-*`` 模式一起使用的显示FPS。默认情况下，使用一个检测值。请记住，设置一个不正确的值（即使是轻微的错误）会破坏视频播放。在多显示器系统中，有可能检测到的值来自错误的显示器。

    只有在你有理由相信自动确定的数值是错误的情况下才设置这个选项。

``--display-fps=<fps>``
    Deprecated ``--overrid-display-fps`` 的别名。

``--hwdec=<api>``
    指定可能的话应该使用的硬件视频解码API。硬件解码是否实际完成取决于视频编解码器。如果硬件解码不可能，mpv将退回到软件解码。

    硬件解码在默认情况下是不启用的，因为它通常是一个额外的错误源。只有在你的CPU太慢，无法解码特定视频的情况下，才值得使用。

    .. note::

        使用 ``Ctrl+h`` 快捷键来在运行时切换硬件解码。它在 ``auto`` 和 ``no`` 之间切换这个选项。

        我们不鼓励通过把它放入配置文件来启用硬件解码。如果你使用Ubuntu软件包，删除 ``/etc/mpv/mpv.conf`` ，因为该软件包试图通过设置 ``hwdec=vaapi`` 来默认启用HW解码（这不是很理想，甚至可能导致使用次优的封装器）。或者至少把它改为 ``hwdec=auto-safe`` 。

    如果你想启用硬件解码，请使用其中一种自动模式。明确选择模式主要是为了测试和调试。如果你想让事情在更新后继续工作，在配置文件中明确选择是个坏主意，等等。

    .. note::

        即使启用，硬件解码仍然只对某些编解码器有白名单。请看  ``--hwdec-codecs`` 以在更多的情况下启用硬件解码。

    .. admonition:: 选择哪种方法？

        - 如果你只想在运行时启用硬件解码，不要设置参数，或者在你的 ``mpv.conf`` 中加入 ``hwdec=no`` （在默认情况下强制启用的发行版上是相关的，比如Ubuntu）。使用 ``Ctrl+h`` 默认绑定在运行时启用它。
        - 如果你不确定，但希望硬件解码在默认情况下被启用，可以在你的``mpv.conf'中加入 ``hwdec=auto-safe`` ，并承认这种使用情况不被 "真正 "支持，可能会导致问题。
        - 如果你想测试可用的硬件解码方法，通过 ``--hwdec=auto --hwdec-codecs=all`` ，看看终端输出。
        - 如果你是一个开发者，或者想进行详细的测试，你可能需要其他任何可能的选项值。

    ``<api>`` 可以是下列之一：

    :no:        始终使用软件解码（默认）
    :auto:      强制启用任何发现的HW解码器（见下文）
    :yes:       与 ``auto`` 完全相同
    :auto-safe: 启用任何白名单的HW解码器（见下文）
    :auto-copy: 启用最好的hw解码器并进行回拷（见下文）
    :vdpau:     需要 ``--vo=gpu`` 和X11，或 ``--vo=vdpau`` （仅Linux）
    :vdpau-copy: 将视频拷贝回系统RAM（仅Linux与某些GPU）
    :vaapi:     需要 ``--vo=gpu`` 或`--vo=vaapi`` (仅Linux)
    :vaapi-copy: 将视频复制到系统RAM中（仅Linux和一些GPU）
    :videotoolbox: 需要 ``--vo=gpu`` （macOS 10.8及以上），或 ``--vo=libmpv`` （iOS 9.0及以上）
    :videotoolbox-copy: 将视频拷贝回系统RAM中（macOS 10.8或iOS 9.0及以上版本）
    :dxva2:     需要 ``--vo=gpu`` 与 ``--gpu-context=d3d11`` ,  ``--gpu-context=angle`` 或 ``--gpu-context=dxinterop`` (仅Windows)
    :dxva2-copy: 将视频拷贝回系统RAM(仅Windows)
    :d3d11va:   需要 ``--vo=gpu`` 与 ``--gpu-context=d3d11`` 或 ``--gpu-context=angle`` (仅Windows 8以上)
    :d3d11va-copy: 将视频拷贝回系统RAM(仅Windows 8+)
    :mediacodec: 需要 ``--vo=mediacodec_embed`` (仅Android)
    :mediacodec-copy: 将视频复制到系统内存（仅安卓）
    :mmal:      要求 ``--vo=gpu`` (仅树莓派--如果有的话默认)
    :mmal-copy: 将视频拷贝到系统RAM（仅树莓派）
    :nvdec:     要求 ``--vo=gpu`` (任何平台的CUDA都可以使用)
    :nvdec-copy: 将视频拷贝到系统RAM（任何平台的CUDA都可以使用）
    :cuda:      要求 ``--vo=gpu`` (任何平台的CUDA都可用)
    :cuda-copy: 将视频拷贝到系统RAM中（任何平台的CUDA都可用）
    :crystalhd: 将视频拷贝到系统RAM中（任何硬件支持的平台）
    :rkmpp:     需要 ``--vo=gpu`` (仅某些RockChip设备)

    ``auto`` 试图使用第一个可用的方法自动启用硬件解码。这仍然取决于你使用的是什么VO。例如，如果你没有使用 ``--vo=gpu`` 或 ``--vo=vdpau`` ，vdpau解码将不会被启用。还要注意的是，如果第一个找到的方法实际上不起作用，它将总是退回到软件解码，而不是尝试下一个方法（在一些Linux系统上可能很重要）。

    ``auto-safe`` 与 ``auto`` 类似，但只允许被认为是 "安全 "的白名单方法。这应该是在配置文件中默认启用硬件解码的一种合理方式（尽管你不应该这样做；最好在运行时用 ``Ctrl+h`` 启用）。与 ``auto`` 不同，它不会尝试启用未知或已知的坏方法。此外，在其他已知会导致问题的情况下，这可能会禁用硬件解码，但目前这个机制是相当原始的。(作为一个仍然会导致问题的例子：Windows上HEVC和Intel芯片的某些组合往往会导致mpv崩溃，很可能是由于驱动错误)。

    ``auto-copy-safe`` 选择了 ``auto-safe`` 和 ``auto-copy`` 的联合方法。

    ``auto-copy`` 只选择在解码后将视频数据拷贝回系统内存的模式。这就选择了像  ``vaapi-copy`` （等等）这样的模式。如果这些都不行，硬件解码就会被禁用。这种模式通常保证与软件解码相比不会产生额外的质量损失（假设是现代编解码器和无错误的视频流），并将允许用视频过滤器进行CPU处理。这种模式适用于所有视频过滤器和VO。

    因为这些模式将解码后的视频复制到系统RAM中，它们的效率往往不如直接模式，而且可能对软件解码没有太大帮助。

    .. note::

       大多数非拷贝方法只在OpenGL GPU后端工作。目前，只有 ``vaapi`` 、``nvdec`` 和 ``cuda`` 方法能在Vulkan上工作。

    ``vaapi`` 模式，如果与 ``--vo=gpu`` 一起使用，需要Mesa 11，并且很可能只适用于Intel和AMD的GPU。它还需要opengl EGL后端。

    ``nvdec`` 和 ``nvdec-copy`` 是最新的方法，建议在Nvidia GPU上进行硬件解码。

    ``cuda`` 和 ``cuda-copy`` 是在Nvidia GPU上进行硬件解码的老方法，使用Nvidia的比特流解析器，而不是FFmpeg的。这可能导致功能上的缺陷，如HDR内容的错误播放， ``nvdec`` / ``nvdec-copy`` 应始终是首选，除非你特别需要Nvidia的去隔行扫描算法。要使用这种去隔行扫描，你必须通过选项： ``vd-lavc-o=deint=[weave|bob|adaptive]`` 。传递 ``weave``（或不设置该选项）以不尝试任何去隔行扫描。

    .. admonition:: 用硬件解码降低质量

        理论上，硬件解码不会降低视频质量（至少对于h264和HEVC编解码器是这样）。然而，由于视频输出API的限制，以及实际硬件解码器的错误，可能会有一些损失，甚至是公然不正确的结果。

        在某些情况下，RGB转换是强制的，这意味着RGB转换是由硬件解码API执行的，而不是由 ``--vo=gpu`` 使用的着色器。这意味着某些色彩空间可能无法正确显示，而且某些过滤（如debanding）不能以理想的方式应用。这通常也会迫使使用低质量的色度缩放器，而不是由 ``--cscale`` 指定的。在其他情况下，硬件解码也会降低解码后图像的比特深度，对于10比特的文件来说，会引入带状或精度损失。

        ``vdpau`` 总是在硬件中进行RGB转换，它不能正确支持较新的色彩空间，如BT.2020。然而， ``vdpau`` 不支持10比特或HDR编码，所以这些限制不太可能是相关的。

        ``vaapi`` 和 ``d3d11va`` 是安全的。启用去隔行扫描（或仅仅是它们各自的后处理过滤器）可能至少会通过将输出转换为8比特格式而降低色彩质量。

        ``dxva2`` 是不安全的。它似乎总是使用BT.601进行强制RGB转换，但实际行为取决于GPU驱动程序。一些驱动程序似乎会转换为有限范围的RGB，这给人一种褪色的感觉。除了特定驱动程序的行为外，全局系统设置可能也会影响到这一点。这可能会产生不正确的结果，即使是完全普通的视频源。

        ``rpi`` 总是使用硬件叠加渲染器，即使使用 ``--vo=gpu``

        ``cuda`` 通常是安全的，但根据文件/流的混合方式，它被报告会破坏时间戳，导致闪烁的帧。它有时也会因不明原因而导致大量帧丢失。建议谨慎使用， ``nvdec`` 应该是首选。

        ``crystalhd`` 不安全。它总是转换为4:2:2 YUV，这可能是有损失的，取决于转换过程中如何进行色度子采样。出于某种原因，它还会丢弃每一帧的左上角像素。

        所有其他的方法，特别是回拷方法（如 ``dxva2-copy`` 等）应该是安全的，尽管它们仍然可能导致随机解码问题。至少，它们不应该影响图像的颜色。

        特别是， ``auto-copy`` 将只选择 "安全 "模式（尽管可能比其他方法慢），但仍然不能保证所选择的硬件解码器能真正正确工作。

        一般来说，我们强烈建议避免使用硬件解码，除非 **绝对** 必要，也就是说，如果你的CPU不足以解码有问题的文件。如果你遇到任何奇怪的解码问题，帧故障或变色，并且你打开了 ``--hwdec`` ，你应该首先尝试禁用它。

``--gpu-hwdec-interop=<auto|all|no|name>``
    这个选项是用来排除hwdec互操作问题的。由于它是一个调试选项，它的语义可能在任何时候改变。

    这对 ``gpu`` 和 ``libmpv`` 虚拟机很有用，可以准确选择使用哪个hwdec互操作环境。有效地，它也可以用来阻止某些后端的加载。

    如果设置为 ``auto`` （默认），其行为取决于VO：对于 ``gpu`` ，它不做任何事情，互操作上下文在需求时被加载（当解码器探测到 ``--hwdec`` 支持时）。对于没有按需加载的 ``libmpv`` ，这等同于 ``all`` 。

    空字符串等同于 ``auto`` 。

    如果设置为 ``all`` ，它试图在GL上下文创建时加载所有的互操作上下文。

    除此以外，可以设置特定的后端，可以用 ``help`` 查询它们的列表（仅mpv CLI）。

    运行时对此的更改会被忽略（每当渲染器被创建时都会使用当前的选项值）。

    以前的别名 ``--opengl-hwdec-interop`` 和 ``--hwdec-preload`` 与此几乎没有关系了，但在某些情况下会有一定的兼容性。

``--hwdec-extra-frames=<N>``
    硬件解码应该预分配的GPU帧数（默认：见 ``--list-options`` 输出）。如果这个数值太低，在解码过程中帧分配可能会失败，视频帧可能会被丢弃或损坏。设置太高只是浪费了GPU内存，没有任何好处。

    这个值只用于需要预先分配面的硬件解码API（已知的例子包括 ``d3d11va`` 和 ``vaapi`` ）。对于其他API，帧是根据需要分配的。细节取决于硬件解码器的libavcodec实现。

    所需的面数取决于动态运行时的情况。默认值是一个固定值，被认为对大多数用途来说是足够的。但在某些情况下，它可能是不够的。

``--hwdec-image-format=<name>``
    设置硬件解码通过 ``--hwdec`` 使用的内部像素格式（默认： ``no`` ）。特殊值  ``no`` 选择一个特定的标准格式。大多数解码器实现只支持一种格式，如果不支持该格式，将无法初始化。

    有些实现可能支持多种格式。特别是videotoolbox需要 ``uyvy422`` ，以便在一些旧的硬件上获得良好的性能。d3d11va总是可以使用 ``yuv420p`` ，它使用不透明的格式，可能没有任何优势。

``--cuda-decode-device=<auto|0..>``
    在使用OpenGL GPU后端的 ``cuda`` 或 ``nvdec`` hwdecs时选择用于解码的GPU设备，在所有情况下使用 ``cuda-copy`` 或 ``nvdec-copy`` hwdecs时也是如此。

    对于OpenGL GPU后端，用于解码的默认设备是被用来提供 ``gpu`` 输出的设备（在绝大多数情况下，只有一个GPU会出现）。

    对于 ``copy`` hwdecs，默认设备将是CUDA库所列举的第一个设备--无论如何都是这样的。

    对于Vulkan GPU后端，解码必须总是发生在显示设备上，这个选项没有影响。

``--vaapi-device=<device file>``
    为 ``vaapi-copy`` 选择DRM设备。这应该是一个DRM设备文件的路径。(默认： ``/dev/dri/renderD128`` )

``--panscan=<0.0-1.0>``
    启用平移和扫描功能（例如，裁剪16:9视频的两侧，使其适合4:3的显示器，没有黑带）。范围控制图像被裁剪的程度。可能不适合所有的视频输出驱动。

    如果使用了 ``--video-unscaled`` 选项，这个选项就没有作用。

``--video-aspect-override=<ratio|no>``
    覆盖视频长宽比，以防播放的文件中长宽比信息不正确或丢失。

    这些值有特殊含义：

    :0:  禁用长宽比处理，假装视频是方形像素。
    :no: 与 ``0`` 相同。
    :-1: 使用视频流或容器的长宽比（默认）。

    但请注意，对这些特殊值的处理在未来可能会改变。

    .. admonition:: 示例

        - ``--video-aspect-override=4:3`` 或 ``--video-aspect-override=1.3333``
        - ``--video-aspect-override=16:9`` 或 ``--video-aspect-override=1.7777``
        - ``--no-video-aspect-override`` 或 ``--video-aspect-override=no``

``--video-aspect-method=<bitstream|container>``
    这设置了默认的视频长宽决定方法（如果长宽没有被用户用 ``--video-aspect-override`` 或其他方式覆盖）。

    :container: 严格意义上讲，倾向于容器的长宽比。这显然是VLC的默认行为，至少在Matroska中是如此。请注意，如果容器没有设置长宽比，其行为与比特流相同。
    :bitstream: 严格倾向于比特流长宽比，除非没有设置比特流长宽比。这显然是XBMC/kodi的默认行为，至少对Matroska是这样。

    目前mpv的默认值是 ``container``

    通常情况下，你不应该设置这个。如果你遇到的视频在mpv里有错误的长宽比，但在其他播放器里似乎是正确的，请尝试各种选择。

``--video-unscaled=<no|yes|downscale-big>``
    禁用视频的缩放功能。如果窗口比视频大，就会添加黑条。否则，视频将被裁剪，除非该选项被设置为 ``downscale-big`` ，在这种情况下，视频将适合于窗口。视频仍然可以受到其他 ``--video-...`` 选项的影响。该选项禁用了 ``--panscan`` 的效果。

    请注意，即使视频没有被缩放，缩放器的算法仍然可能被使用。例如，这可能影响色度转换。如果视频源使用非正方形像素（例如变形宽屏DVD），视频也将在一个维度上被缩放。

    如果使用 ``--no-keepaspect`` 选项，该选项将被禁用。

``--video-pan-x=<value>``, ``--video-pan-y=<value>``
    将显示的视频矩形在X或Y方向移动给定值。单位是按比例的视频尺寸的分数（全尺寸，即使由于panscan或其他选项，视频的部分内容不可见）。

    例如，在1680x1050的屏幕上全屏显示1280x720的视频，使用 ``--video-pan-x=-0.1`` 会将视频向左移动168像素（使源视频的128像素不可见）。

    如果使用 ``--no-keepaspect`` 选项，这个选项将被禁用。

``--video-rotate=<0-359|no>``
    顺时针旋转视频，单位是度。如果给了 ``no`` ，视频就不会被旋转，即使文件有旋转元数据。(旋转值被添加到旋转元数据中，这意味着 ``0`` 值将根据旋转元数据旋转视频)。

    当使用没有回拷的硬件解码时，只有90°的步骤可以工作，而软件解码和将视频回拷到系统内存的硬件解码方法支持0到359之间的所有值。

``--video-zoom=<value>``
    按给定值调整视频显示比例因子。该参数是给定的对数2。例如， ``--video-zoom=0`` 是未缩放的， ``--video-zoom=1`` 是尺寸的两倍， ``--video-zoom=-2`` 是尺寸的四分之一，以此类推。

    如果使用了 ``--no-keepaspect`` 选项，这个选项将被禁用。

``--video-scale-x=<value>``, ``--video-scale-y=<value>``
    将视频显示尺寸与给定值相乘（默认：1.0）。如果使用非默认值，这将与窗口尺寸不同，所以视频将被切断，或加入黑条。

    这个值与从 ``--video-zoom`` 得出的值和正常的视频宽高比相乘。如果使用 ``--no-keepaspect`` 选项，这个选项将被禁用。

``--video-align-x=<-1-1>``, ``--video-align-y=<-1-1>``
    在黑色边框内移动视频矩形，如果视频和屏幕的长宽比不同，通常会添加黑色边框来垫高视频和屏幕。 ``--video-align-y=-1`` 会将视频移到屏幕顶部（只在底部留有边框），数值为 ``0`` 会将其居中（默认），数值为 ``1`` 会将视频放在屏幕底部。

    如果视频和屏幕的长宽比完全匹配，这些选项没有任何作用。

    如果使用了 ``--no-keepaspect`` 选项，这个选项将被禁用。

``--video-margin-ratio-left=<val>``, ``--video-margin-ratio-right=<val>``, ``--video-margin-ratio-top=<val>``, ``--video-margin-ratio-bottom=<val>``
    在每个边框上设置额外的视频边距（默认：0）。每个值是窗口大小的比率，使用范围是0.0-1.0。例如，在窗口大小为1000像素时，设置选项 ``--video-margin-ratio-right=0.2`` ，将在窗口的右边增加200像素的边框。

    视频会被这些边距 "框住"。窗口的大小没有改变。特别是它不会放大窗口，而且边距会导致视频默认被缩小。这在将来可能会也可能不会改变。

    边距是在视频旋转90°后应用的，但在任何其他视频转换之前。

    如果使用了 ``--no-keepaspect`` 选项，这个选项将被禁用。

    字幕仍然可以使用边距，取决于 ``--sub-use-margins`` 和类似的选项。

    这些选项是为OSC创建的。一些奇怪的决定，例如使边距值成为一个比率（而不是像素），是为了OSC而作出的。这些选项有可能被那些更普遍有用的选项所取代。这些选项的行为也可能改变，以更好地适应OSC的要求。

``--correct-pts``, ``--no-correct-pts``
    ``--no-correct-pts`` 将mpv切换到使用固定帧率值（使用 ``--fps`` 选项，或使用文件信息）确定视频时间的模式。有时，在这种模式下，具有非常破碎的时间戳的文件可以得到一定程度的播放。请注意，在这种模式下，视频过滤、字幕渲染、搜索（包括hr-seeks和backstepping）和音频同步可能完全被破坏。

``--fps=<float>``
    覆盖视频帧速率。如果原始值是错误的或丢失的，则很有用。

    .. note::

        只在 ``--no-correct-pts`` 模式下工作。

``--deinterlace=<yes|no>``
    启用或禁用隔行扫描（默认：no）。隔行扫描的视频会出现丑陋的梳子状伪影，在快速移动时可见。启用这个功能通常会插入yadif视频过滤器，以便对视频进行去隔行扫描，或者让视频输出应用去隔行扫描（如果支持）。

    这和 ``deinterlace`` 输入属性（通常映射到 ``d`` ）的行为完全一样。

    请记住，这 **会** 与手动插入的去交错滤波器冲突，除非你小心。(从mpv0.27.0开始，即使是硬件去交错滤波器也会发生冲突。也是从那个版本开始， ``--deinterlace=auto`` 被删除了，这意味着可能插入的视频过滤器的默认隔行扫描选项被使用。）

    请注意，如果视频实际上没有隔行扫描，这将使视频看起来更糟。

``--frames=<number>``
    只播放/转换第一个``<number>``视频帧，然后退出。

    ``--frames=0`` 加载文件，但在初始化播放前立即退出。(可能对那些只想确定一些文件属性的脚本很有用)。

    对于纯音频的播放，任何大于0的值都会在初始化后立即退出播放。值0和视频一样。

``--video-output-levels=<outputlevels>``
    用于YUV到RGB转换的RGB色阶。通常情况下，输出设备如PC显示器使用全范围的颜色级别。然而，一些电视和视频监视器希望使用工作室RGB水平。向期望工作室水平输入的设备提供全范围输出，会导致黑色和白色的破碎，反之则会导致黑色和白色的暗淡。

    不是所有的VO都支持这个选项。有些会默默地忽略它。

    可用的颜色范围是。

    :auto:      自动选择（等于全范围）（默认）。
    :limited:   有限的范围（每个组件16-235），工作室水平
    :full:      全范围（每个分量0-255），PC级别

    .. note::

        建议使用你的图形驱动的颜色范围选项，如果有的话。

``--hwdec-codecs=<codec1,codec2,...|all>``
    只允许对一个给定的编解码器列表进行硬件解码。特殊值 ``all`` 总是允许所有的编解码器。

    你可以用 ``mpv --vd=help`` 获得允许的编解码器列表。移除前缀，例如，用 ``h264`` 代替 ``lavc:h264`` 

    默认情况下，这被设置为 ``h264,vc1,hevc,vp8,vp9,av1,prores`` 。请注意，像 ``h264_vdpau`` 这样的硬件加速特殊编解码器已经没有意义了，事实上已经从Libav中删除了这种形式。

    通常只有在坏了的GPU上才需要这样做，在这种情况下，一个编解码器被报告为支持，但解码造成的问题比它解决的要多。

    .. admonition:: 示例

        ``mpv --hwdec=vdpau --vo=vdpau --hwdec-codecs=h264,mpeg2video``
            只对h264和mpeg2启用vdpau解码。

``--vd-lavc-check-hw-profile=<yes|no>``
    检查硬件解码器配置文件（默认：是）。如果设置了 ``no`` ，就会无条件地选择硬件解码器的最高配置，即使视频的配置高于此，也会强制解码。其结果很可能是解码失败，但如果检测到的或报告的配置文件在某种程度上不正确，也可能有帮助。

``--vd-lavc-software-fallback=<yes|no|N>``
    如果硬件加速解码器失败，回落到软件解码（默认：3）。如果这是一个数字，那么如果N个帧连续解码失败，就会触发回退。1相当于 ``yes``

    设置为更高的数字可能会破坏回放开始时的回退：如果回退发生，文件的部分内容将被跳过，大约是无法解码的数据包的数量。低于一个未指定的数值不会有这个问题，因为mpv保留了这些数据包。

``--vd-lavc-dr=<yes|no>``
    启用直接渲染（默认：yes）。如果设置为 ``yes`` ，视频将被直接解码到GPU视频存储器（或暂存缓冲区）。这可以加快视频上传速度，对大分辨率或慢速硬件可能有帮助。这只适用于以下的VO：

        - ``gpu`` : 要求至少有OpenGL 4.4或Vulkan。
        - ``libmpv`` : libmpv渲染API有可选支持。

    使用任何类型的写到图像数据的视频过滤器（或输出新分配的帧）都会默默地禁用DR代码路径。

``--vd-lavc-bitexact``
    在所有解码步骤中只使用比特精确的算法（用于编解码器测试）。

``--vd-lavc-fast`` (MPEG-2, MPEG-4, and H.264 only)
    启用不符合格式规范并可能导致问题的优化，如更简单的去量化，更简单的运动补偿，假设使用默认的量化矩阵，假设为YUV 4:2:0，跳过一些检查以检测损坏的比特流。

``--vd-lavc-o=<key>=<value>[,<key>=<value>[,...]]``
    向libavcodec解码器传递AVOptions。注意，欢迎打一个补丁，使 ``o=`` 不需要，通过AVOption系统传递所有未知的选项。AVOptions的完整列表可以在FFmpeg手册中找到。

    一些曾经是直接选项的选项可以通过这个机制来设置，比如 ``bug``, ``gray``, ``idct``, ``ec``, ``vismv``, ``skip_top`` （原 ``st`` ）, ``skip_bottom`` （原 ``sb`` ）, ``debug``

    这是一个按键/值列表选项。详见 `List Options`_

    .. admonition:: 示例

        ``--vd-lavc-o=debug=pict``

``--vd-lavc-show-all=<yes|no>``
    甚至显示破损/损坏的帧（默认：no）。如果这个选项被设置为no，libavcodec将不会输出在初始关键帧被解码之前被解码的帧，或者被识别为损坏的帧。

``--vd-lavc-skiploopfilter=<skipvalue> (H.264 only)``
    在H.264解码期间跳过循环过滤器（又称解锁）。由于过滤后的帧应该被用作解码附属帧的参考，这对质量的影响比不对MPEG-2视频进行解锁更糟糕。但至少对于高比特率的HDTV来说，这提供了一个很大的速度，而几乎没有明显的质量损失。

    ``<skipvalue>`` 可以是以下的一种：

    :none:    从不跳过。
    :default: 跳过无用的处理步骤（例如AVI中的0尺寸数据包）。
    :nonref:  跳过没有参考的帧（即不用于解码其他帧，错误不能 "积累"）。
    :bidir:   跳过B类帧。
    :nonkey:  跳过所有帧，除了关键帧。
    :all:     跳过所有帧。

``--vd-lavc-skipidct=<skipvalue> (MPEG-1/2 only)``
    跳过IDCT步骤。这在几乎所有情况下都会使质量下降很多(可用的跳过值见skiploopfilter)。

``--vd-lavc-skipframe=<skipvalue>``
    完全跳过帧的解码。速度大增，但动作生硬，有时会出现不良伪影（关于可用的跳过值，请参见 skiploopfilter）。

``--vd-lavc-framedrop=<skipvalue>``
    设置与 ``--framedrop`` 一起使用的成帧掠夺模式（可用的跳过值见skiploopfilter）。

``--vd-lavc-threads=<N>``
    解码时使用的线程数。实际是否支持线程取决于编解码器（默认：0）。0意味着自动检测机器上的核数并使用该核数，最多为16。你可以手动设置16个以上的线程。

``--vd-lavc-assume-old-x264=<yes|no>``
    假设视频是由一个旧的、有问题的x264版本编码的（默认：no）。通常情况下，这是由libavcodec自动检测的。但是如果比特流不包含x264版本信息（或者以某种方式被跳过），并且该流实际上是由旧的x264版本（build 150或更早）编码的，并且如果该流使用 ``4:4:4`` 色度，那么libavcodec将默认显示损坏的视频。这个选项将libavcodec的 ``x264_build`` 选项设置为 ``150`` ，这意味着如果流不包含版本信息，或者根本不是由x264编码的，它就会假定它是由旧版本编码的。如果你想让你损坏的文件正常工作，启用这个选项是非常安全的，但是理论上这可能会损坏不是由x264编码的数据流，或者如果由较新的x264版本编码的数据流不包含版本信息。

``--swapchain-depth=<N>``
    允许最多 N 个飞行中的帧。这实质上控制了帧的延迟。增加交换链深度可以改善流水线并防止错过vsyncs，但会增加可见的延迟。这个选项只规定了一个上限，实现可以使用比内部要求更低的延时。设置为1意味着VO在开始渲染下一帧之前会等待每一帧成为可见的。(默认：3)

Audio
-----

``--audio-pitch-correction=<yes|no>``
    如果启用这个功能（默认），以不同于正常的速度播放会自动插入 ``scaletempo2`` 音频过滤器。详情请见音频过滤器部分。

``--audio-device=<name>``
    使用给定的音频设备。这由音频输出名称组成，例如 ``alsa`` ，后面是 ``/`` ，然后是音频输出的具体设备名称。这个选项的默认值是 ``auto`` ，它以默认设备的优先顺序尝试每个音频输出。

    你可以用``--audio-device=help`` 列出音频设备。这将输出带引号的设备名称，后面是描述。设备名称是你必须传递给 ``--audio-device`` 选项的东西。音频设备的列表可以通过API使用 ``audio-device-list`` 属性来检索。

    虽然该选项通常采取上述方法所指示的字符串之一，但你也可以通过手动构建它来强制大多数AO的设备。例如 ``name/foobar`` 强制AO ``name`` 使用设备 ``foobar`` 。然而， ``--ao`` 选项将严格强制一个特定的AO。为了避免混淆，不要同时使用 ``--ao`` 和 ``--audio-device``

    .. admonition:: ALSA的示例

        MPlayer和mplayer2要求你将ALSA设备名称中的任何','替换为'.'，任何':'替换为'='。例如，要使用名为 ``dmix:default`` 的设备，你必须这样做。

            ``-ao alsa:device=dmix=default``

        在mpv中，你可以改用：

            ``--audio-device=alsa/dmix:default``


``--audio-exclusive=<yes|no>``
    启用独占输出模式。在这种模式下，系统通常被锁定，只有mpv能够输出音频。

    这只对某些音频输出有效，比如 ``wasapi`` 和 ``coreaudio`` 。其他音频输出会默默地忽略这个选项。它们要么没有独占模式的概念，要么就是缺少mpv方面的实现。

``--audio-fallback-to-null=<yes|no>``
    如果没有音频设备被打开，就像给了 ``--ao=null`` 一样。这和 ``--audio-device`` 结合起来很有用：如果选择的设备不存在，客户端API用户（或Lua脚本）可以让播放正常进行，并检查 ``current-ao`` 和 ``audio-device-list`` 属性，以做出关于如何继续的高级决定。

``--ao=<driver>``
    指定要使用的音频输出驱动。参见 `AUDIO OUTPUT DRIVERS`_ 以了解可用驱动的细节和描述。

``--af=<filter1[=parameter1:parameter2:...],filter2,...>``
    指定一个音频过滤器的列表，应用于音频流。关于可用过滤器的细节和描述，请看 `AUDIO FILTERS`_ 。选项变体 ``--af-add``, ``--af-pre``, ``--af-del`` 和 ``--af-clr`` 存在，用于修改先前指定的列表，但在典型使用中不需要这些。

``--audio-spdif=<codecs>``
    应该使用压缩音频直通的编解码器的列表。这对传统的S/PDIF和HDMI都有效。

    可能的编解码器有 ``ac3``, ``dts``, ``dts-hd``, ``eac3``, ``truehd`` 。可以用 ``,`` 分隔多个编解码器来指定。 ``dts`` 指的是低比特率的DTS核心，而 ``dts-hd`` 指的是DTS MA（接收器和操作系统支持不同）。如果同时指定 ``dts`` 和 ``dts-hd`` ，它的作用等同于只指定 ``dts-hd``

    在早期的mpv版本中，你可以使用 ``--ad`` 来强制使用spdif包装器。现在这不起作用了。

    .. admonition:: 警告

        没有什么理由要使用这个。HDMI支持未压缩的多声道PCM，mpv支持通过FFmpeg的新DCA解码器（基于libdcadec）进行无损的DTS-HD解码。

``--ad=<decoder1,decoder2,...[-]>``
    根据解码器的名称，指定一个要使用的音频解码器的优先级列表。当确定使用哪个解码器时，会选择第一个与音频格式匹配的解码器。如果该解码器不可用，则使用下一个解码器。最后，它尝试所有其他没有明确选择或被选项拒绝的解码器。

    列表末尾的 ``-`` 抑制了不在 ``--ad`` 列表中的其他可用解码器的后退。 ``+`` 在一个条目前面，强制使用解码器。这两种方法通常都不应该使用，因为它们破坏了正常的解码器自动选择。这两种方法都被废弃了。

    .. admonition:: 示例

        ``--ad=mp3float``
            优先使用FFmpeg/Libav ``mp3float`` 解码器，而不是其他所有的MP3解码器。

        ``--ad=help``
            列出所有可用的解码器。

    .. admonition:: 警告

        使用该选项不可能启用压缩音频直通（通过SPDIF/HDMI的AC3和DTS）。请使用 ``--audio-spdif`` 代替。

``--volume=<value>``
    设置启动时的音量。0表示无声，100表示没有音量降低或放大。为了兼容，可以传递负值，但会被当作0处理。

    从mpv 0.18.1开始，它总是控制内部混音器（又称 "软音量"）。

``--replaygain=<no|track|album>``
    根据存储在文件元数据中的重放增益值来调整音量增益。使用 ``--replaygain=no`` （默认），不进行调整。用 ``--replaygain=track`` ，应用轨道增益。用 ``--replaygain=album`` ，如果有专辑增益，就应用专辑增益，否则就回落到轨道增益。

``--replaygain-preamp=<db>``
    预放大增益，单位为dB，应用于选定的重放增益（默认：0）。

``--replaygain-clip=<yes|no>``
    通过自动降低增益来防止由重放引起的削波（默认）。使用 ``--replaygain-clip=no`` 来禁用它。

``--replaygain-fallback=<db>``
    如果文件没有重放增益标签，要应用的增益（dB）。如果重放增益逻辑在某种程度上是不活跃的，这个选项总是被应用。如果这个选项被应用，其他重放增益选项就不会被应用。

``--audio-delay=<sec>``
    以秒为单位的音频延迟（正或负的浮动值）。正值是延迟音频，负值是延迟视频。

``--mute=<yes|no|auto>``
    设置启动时的音频静音状态（默认：no）。

    ``auto`` 是一个deprecated的可能值，等同于 ``no`` 。

    也请参见： ``--volume``

``--softvol=<no|yes|auto>``
    已Deprecated/无法使用。在mpv 0.18.1之前，它用来控制是使用音频输出驱动的音量控制还是mpv内部的音量过滤器。

    目前的行为是softvol总是被启用，也就是说，就像这个选项被设置为 ``yes`` 一样。其他行为不再可用，尽管在大多数情况下 ``auto`` 几乎与当前行为一致。

    ``no`` 行为仍然可以通过 ``ao-volume`` 和 ``ao-mute`` 属性部分使用。但是没有选项可以重置这些。

``--audio-demuxer=<[+]name>``
    当使用 ``--audio-file`` 时，使用这种音频解复用器类型。在名称前使用 ``+`` 来强制它；这将跳过一些检查。给出由 ``--audio-demuxer=help`` 打印的解复用器名称。

``--ad-lavc-ac3drc=<level>``
    选择AC-3音频流的动态范围压缩级别。 ``<level>`` 是一个从0到1的浮动值，0表示不压缩（这是默认的），1表示完全压缩（使响亮的段落更安静，反之亦然）。也可以接受高达6的值，但纯粹是实验性的。这个选项只有在AC-3流包含所需的范围压缩信息时才会显示效果。

    标准规定DRC在默认情况下被启用，但mpv（和其他一些播放器）为了更好的音频质量而忽略了这一点。

``--ad-lavc-downmix=<yes|no>``
    是否要求解码器对音频通道进行降频处理（默认：否）。一些解码器，如AC-3、AAC和DTS，可以在解码时重新混合音频。要求的输出通道数是用 ``--audio-channels`` 选项设置的。对于在立体声系统上播放环绕声音频很有用。

``--ad-lavc-threads=<0-16>``
    解码时使用的线程数量。线程是否真正支持取决于编解码器。截至目前，它只支持一些无损编解码器。0表示自动检测机器上的核心数，并使用该核心数，最大为16（默认：1）。

``--ad-lavc-o=<key>=<value>[,<key>=<value>[,...]]``
    将AVOptions传递给libavcodec解码器。注意，欢迎打一个补丁，使o=不需要，并通过AVOption系统传递所有未知的选项。AVOptions的完整列表可以在FFmpeg手册中找到。

    这是一个按键/值列表选项。详见 `List Options`_

``--ad-spdif-dtshd=<yes|no>``, ``--dtshd``, ``--no-dtshd``
    如果DTS是通过的，则使用DTS-HD。

    .. admonition:: 警告

        这和通过 ``--ad`` 启用直通的做法已被deprecated，而使用 ``--audio-spdif=dts-hd``

``--audio-channels=<auto-safe|auto|layouts>``
    控制哪些音频通道被输出（例如，环绕声与立体声）。有以下几种可能性。

    - ``--audio-channels=auto-safe``
        使用系统的首选通道布局。如果没有（比如访问硬件设备而不是系统混音器时），就强制使用立体声。有些音频输出可能只是接受任何布局，并自行进行降频处理。

        这是默认的。
    - ``--audio-channels=auto``
        向音频设备发送它所接受的任何内容，倾向于音频的原始通道布局。可能导致HDMI的问题（见下面的警告）。
    - ``--audio-channels=layout1,layout2,...``
        应该允许的 ``,`` 分隔的通道布局的列表。技术上来说，这只是把过滤器链的输出调整到列表中最匹配的布局，并把结果传递给音频API。音频API有可能会选择一个不同的通道布局。

        对于直接的硬件输出，特别是通过HDMI（见下面的HDMI警告），建议使用这种模式。
    - ``--audio-channels=stereo``
        强制进行纯立体声降混。这是前一项的一个特例。(见下面几段的含义)。

    如果给了一个布局列表，每项可以是一个明确的通道布局名称（如 ``5.1`` ），或一个通道编号。通道号码指的是默认的布局，例如2通道指的是立体声，6指的是5.1。

    参见 ``---audio-channels=help`` 输出，了解定义的默认布局。这也列出了扬声器的名字，可以用来表达任意的通道布局（例如 ``fl-fr-lfe`` 是2.1）。

    如果通道布局列表中只有1项，解码器将被要求产生相应的输出。这有时会触发解码器降混，这可能与正常的mpv降混不同。(只有一些解码器支持重混音频，如AC-3、AAC或DTS。你可以使用 ``--ad-lavc-downmix=no`` 来使解码器总是输出其原始布局）。一个后果是， ``--audio-channels=stereo`` 会触发解码器降频，而 ``auto`` 或 ``auto-safe`` 永远不会，即使他们最终选择立体声。发生这种情况是因为是否使用解码器降频的决定发生在音频设备被打开之前。

    如果媒体文件（即解码器）的通道布局和AO的通道布局不匹配，mpv将尝试插入一个转换过滤器。你可能需要改变系统混频器的通道布局，以达到你想要的输出，因为mpv无法控制它。在一些AO上的另一个解决方法是使用 ``--audio-exclusive=yes`` 来完全规避系统混音器。

    .. admonition:: 警告

        当通过HDMI使用音频时，使用 ``auto`` 会导致问题。操作系统通常会报告所有可以通过HDMI的通道布局，即使接收器不支持它们。如果接收器得到一个不支持的通道布局，就会发生一些随机的事情，如丢弃额外的通道，或增加噪音。

        建议你设置一个你想要的布局的明确白名单。例如，大多数通过HDMI连接的A/V接收机，如果可以做7.1，就可以通过以下方式实现。 ``--audio-channels=7.1,5.1,stereo``

``--audio-display=<no|embedded-first|external-first>``
    决定在播放音频文件时是否显示封面图，以及优先级是多少。它将显示找到的第一张图片，其他图片可作为视频轨道。

    :no:             在播放音频文件时完全禁止显示视频。
    :embedded-first: 显示嵌入式图像和外部封面，优先显示嵌入式图像（默认）。
    :external-first: 显示嵌入式图像和外部封面，优先显示外部文件。

    这个选项对有正常视频轨道的文件没有影响。

``--audio-files=<files>``
    在观看视频时播放外部文件的音频。

    这是一个路径列表选项。详见 `List Options`_

``--audio-file=<file>``
    CLI/配置文件只是 ``--audio-files-append`` 的别名。每次使用这个选项将添加一个新的音轨。细节类似于 ``--sub-file`` 的工作方式。

``--audio-format=<format>``
    选择用于从音频过滤层输出到声卡的采样格式。 ``<format>`` 可以采用的值在下面的 ``format`` 音频滤波器的描述中列出。

``--audio-samplerate=<Hz>``
    选择要使用的输出采样率（当然声卡在这方面有限制）。如果选择的采样频率与当前媒体的不同，lavrresample音频滤波器将被插入音频滤波器层以补偿差异。

``--gapless-audio=<no|yes|weak>``
    尝试播放连续的音频文件，在文件变化的地方没有沉默或中断。默认值： ``weak``

    :no:    禁用无间隙音频。
    :yes:   音频设备使用为第一个播放的文件选择的参数打开，然后为无间隙播放保持开放。这意味着，如果第一个文件的采样率很低，那么后面的文件可能会被重新采样到相同的低采样率，导致声音质量下降。如果你用不同的参数播放文件，考虑使用选项，如 ``--audio-samplerate`` 和 ``--audio-format`` 来明确选择共享的输出格式是什么。
    :weak:  通常情况下，音频设备会保持开放（使用它第一次初始化的格式）。如果解码器输出的音频格式改变了，音频设备会被关闭并重新打开。这意味着你通常会得到使用相同设置编码的文件的无间隙音频，但在其他情况下可能不会是无间隙的。音频设备保持开放的确切条件是一个实现细节，并且可以从不同的版本中改变。目前，即使样本格式改变，设备也会被保留，但样本格式是可以转换的。如果在还有音频的情况下，视频还在进行，试图使用无间隙也是明确放弃的。

    .. note::

        这个功能是以一种简单的方式实现的，在从一个文件转到另一个文件时，依靠音频输出设备的缓冲来继续播放。如果新文件的播放开始得很慢，例如因为它是从远程网络位置播放的，或者因为你指定的缓冲设置需要时间进行初始缓冲填充，那么在新文件的播放开始之前，缓冲的音频可能会用完。

``--initial-audio-sync``, ``--no-initial-audio-sync``
    当开始一个视频文件或在事件发生后，比如寻找，mpv默认会修改音频流，使其与视频从相同的时间戳开始，在开始时插入沉默或切掉第一个样本。禁用这个选项会使播放器表现得像旧版mpv一样：视频和音频都立即开始，即使它们的开始时间戳不同，然后如果有必要，视频时间会逐渐调整，以达到正确的同步。

``--volume-max=<100.0-1000.0>``, ``--softvol-max=<...>``
    设置最大的放大级别，单位是百分比（默认：130）。130的值将允许你将音量调整到正常水平的两倍左右。

    ``--softvol-max`` 是一个deprecated的别名，不应该被使用。

``--audio-file-auto=<no|exact|fuzzy|all>``, ``--no-audio-file-auto``
    加载与视频文件名匹配的额外音频文件。该参数指定了外部音频文件的匹配方式。

    :no:    不要自动加载外部音频文件（默认）。
    :exact: 加载带有音频文件扩展名的媒体文件。
    :fuzzy: 加载所有包含媒体文件名的音频文件。
    :all:   加载当前目录和 ``--audio-file-paths`` 目录下的所有音频文件。

``--audio-file-paths=<path1:path2:...>``
    相当于 ``--sub-file-paths`` 选项，但用于自动加载的音频文件。

    这是一个路径列表选项。详见 `List Options`_

``--audio-client-name=<name>``
    播放器报告给音频API的应用程序名称。如果你想强制使用不同的音频配置文件（例如使用PulseAudio），或者在使用libmpv时设置你自己的应用程序名称，就会很有用。

``--audio-buffer=<seconds>``
    设置音频输出的最小缓冲区。如果音频设备乐意的话，它实际上可能会创建一个更大的缓冲区。如果设备创建了一个较小的缓冲区，额外的音频将被缓冲在一个额外的软件缓冲区中。

    把它变大会使软音量和其他过滤器的反应变慢，在播放速度变化时引入额外的问题，并在音频格式变化时阻止播放器。较小的缓冲区可能会导致音频掉线。

    这个选项应该只用于测试。如果一个非默认值有很大帮助，应该联系mpv的开发者。

    默认： 0.2 (即200ms)

``--audio-stream-silence=<yes|no>``
    抢钱的消费类音频硬件（如A/V接收机）经常忽略通过HDMI发送的初始音频。这可能发生在每次通过HDMI停止和恢复音频的时候。为了弥补这一点，你可以启用这个选项，在寻求时不停止和重新启动音频，用沉默来填补空隙。同样，当暂停播放时，音频也不会停止，暂停时播放的是静音。注意，如果没有选择音轨，音频设备仍然会被立即关闭。

    不是所有的AO都支持这个。

    .. admonition:: 警告

        这修改了某些微妙的播放器行为，如A/V-同步和欠载处理。强烈建议不要启用这个选项。

``--audio-wait-open=<secs>``
    这对与`--audio-stream-silence=yes`` 一起使用有意义。如果给了这个选项，播放器将在打开音频设备后等待给定的秒数，然后再发送实际的音频数据给它。如果你的昂贵的硬件会丢弃前1或2秒的音频数据，那就很有用。如果没有设置 ``--audio-stream-silence=yes`` ，这个选项很可能只是浪费时间。

Subtitles
---------

.. note::

    改变风格和位置对所有的字幕都不起作用。基于图像的字幕（DVD、Bluray/PGS、DVB）由于基本原因不能改变。ASS格式的字幕通常不会被有意改变，但可以用 ``--sub-ass-override`` 来控制覆盖它们。

    以前一些处理文本字幕的选项被称为 ``--sub-text-*`` ，现在它们被命名为 ``--sub-*`` ，而那些专门针对ASS的选项已经从 ``--ass-*`` 改名为 ``--sub-ass-*`` 。它们现在都在这个部分。

``--sub-demuxer=<[+]name>``
    为 ``---sub-file`` 强制使用字幕解扰器类型。给出由 ``--sub-demuxer=help`` 打印的解复用器名称。

``--sub-delay=<sec>``
    将字幕延迟 ``<sec>`` 秒。可以是负数。

``--sub-files=<file-list>``, ``--sub-file=<filename>``
    添加一个字幕文件到外部字幕列表中。

    如果你只使用一次 ``--sub-file`` ，这个字幕文件就会默认显示。

    如果 ``--sub-file`` 被多次使用，可以在运行时通过循环字幕轨道切换要使用的字幕。可以同时显示两个字幕：使用 ``--sid`` 选择第一个字幕索引， ``--secondary-sid`` 选择第二个索引。(索引打印在终端输出的流列表中 ``--sid=`` 之后)。

    ``--sub-files`` 是一个路径列表选项（详见 `List Options`_ ），可以接受多个文件名，用 ``:`` (Unix) 或 ``;`` (Windows)分隔，而 ``--sub-file`` 只接受一个文件名，但可以多次使用来添加多个文件。技术上， ``--sub-file`` 是 ``--sub-files-append`` 的CLI/配置文件的别名。

``--secondary-sid=<ID|auto|no>``
    选择一个二级字幕流。这与 ``--sid`` 相似。如果选择了辅助字幕，它将作为顶部字幕（即在屏幕的顶部）与普通字幕一起呈现，并提供一种同时呈现两个字幕的方法。

    这个功能有一些相关的注意事项。例如，位图字幕将总是在其通常的位置呈现，所以选择位图字幕作为次要字幕将导致字幕重叠。如果视频被禁用，二级字幕永远不会在终端上显示。

    .. note::

        次要字幕的样式和对任何格式化标签的解释都是禁用的。在内部，与 ``--no-sub-ass`` 相同的机制被用来剥离样式设计。

    .. note::

        如果主字幕流包含格式化标签，将字幕显示在屏幕的顶部，它将与副字幕重叠。为了防止这种情况，你可以使用 ``--no-sub-ass`` 来禁用主字幕流中的样式。

``--sub-scale=<0-100>``
    文本副标题字体大小的因素（默认：1）。

    .. note::

        这也会影响ASS字幕，并可能导致不正确的字幕渲染。小心使用，或使用 ``--sub-font-size`` 代替。

``--sub-scale-by-window=<yes|no>``
    是否随窗口大小调整字幕（默认：是）。如果禁用这个功能，改变窗口大小不会改变字幕字体大小。

    和 ``--sub-scale`` 一样，这可能会破坏ASS字幕。

``--sub-scale-with-window=<yes|no>``
    使字幕的字体大小与窗口相对，而不是与视频相对。如果你总是想要相同的字体大小，这很有用，即使视频没有完全覆盖窗口，例如，因为屏幕和窗口的长宽不匹配（而且播放器会添加黑条）。

    默认： yes

    这个选项的名字不对。与听起来令人困惑的类似选项 ``--sub-scale-by-window`` 的区别在于 ``--sub-scale-with-window`` 仍然是根据窗口的近似大小进行缩放，而另一个选项则是禁用这种缩放。

    只影响纯文本字幕（或ASS，如果 ``--sub-ass-override`` 设置得足够高）。

``--sub-ass-scale-with-window=<yes|no>``
    和 ``--sub-scale-with-window`` 一样，但只影响ASS格式的字幕。和 ``--sub-scale`` 一样，这可能会破坏ASS字幕。

    默认值： no

``--embeddedfonts=<yes|no>``
    使用嵌入在Matroska容器文件和ASS脚本中的字体（默认： yes）。这些字体可以用于SSA/ASS字幕的渲染。

``--sub-pos=<0-150>``
    指定字幕在屏幕上的位置。该值是字幕的垂直位置，单位是屏幕高度的%。100是原始位置，通常不是屏幕的绝对底部，而是在底部和字幕之间有一些余量。高于100的数值会使字幕进一步向下移动。

    .. admonition:: 警告

        如果该选项的值高于100，文字字幕（相对于图像字幕）可能会被切断。这是一个libass的限制。

        这也会影响ASS字幕，除了上述问题外，还可能导致不正确的字幕渲染。

        使用 ``--sub-margin-y`` 可以用更好的方式来实现。

``--sub-speed=<0.1-10.0>``
    将字幕事件的时间戳与给定值相乘。可以用来固定基于帧的字幕格式的播放速度。只影响到文本字幕。

    .. admonition:: 例子

        ``--sub-speed=25/23.976`` 播放以帧为基础的字幕，假设帧率为23.976，速度为25FPS。

``--sub-ass-force-style=<[Style.]Param=Value[,...]>``
    覆盖一些风格或脚本信息参数。

    这是一个字符串列表选项。详见 `List Options`_

    .. admonition:: 示例

        - ``--sub-ass-force-style=FontName=Arial,Default.Bold=1``
        - ``--sub-ass-force-style=PlayResY=768``

    .. note::

        使用这个选项可能会导致不正确的字幕渲染。

``--sub-ass-hinting=<none|light|normal|native>``
    设置字体提示类型。<type> 可以是：

    :none:       没有提示（默认）。
    :light:      FreeType自动提示，轻型模式
    :normal:     FreeType自动跳线，正常模式
    :native:     字体的本机界面

    .. admonition:: 警告

        启用提示可能会导致文本位置错误（在它应该与视频背景相匹配的情况下），或者减少一些不好的ASS脚本的动画的平滑度。建议不要使用这个选项，除非真的需要。

``--sub-ass-line-spacing=<value>``
    为SSA/ASS渲染器设置行距值。

``--sub-ass-shaper=<simple|complex>``
    设置libass使用的文本布局引擎。

    :simple:   只使用Fribidi，速度快，不能正确渲染某些语言
    :complex:  使用HarfBuzz，速度较慢，支持更多语言

    ``complex`` 是默认的。如果libass没有针对HarfBuzz进行编译，libass会默默地恢复到 ``simple``

``--sub-ass-styles=<filename>``
    加载在指定文件中找到的所有SSA/ASS风格，并使用它们来渲染文本字幕。文件的语法与SSA/ASS的 ``[V4 Styles]`` / ``[V4+ Styles]`` 部分完全一样。

    .. note::

        使用这个选项可能导致不正确的字幕渲染。

``--sub-ass-override=<yes|no|force|scale|strip>``
    控制是否应该应用用户风格覆盖。请注意，所有这些覆盖都试图在某种程度上聪明地计算出一个字幕是否被认为是一个 "符号"。

    :no:    按照字幕脚本指定的方式渲染字幕，没有覆盖。
    :yes:   应用所有的 ``--sub-ass-*`` 样式覆盖选项。改变这些选项的默认值会导致不正确的字幕渲染（默认）。
    :force: 和 ``yes`` 一样，但也强制使用所有 ``--sub-*`` 选项。可以轻易破坏渲染。
    :scale: 像 ``yes`` ，但也应用 ``--sub-scale``
    :strip: 从根本上剥离副标题的所有ASS标签和样式。这相当于以前的 ``--no-ass`` / ``--no-sub-ass`` 选项。

    这也控制了一些位图字幕的覆盖，以及SRT等格式的HTML标签，尽管该选项的名字是这样的。

``--sub-ass-force-margins``
    如果字幕是ASS格式，在有黑色边框的情况下，启用将顶部字幕和字幕放在黑色边框中。

    默认： no

``--sub-use-margins``
    如果字幕是纯文本格式（或ASS格式，如果 ``--sub-ass-override`` 设置得足够高），当字幕可用时，可以将其置于黑色边框内。

    默认： yes

    从 ``--sub-ass-use-margins`` 改名。如果要把ASS字幕也放在边框中（像旧的选项那样），也要增加 ``--sub-ass-force-margins``

``--sub-ass-vsfilter-aspect-compat=<yes|no>``
    在播放变形视频时拉伸SSA/ASS字幕，与传统VSFilter行为兼容。当视频以方形像素存储时，这个开关没有影响。

    历史上最常用于SSA/ASS字幕格式的渲染器VSFilter有问题，如果视频以变形格式存储，需要缩放显示时，字幕也会被拉长。 这种行为通常是不可取的，较新的VSFilter版本可能会有不同的行为。然而，许多现有的脚本通过在相反的方向上进行修改来补偿拉伸。 因此，如果这类脚本被 "正确 "地显示出来，它们就不会像预期的那样出现。 这个开关可以模拟旧的VSFilter行为（不可取，但许多现有的脚本都希望如此）。

    默认情况下是启用的。

``--sub-ass-vsfilter-blur-compat=<yes|no>``
    根据视频分辨率而不是脚本分辨率来调整 ``\blur`` 标签的大小（默认启用）。这是VSFilter的bug，根据一些人的说法，为了兼容，不能再修复了。

    请注意，这是用实际的视频分辨率来计算偏移比例因子，而不是视频过滤链或视频输出所使用的。

``--sub-ass-vsfilter-color-compat=<basic|full|force-601|no>``
    像(xy-)vsfilter那样纠结颜色（默认：基本）。历史上，VSFilter是不知道颜色空间的。只要使用标清视频（BT.601）的色彩空间，这就没有问题。但是，当一切都转向高清（BT.709）时，VSFilter仍然将RGB颜色转换为BT.601，将它们渲染到视频帧中，并将帧处理到视频输出，这将使用BT.709来转换为RGB。结果是字幕的颜色被弄乱了。后来，在ASS格式的基础上增加了一些不好的黑客，以控制颜色的处理方式。

    :basic: 只处理BT.601->BT.709混合，如果字幕似乎表明这是需要的（默认）。
    :full:  处理完整的 ``YCbCr Matrix`` 头和所有libass和mpv支持的视频色彩空间。这可能会导致角落里的破损，而且对于兼容性来说不是严格需要的（希望如此），这就是为什么这不是默认的。
    :force-601: 强制处理BT.601->BT.709，不考虑字幕头或视频色彩空间。
    :no:    完全禁用颜色处理。所有颜色都是RGB。

    选择除 ``no`` 以外的任何东西都会使字幕颜色依赖于视频色彩空间，例如，理论上不可能在另一个视频文件中重复使用一个字幕脚本。 ``--sub-ass-override`` 选项不影响这个选项的解释。

``--stretch-dvd-subs=<yes|no>``
    在播放变形视频时拉伸DVD字幕，以便在不良的DVD上获得更好的字体效果。当视频以方形像素存储时，这个开关没有效果--虽然对DVD输入来说不可能是这种情况。

    许多工作室在制作DVD时倾向于使用为方形像素设计的位图字体，导致字体在DVD播放机上看起来被拉伸了。这个选项可以解决这个问题，但代价是可能会使一些字幕错位（如手势翻译）。

    默认情况下是禁用的。

``--stretch-image-subs-to-screen=<yes|no>``
    将DVD和其他图像字幕拉伸到屏幕上，忽略视频的边缘。这和 ``--sub-use-margins`` 对文本字幕有类似的效果，只是文本本身会被拉伸，而不仅仅是重新定位。(至少在一般情况下这是不可避免的，因为理论上一个图像位图可以由一个覆盖整个屏幕的位图组成，而播放器不会知道文字部分的确切位置）。

    这个选项不能正确显示字幕。使用时要小心。

    默认情况下是禁用的。

``--image-subs-video-resolution=<yes|no>``
    用视频分辨率覆盖图像字幕的分辨率（默认：否）。通常情况下，字幕画布是适合视频画布的（例如，信箱式）。设置这个选项可以使用视频尺寸作为字幕画布尺寸。可以用来测试破碎的字幕，这在视频被转码时经常发生，同时试图保留旧的字幕。

``--sub-ass``, ``--no-sub-ass``
    原生渲染ASS字幕（默认启用）。

    .. note::

        这已经被 ``--sub-ass-override=strip`` 所淘汰。你可能还需要 ``--embeddedfonts=no`` 来获得同样的行为。另外，使用 ``--sub-ass-override=style`` 应该会有更好的效果，而不会对字幕造成太大影响。

    如果指定了 ``--no-sub-ass`` ，所有的标签和样式声明都会被剥离并在显示时被忽略。字幕渲染器使用 ``--sub-`` 选项所指定的字体样式来代替。

    .. note::

        使用 ``--no-sub-ass`` 可能会导致ASS/SSA字幕的渲染不正确或完全损坏。有时强行覆盖ASS字幕的风格是有用的，但一般情况下应该避免。

``--sub-auto=<no|exact|fuzzy|all>``, ``--no-sub-auto``
    加载与视频文件名匹配的额外字幕文件。该参数指定了外部字幕文件的匹配方式。默认情况下， ``exact`` 被启用。

    :no:    不要自动加载外部字幕文件。
    :exact: 加载带有字幕文件扩展名和可能的语言后缀的媒体文件名（默认）。
    :fuzzy: 加载包含媒体文件名的所有字幕。
    :all:   加载当前和 ``--sub-file-paths`` 目录下的所有子文件。

``--sub-codepage=<codepage>``
    你可以用这个选项来指定字幕编码，uchardet将被用来猜测字符集。(如果mpv没有用uchardet编译，那么 ``utf-8`` 是有效的默认值)。

    这个选项的默认值是 ``auto`` ，它启用自动检测。

    依次采取以下步骤来确定最终的编码页：

    - 如果特定的编码页有 ``+`` ，则使用该编码页
    - 如果数据看起来像UTF-8，就假定它是UTF-8
    - 如果 ``--sub-codepage`` 被设置为一个特定的码表，则使用该码表
    - 运行uchardet，如果成功，则使用该代码。
    - 否则，使用 ``UTF-8-BROKEN``

    .. admonition:: 示例

        - ``--sub-codepage=latin2`` 如果输入不是UTF-8，则使用Latin 2。
        - ``--sub-codeepage=+cp1250`` 总是强制重新编码为cp1250。

    伪码表 ``UTF-8-BROKEN`` 是内部使用的。如果它被设置，字幕被解释为UTF-8，"Latin 1 "作为非有效UTF-8序列的后备字节。 iconv从不参与这种模式。

    这个选项在mpv0.23.0中改变了。对旧语法的支持在mpv0.24.0中被完全删除。

    .. note::

        这只适用于文本字幕文件。其他类型的字幕（特别是mkv文件中的字幕）总是被假定为UTF-8。


``--sub-fix-timing=<yes|no>``
    调整字幕时间是为了消除字幕之间的微小差距或重叠（如果差距小于210毫秒，差距或重叠会被删除）。

``--sub-forced-only=<auto|yes|no>``
    只显示由 ``--slang`` 等选择的DVD字幕流的强制字幕（默认： ``auto`` ）。当设置为 ``auto`` 时，当 ``--subs-with-matching-audio`` 选项打开并且选择了非强制字幕流时启用。启用这个选项将隐藏流中的所有字幕，因为流中没有区分强制和非强制的事件。

``--sub-fps=<rate>``
    指定字幕文件的帧速率（默认：视频帧速率）。只影响文本字幕。

    .. note::

        ``<rate>`` > 视频帧率对基于帧的字幕文件加速，对基于时间的字幕文件减慢。

    也请参见： ``--sub-speed``

``--sub-gauss=<0.0-3.0>``
    对图像字幕应用高斯模糊（默认： 0）。这可以帮助使像素化的DVD/Vobsubs看起来更漂亮。除了0以外的值还可以切换到软件字幕的缩放。可能会很慢。

    .. note::

        从不应用于文本字幕。

``--sub-gray``
    将图像字幕转换成灰度。可以帮助使黄色DVD/Vobsubs看起来更漂亮。

    .. note::

        从不应用于文本字幕。

``--sub-paths=<path1:path2:...>``
    已Deprecated，使用 ``--sub-file-paths``

``--sub-file-paths=<path-list>``
    指定额外的目录来搜索匹配视频的字幕。多个目录可以用":"（在Windows下为";"）隔开。路径可以是相对的或绝对的。相对路径被解释为相对于视频文件目录。如果文件是一个URL，只有绝对路径和 ``sub`` 配置子目录会被扫描。

    .. admonition:: 示例

        假设 ``/path/to/video/video.avi`` 被播放并且 ``--sub-file-paths=sub:subtitles`` 被指定，mpv在这些目录中搜索字幕文件。

        - ``/path/to/video/``
        - ``/path/to/video/sub/``
        - ``/path/to/video/subtitles/``
        - ``sub`` 配置子目录（通常是 ``~/.config/mpv/sub/`` ）

    这是一个路径列表选项。详见 `List Options`_

``--sub-visibility``, ``--no-sub-visibility``
    可以用来禁止显示字幕，但仍可选择和解码。

``--secondary-sub-visibility``, ``--no-secondary-sub-visibility``
    可用于禁止显示二级字幕，但仍可选择和解码。

    .. note::

        如果 ``--sub-visibility=no`` ，无论`---次可见性'如何，次要字幕都被隐藏。

``--sub-clear-on-seek``
    (不明显，很少有用。)可以用来播放有重复ReadOrder字段的破碎mkv文件。ReadOrder是Matroska式ASS字幕包的第一个字段。它应该是唯一的，libass使用它来快速消除重复的内容。这个选项禁用了跨寻址的字幕缓存，因此在寻址之后，libass不能消除与先前的数据包具有相同ReadOrder的字幕包。

``--teletext-page=<1-999>``
    这适用于 ``dvb_teletext`` 字幕流，如果FFmpeg在编译时支持它。

``--sub-past-video-end``
    在视频的最后一帧之后，如果这个选项被启用，字幕将继续根据音频的时间戳来更新。否则，最后一帧视频的字幕将留在屏幕上。

    默认： 禁用

``--sub-font=<name>``
    为本身没有指定特定字体的字幕指定使用的字体。默认是 ``sans-serif``

    .. admonition:: 示例

        - ``--sub-font='Bitstream Vera Sans'``
        - ``--sub-font='Comic Sans MS'``

    .. note::

        在渲染ASS字幕时， ``--sub-font`` 选项（以及许多其他与风格相关的 ``--sub-`` 选项）会被忽略，除非指定 ``--no-sub-ass`` 选项。

        这用于支持fontconfig模式。从libass0.13.0开始，它不再工作。

``--sub-font-size=<size>``
    指定子字体的大小。单位是窗口高度为720时按比例计算的像素大小。实际的像素大小随着窗口高度的变化而变化：如果窗口高度大于或小于720，文字的实际大小也会随之增加或减少。

    默认： 55

``--sub-back-color=<color>``
    参见 ``--sub-color`` 。用于子文本背景的颜色。你可以使用 ``--sub-shadow-offset`` 来改变它相对于文字的大小。

``--sub-blur=<0..20.0>``
    高斯模糊系数。0意味着不应用模糊（默认）。

``--sub-bold=<yes|no>``
    加粗文本的格式。

``--sub-italic=<yes|no>``
    以斜体字格式显示文本。

``--sub-border-color=<color>``
    参见 ``--sub-color`` 。用于副字体边框的颜色。

``--sub-border-size=<size>``
    副字体边框的大小，按像素比例计算（详见 ``--sub-font-size`` ）。值为0时，禁用边框。

    默认： 3。

``--sub-color=<color>``
    指定用于未定型文本字幕的颜色。

    颜色是以 ``r/g/b`` 的形式指定的，其中每个颜色成分被指定为0.0到1.0范围内的数字。也可以通过使用 ``r/g/b/a`` 来指定透明度，其中alpha值0表示完全透明，1.0表示不透明。如果没有给出alpha分量，颜色就是100%不透明的。

    给选项传递一个数字，就可以把子设置为灰色，而``gray/a``的形式可以让你额外指定alpha。

    .. admonition:: 示例

        - ``--sub-color=1.0/0.0/0.0`` 设置子色为不透明的红色
        - ``--sub-color=1.0/0.0/0.0/0.75`` 设置子颜色为不透明的红色和75%的alpha
        - ``--sub-color=0.5/0.75`` 设置子色为50%灰色，75%alpha

    另外，颜色可以被指定为RGB十六进制三联体，形式为 ``#RRGGBB`` ，其中每个2位数字组表示0（ ``00`` ）到255（ ``FF`` ）范围内的一个颜色值。例如， ``#FF0000`` 是红色。这与网页颜色类似。α是用 ``#AARRGGBB`` 来表示的。

    .. admonition:: 示例

        - ``--sub-color='#FF0000'`` 设置sub为不透明的红色
        - ``--sub-color='#C0808080'`` 设置sub为50%灰色，75%alpha

``--sub-margin-x=<size>``
    子屏幕的左右边距，按比例像素计算（详见 ``--sub-font-size`` ）。

    这个选项指定了子文本到左边的距离，以及长子文本到右边边界的哪个距离会被打断。

    默认： 25

``--sub-margin-y=<size>``
    子文本的顶部和底部的屏幕边距，按比例像素计算（详见 ``--sub-font-size`` ）。

    这个选项指定了未定型的文本字幕的垂直边距。如果你只想提高垂直字幕的位置，使用 ``--sub-pos``

    默认： 22

``--sub-align-x=<left|center|right>``
    控制文本字幕应该对准屏幕的哪个角落（默认： ``center``）

    除了在 ``--no-sub-ass`` 模式下，从不应用于ASS字幕。同样，这也不适用于图像字幕。

``--sub-align-y=<top|center|bottom>``
    垂直位置（默认： ``bottom`` ）。详见 ``--sub-align-x``

``--sub-justify=<auto|left|center|right>``
    控制多行子句的对齐方式，无论它们在哪里对齐（默认： ``auto`` ，按照 ``--sub-align-x`` 的定义进行对齐）。推荐使用左对齐，使子句更容易阅读，因为它对眼睛更有利。

``--sub-ass-justify=<yes|no>``
    如果 ``--sub-ass-override`` 没有设置为 ``no`` ，则在ASS字幕上应用 ``--sub-justify`` 所定义的对齐方式。默认： ``no``

``--sub-shadow-color=<color>``
    见 ``--sub-color`` 。用于子文本阴影的颜色。

    .. note::

        当指定 ``--sub-back-color`` 时被忽略（或者更确切地说：当该选项没有被设置为完全透明时）。

``--sub-shadow-offset=<size>``
    子文本阴影的位移，按比例像素计算（详见 ``--sub-font-size`` ）。值为0时，阴影将被禁用。

    默认： 0

``--sub-spacing=<size>``
    水平副字体间距，按比例像素计算（详见 ``--sub-font-size`` ）。这个值会加到正常的字母间距上。负值是允许的。

    默认： 0

``--sub-filter-sdh=<yes|no>``
    应用过滤器去除为聋人或重听者（SDH）添加的字幕。这是为英语准备的，但也可能部分适用于其他语言。其目的是，它可以一直被启用，所以可能不会删除所有添加的部分。它可以删除说话人标签（如MAN:）、括号内的大写文字和任何括号内的文字。

    默认： ``no``

``--sub-filter-sdh-harder=<yes|no>``
    做更难的SDH过滤（如果由 ``--sub-filter-sdh`` 启用）。也将删除扬声器标签和括号内使用小写和大写字母的文本。

    默认： ``no``

``--sub-filter-regex-...=...``
    设置一个正则表达式列表来匹配文本字幕，并删除任何匹配的行（默认：空）。这是一个字符串列表选项。详见 `List Options`_ 。通常，你应该使用 ``--sub-filter-regex-append=<regex>`` ，每一个选项的使用都会附加一个新的正则表达式，而不需要对抗转义问题。

    列表项是按顺序匹配的。如果一个正则表达式匹配，这个过程就会停止，字幕行被丢弃。默认情况下，匹配的文本是ASS事件的 ``Text`` 字段（如果副标题格式不同，它总是被转换）。这可能包括格式化标签。匹配是不分大小写的，但如何做到这一点取决于libc，而且很可能只在ASCII中工作。它对位图/图像字幕不起作用。在劣质操作系统上不可用（需要POSIX regex支持）。

    .. admonition:: 示例

        ``--sub-filter-regex-append=opensubtitles\.org`` 过滤一些广告。

    从技术上讲，使用列表进行匹配是多余的，因为你可以只使用一个组合的正则表达式。但它有助于诊断，便于使用，以及临时禁用或启用单个过滤器。

    .. warning::

        这是实验性的。语义很可能会改变，如果你使用这个，你应该准备好以后更新这个选项。想法包括用一个非常原始和小的sed子集来代替regexes，或者用一些方法来控制大小写敏感度。

``--sub-filter-jsre-...=...``
    与 ``--sub-filter-regex`` 相同，但使用JavaScript正则表达式。分享/受所有 ``--sub-filter-regex-*`` 控制选项影响（见下文），也是试验性的。只需要JavaScript支持。

``--sub-filter-regex-plain=<yes|no>``
    是否首先将ASS "文本 "字段转换为纯文本（默认： no）。这将剥离ASS标签并应用ASS指令，如 ``\N`` 到换行。如果结果是多行的，那么重构表达式锚点 ``^`` 和 ``$`` 会匹配每一行，但任何匹配都会丢弃所有行。

``--sub-filter-regex-warn=<yes|no>``
    用警告日志级别记录被丢弃的行，而不是粗略的（默认：没有）。对测试有帮助.

``--sub-filter-regex-enable=<yes|no>``
    是否启用regex过滤（默认： yes）。注意，如果在 ``--sub-filter-regex`` 列表中没有添加任何重词，将此选项设置为`是'没有任何作用。它是为了方便临时禁用或启用过滤功能。

``--sub-create-cc-track=<yes|no>``
    对于每个视频流，创建一个闭合字幕轨道（默认： no）。唯一的目的是使轨道在播放开始时可以选择，而不是懒散地创建它。这只适用于 ``ATSC A53 Part 4 Closed Captions`` （由mpv使用编解码器 ``eia_608`` 作为字幕轨道显示）。CC轨道被标记为 "默认"，并根据正常的字幕轨道选择规则来选择。然后你也可以使用 ``--sid`` 来明确选择正确的轨道。

    如果视频流不包含闭合字幕，或者没有视频被解码，CC轨道将保持空白，不显示任何文本。

``--sub-font-provider=<auto|none|fontconfig>``
    使用哪种libass字体提供者的后端（默认： auto）。 ``auto`` 将尝试使用本地字体提供者：Linux上的fontconfig，macOS上的CoreText，Windows上的DirectWrite。 ``fontconfig`` 会强制使用fontconfig，如果libass在构建时支持的话（如果不支持，它的行为与 ``none`` 相似）。

    ``none`` 字体提供者有效地禁用了系统字体。它仍然会尝试使用嵌入式字体（除非设置了 ``--embeddedfonts=no`` ；这与所有其他字体提供者的行为相同），如果提供了 ``subfont.ttf`` ，如果提供了 ``fonts`` 子目录下的字体。(回退比其他字体提供者更严格，如果一个字体名称不匹配，它可能宁愿不渲染任何使用缺失字体的文本)。

Window
------

``--title=<string>``
    设置窗口的标题。这用于视频窗口，如果可能的话，也设置音频流标题。

    属性被扩展。(见 `Property Expansion`_ )

    .. warning::

        这有可能导致大量的CPU占用，这取决于使用的属性。改变窗口的标题通常是一个缓慢的操作，如果标题每一帧都在变化，播放就会被破坏。

``--screen=<default|0-32>``
    在多显示器配置中（即一个桌面横跨多个显示器），这个选项告诉mpv在哪个屏幕上显示视频。

    .. admonition:: 注意 (X11)

        这个选项并不能在所有的窗口管理器中正常工作。在这种情况下，你可以尝试使用 ``--geometry`` 来明确定位窗口。也有可能是窗口管理器提供了本地功能来控制应用程序窗口应该使用哪些屏幕。

    参见 ``--fs-screen``

`--screen-name=<string>```。
    在多显示器配置中，这个选项告诉mpv根据来自视频后端的屏幕名称在哪个屏幕上显示视频。 ``--screen`` 选项中的注意事项也适用于此。如果 ``--screen`` 是明确设置的，这个选项将被忽略，并且没有任何作用。

``--fullscreen``, ``--fs``
    全屏播放。

``--fs-screen=<all|current|0-32>``
    在多显示器配置中（即一个桌面跨越多个显示器），这个选项告诉mpv要全屏到哪个屏幕。如果使用 ``current`` ，mpv将回到用户提供的 ``screen`` 选项上。

    .. admonition:: 注意 (X11)

        这个选项只有在理解EWMH ``_NET_WM_FULLSCREEN_MONITORS`` 提示的窗口管理器中才能正常工作。

    .. admonition:: 注意(macOS)

        ``all`` 在macOS上不起作用，会像 ``current`` 一样。

    参见 ``--screen``

``--fs-screen-name=<string>``
    在多显示器配置中，这个选项告诉mpv根据视频后台的屏幕名称进入全屏。与 ``--fs-screen`` 选项中的注意事项同样适用于此。如果 ``--fs-screen`` 是明确设置的，这个选项将被忽略，并且没有任何作用。

``--keep-open=<yes|no|always>``
    当播放或搜索超过文件的末尾，并且没有下一个文件要播放时，不要终止播放（并且不使用 ``--loop`` ）。相反，暂停播放器。当试图在文件结束后寻找时，播放器将试图寻找到最后一帧。

    通常情况下，这就像在EOF时 ``set pause yes`` 一样，除非设置了 ``--keep-open-pause=no`` 选项。

    可以给出以下参数：

    :no:        如果当前文件结束，转到下一个文件或终止。(默认值。)
    :yes:       如果当前文件是最后一个播放列表条目，不要终止。相当于 ``--keep-open`` ，没有参数。
    :always:    和 ``yes`` 一样，但也适用于最后一个播放列表项目之前的文件。这意味着播放将不会自动推进到下一个文件。

    .. note::

        当使用 ``--frames`` 时，这个选项不被尊重。如果绑定使用 ``force`` ，明确地跳到下一个文件，也会终止播放。

        另外，如果发生错误或异常情况，播放器还是可以退出。

    从mpv0.6.0开始，如果播放列表中有下一个文件，或者播放列表是循环的，这就不会暂停了。近似地，这将在播放器正常退出时暂停，但在实践中，有一些角落的情况不是这样的（例如， ``mpv --keep-open file.mkv /dev/null`` 将正常播放file.mkv，然后无法打开 ``/dev/null`` ，然后退出）。(在mpv0.8.0中， ``always`` 被引入，它恢复了旧的行为)。

``--keep-open-pause=<yes|no>``
    如果设置为 ``no`` ，当 ``--keep-open`` 激活时，不会暂停，而只是在文件结束时停止，当你向后搜索时继续向前播放，直到结束时再次停止。默认： ``yes``

``--image-display-duration=<seconds|inf>``
    如果当前文件是图像，播放图像的时间为给定的秒数（默认为1）。 ``inf`` 表示该文件永远保持开放（直到用户手动停止播放）。

    与 ``--keep-open`` 不同，播放器不会暂停，只是继续播放直到时间结束。(在 "播放 "期间，它不应该使用任何资源)。

    这影响到图像文件，它被定义为只有1个视频帧，没有音频。播放器可能会将某些非图像识别为图像，例如，如果 ``--length`` 被用来减少长度为1帧，或者如果你寻找到最后一帧。

    这个选项不影响用于 ``mf://`` 或 ``--merge-files`` 的帧速率。为此，请使用 ``--mf-fps`` 代替。

    设置 ``--image-display-duration`` 隐藏OSC，不在命令行输出中跟踪播放时间，也不在编码时重复图像帧。要迫使播放器进入 "哑巴模式 "并实际计数，或在编码时复制图像，你需要使用 ``--demuxer=lavf --demuxer-lavf-o=loop=1`` ，并使用 ``--length`` 或 ``--frames`` 在特定时间后停止。

``--force-window=<yes|no|immediate>``
    即使没有视频，也要创建一个视频输出窗口。当假装mpv是一个GUI应用程序时，这可能很有用。目前，该窗口的大小总是640x480，并受 ``--geometry`` 、 ``--autofit`` 和类似选项的制约。

    .. warning::

        窗口只在初始化后创建（以确保在视频尺寸与 ``--force-window`` 默认窗口尺寸不同的情况下，默认的窗口放置仍然有效）。如果初始化工作不完美，这可能是一个问题，比如在网络连接不好的情况下打开URL，或者打开破碎的视频文件。

``--taskbar-progress``, ``--no-taskbar-progress``
    (仅Windows) 启用/禁用任务栏中的播放进度渲染（Windows 7及以上）。

    默认启用。

``--snap-window``
    (仅适用于Windows) 将播放器窗口固定在屏幕边缘。

``--ontop``
    使播放器窗口停留在其他窗口的顶部。

    在Windows上，如果与全屏模式相结合，这将导致mpv被视为绕过桌面窗口管理器的专属全屏窗口。

``--ontop-level=<window|system|desktop|level>``
    (仅限macOS) 设置顶部窗口的级别（默认为window）。

    :window:  在所有其他窗口之上。
    :system:  在系统元素之上，比如任务栏、菜单栏和Dock。
    :desktop: 在窗口和桌面图标后面的Dekstop上面。
    :level:   一个整数的级别。

``--focus-on-open``, ``--no-focus-on-open``
    (仅限macOS) 在创建时聚焦视频窗口，使其成为最前面的窗口。这在默认情况下是打开的。

``--border``, ``--no-border``
    播放带有窗口边框和装饰的视频。由于这是默认开启的，使用 ``--no-border`` 来禁用标准窗口装饰。

``--on-all-workspaces``
    (仅X11和macOS) 在所有虚拟桌面上显示视频窗口。

``--geometry=<[W[xH]][+-x+-y][/WS]>``, ``--geometry=<x:y>``
    调整初始窗口的位置或大小。 ``W`` 和 ``H`` 以像素为单位设置窗口大小。 ``x`` 和 ``y`` 设置窗口位置，从屏幕的左上角到正在显示的图像的左上角，以像素计算。如果在参数后面给了一个百分比符号（ ``%`` ），就会把这个值变成该方向上屏幕尺寸的百分比。位置的指定类似于标准的X11 ``--geometry`` 选项格式，例如，+10-50表示 "从左边框开始放置10个像素，从下边框开始放置50个像素"，"-20+-10 "表示 "从右边框开始放置20个像素，从上边框开始放置10个像素"。尾部的 ``/`` 后面是一个整数，表示窗口应该出现在哪个工作区（虚拟桌面）（仅限X11）。

    如果使用 ``--wid`` 选项指定一个外部窗口，这个选项将被忽略。

    对于完全支持 ``--screen`` 的视频输出驱动，坐标是相对于 ``--screen`` 给出的屏幕的。

    .. note::

        一般来说只被GUI VO支持。编码时忽略不计。

    .. admonition: 注意 (macOS)

        在macOS上，屏幕坐标系的原点位于左下角。例如， ``0:0`` 将把窗口放在屏幕的左下方。

    .. admonition:: 注意 (X11)

        这个选项并不能在所有的窗口管理器中正常工作。

    .. admonition:: 示例

        ``50:40``
            将窗口放在x=50, y=40的位置。
        ``50%:50%``
            将窗口放置在屏幕的中间。
        ``100%:100%``
            将窗口放置在屏幕的右下角。
        ``50%``
            将窗口宽度设置为屏幕宽度的一半。窗口高度的设置是为了使窗口具有视频长宽比。
        ``50%x50%``
            强制窗口的宽度和高度为屏幕宽度和高度的一半。将显示黑色边框，以补偿视频的长宽比（与大多数VO和没有 ``--no-keepaspect`` ）。
        ``50%+10+10/2``
            将窗口设置为屏幕宽度的一半，并将其定位在屏幕左上角下方/左边10个像素，在第二个工作区。

    参见 ``--autofit`` 和 ``--autofit-larger`` ，用于在不改变长宽比的情况下将窗口装入指定尺寸。

``--autofit=<[W[xH]]>``
    将初始窗口尺寸设置为由 ``WxH`` 指定的最大尺寸，不改变窗口的长宽比。尺寸以像素为单位，如果数字后面有百分比符号（ ``%`` ），则以屏幕尺寸的百分数为单位。

    这个选项不会改变窗口的长宽比。如果长宽比不匹配，窗口的尺寸就会缩小，直到适合指定的尺寸。

    窗口的位置不被考虑，也不被这个选项修改（窗口管理器仍然可能根据尺寸的不同来放置窗口）。使用 ``--geometry`` 来改变窗口的位置。它的效果会在这个选项之后应用。

    参见 ``--geometry`` 以了解如何处理多显示器设置的细节。

    如果你只想限制窗口的最大尺寸，而不是总是强制要求窗口尺寸，请使用 ``--autofit-larger`` 代替。

    如果你想把窗口的宽度和高度都强制到一个特定的尺寸，请使用 ``--geometry``

    .. note::

        一般来说只被GUI VO支持。编码时忽略不计。

    .. admonition:: 示例

        ``70%``
            使窗口宽度为屏幕尺寸的70%，保持宽高比。
        ``1000``
            设置窗口宽度为1000像素，保持长宽比。
        ``70%x60%``
            使窗口尽可能大，不超过屏幕宽度的70%，或高于屏幕高度的60%。

``--autofit-larger=<[W[xH]]>``
    这个选项的行为与 ``--autofit`` 完全一样，只是只有在窗口会大于指定的尺寸时才会改变窗口尺寸。

    .. admonition:: 示例

        ``90%x80%``
            如果视频大于屏幕宽度的90%或屏幕高度的80%，使窗口变小，直到其宽度为屏幕的90%，或高度为屏幕的80%。

``--autofit-smaller=<[W[xH]]>``
    这个选项的行为与 ``--autofit`` 完全一样，只是它设置了窗口的最小尺寸（就像 ``--autofit-larger`` 设置的最大尺寸一样）。

    .. admonition:: 示例

        ``500x500``
            使窗口至少有500像素宽和500像素高（根据视频的长宽比，宽度或高度将大于500，以保持长宽比相同）。

``--window-scale=<factor>``
    将视频窗口的大小调整为视频大小的倍数（或分数）。这个选项在 ``--autofit`` 和其他选项应用之前应用（所以它们覆盖这个选项）。

    例如， ``--window-scale=0.5`` 将显示窗口为视频尺寸的一半。

``--window-minimized=<yes|no>``
    视频窗口是否被最小化。如果当前VO支持的话，设置这个将最小化或取消最小化视频窗口。注意，有些VO可能支持最小化而不支持取消最小化（例如：Wayland）。

    这个选项和 ``--window-maximized`` 是在程序启动时还是在运行时工作，以及它们是否（在运行时）被更新以反映实际的窗口状态，很大程度上取决于VO和窗口系统。有些VO根本没有实现它们或其中的一部分，而其他VO可能受到窗口系统的限制（尤其是Wayland）。

``--window-maximized=<yes|no>``
    视频窗口是否被最大化。如果当前VO支持的话，设置这个选项将使视频窗口最大化，或取消最大化。更多信息请参见`--窗口最小化'。

``--cursor-autohide=<number|no|always>``
    使鼠标指针在给定的毫秒数后自动隐藏。 ``no`` 将禁用光标自动隐藏功能。 ``always`` 表示光标将保持隐藏。

``--cursor-autohide-fs-only``
    如果给出这个选项，光标在窗口模式下总是可见的。在全屏模式下，光标会根据 ``--cursor-autohide`` 显示或隐藏。

``--no-fixed-vo``, ``--fixed-vo``
    ``--no-fixed-vo`` 强制关闭和重新打开多个文件的视频窗口（每个文件都有一个（非）初始化）。

``--force-rgba-osd-rendering``
    改变一些视频输出渲染OSD和文本字幕的方式。这并不改变字幕的外观，只对性能有影响。对于支持本地ASS渲染的VO（如 ``gpu``, ``vdpau``, ``direct3d`` ），这可能会稍快或稍慢，取决于GPU驱动和硬件。对于其他虚拟主机，这只是使渲染速度变慢。

``--force-window-position``
    每当视频参数、视频流或文件有变化时，强制将mpv的视频输出窗口移到默认位置。这曾经是默认行为。目前只影响到X11 VO。

``--no-keepaspect``, ``--keepaspect``
    ``--no-keepaspect`` 会一直将视频拉伸到窗口大小，并禁用窗口管理器的提示，强制窗口长宽比。(在全屏模式下被忽略)。

``--no-keepaspect-window``, ``--keepaspect-window``
    ``--keepaspect-window`` (默认)会将窗口尺寸锁定在视频长宽上。 ``--no-keepaspect-window`` 禁用这一行为，如果窗口的长宽和视频的长宽不匹配，则会增加黑条。这是否真的有效，取决于VO的后端。(在全屏模式下会被忽略）。

``--monitoraspect=<ratio>``
    设置你的显示器或电视屏幕的长宽比。如果数值为0，则禁用之前的设置（例如在配置文件中）。如果启用，将覆盖 ``--monitorpixelaspect`` 的设置。

    参见 ``--monitorpixelaspect`` 和 ``--video-aspect-override``

    .. admonition:: 示例

        - ``--monitoraspect=4:3`` 或 ``--monitoraspect=1.3333``
        - ``--monitoraspect=16:9`` 或 ``--monitoraspect=1.7777``

``--hidpi-window-scale``, ``--no-hidpi-window-scale``
    (仅限macOS, Windows, X11, 和Wayland) 根据支持的比例系数来调整窗口大小（默认：是）。在普通的HiDPI分辨率下，窗口以双倍的尺寸打开，但在非HiDPI分辨率下看起来有相同的尺寸。这在macOS上是默认启用的。

``--native-fs``, ``--no-native-fs``
    (仅macOS) 使用操作系统的原生全屏机制(默认： yes)。

``--monitorpixelaspect=<ratio>``
    设置你的显示器或电视屏幕的单个像素的长宽比（默认：1）。1的值意味着方形像素（对（几乎）所有的LCD都是正确的）。参见 ``--monitoraspect`` 和 ``--video-aspect-override``

``--stop-screensaver``, ``--no-stop-screensaver``
    在启动时关闭屏幕保护程序（或屏幕空白程序和类似机制），在退出时再次打开（默认： yes）。当播放器暂停时，屏保总是被重新启用。

    这不是在所有的视频输出或平台上都支持。有时它被实现了，但并不工作（特别是在Linux "桌面 "上）。请仔细阅读 `Disabling Screensaver`_ 部分。

``--wid=<ID>``
    这告诉mpv附加到一个现有的窗口。如果选择了支持该选项的VO，它将使用该窗口进行视频输出。mpv将根据该窗口的大小缩放视频，如果视频的长宽比不同，将添加黑条来补偿。

    在X11上，该ID被解释为X11上的 ``Window`` 。与MPlayer/mplayer2不同，mpv总是创建自己的窗口，并将wid窗口设置为父窗口。窗口将总是被调整大小以完全覆盖父窗口。值 ``0`` 被特别解释，mpv将直接在根窗口上绘图。

    在win32上，ID被解释为 ``HWND`` 。Pass it as value cast to ``intptr_t``. mpv将创建自己的窗口，并将窗口设置为父窗口，就像X11一样。

    在macOS/Cocoa上，ID被解释为 ``NSView*`` 。把它作为值传递给 ``intptr_t`` ，mpv将创建自己的子视图。因为macOS不支持外来进程的窗口嵌入，这只适用于libmpv，从命令行使用时会崩溃。

    在Android上，ID会被解释为 ``android.view.Surface`` 。把它作为一个值传递给 ``intptr_t`` 。与 ``--vo=mediacodec_embed`` 和 ``--hwdec=mediacodec`` 一起使用，以便使用MediaCodec直接渲染，或者与 ``--vo=gpu --gpu-context=android`` 一起使用（无论是否有 ``--hwdec=mediacodec-copy`` ）。

``--no-window-dragging``
    在点击窗口和移动鼠标指针时，不要移动窗口。

``--x11-name``
    为基于X11的视频输出方法设置窗口类名称。

``--x11-netwm=<yes|no|auto>``
    (仅X11) 控制NetWM协议功能的使用。

    这可能对破损的窗口管理器有帮助，也可能没有。这提供了一些已被删除的 ``--fstype`` 选项实现的功能。实际上，开发人员并不知道这个选项需要到什么程度，所以欢迎反馈。

    具体来说， ``--fstype`` 将强制使用NetWM的全屏支持，即使WM没有宣传过。这对那些故意破坏的WM很有用，比如XMonad。(据说XMonad没有宣传全屏支持，因为Flash使用它。显然，那些想使用全屏的应用程序应该忽略NetWM的支持提示，或者提供一个变通方案。XMonad故意破坏X协议，真是太可耻了（好像X还不够坏似的）。

    默认情况下，NetWM支持是自动检测的（ ``auto`` ）。

    这个选项在将来可能会被删除。

``--x11-bypass-compositor=<yes|no|fs-only|never>``
    如果设置为 ``yes`` ，则要求合成器取消对mpv窗口的重定向（默认： ``fs-only`` ）。这使用了 ``_NET_WM_BYPASS_COMPOSITOR`` 的提示。

    ``fs-only`` 要求窗口管理器只在全屏模式下禁用合成器。

    ``no`` 将 ``_NET_WM_BYPASS_COMPOSITOR`` 设置为0，这是EWMH规范所声明的默认值，也就是说，不做任何改变。

    ``never`` 要求窗口管理器永远不要禁用合成器。


Disc Devices
------------

``--cdrom-device=<path>``
    指定光盘设备（默认： ``/dev/cdrom`` ）。

``--dvd-device=<path>``
    指定DVD设备或.iso文件名（默认： ``/dev/dvd`` ）。你也可以指定一个包含以前直接从DVD复制的文件的目录（例如，用vobcopy）。

    .. admonition:: 示例

        ``mpv dvd:// --dvd-device=/path/to/dvd/``

``--bluray-device=<path>``
    (仅蓝光) 指定蓝光光盘的位置。必须是一个具有蓝光结构的目录。

    .. admonition:: 示例

        ``mpv bd:// --bluray-device=/path/to/bd/``

``--cdda-...``
    这些选项可以用来调整mpv的CD音频读取功能。

``--cdda-speed=<value>``
    设置CD旋转速度。

``--cdda-paranoia=<0-2>``
    设置偏执狂水平。0以外的值似乎会破坏除第一轨以外的任何播放。

    :0: 禁用检查（默认）。
    :1: 只检查重叠部分
    :2: 完整的数据校正和验证

``--cdda-sector-size=<value>``
    设置原子读取大小。

``--cdda-overlap=<value>``
    在验证过程中强制最小重叠搜索到<value>扇区。

``--cdda-toc-bias``
    假设TOC中报告的第1轨的起始偏移量将被寻址为LBA 0。 一些光盘需要这样才能正确获得轨道边界。

``--cdda-toc-offset=<value>``
    在寻址轨道时，在报告的数值上增加 ``<value>`` 扇区。可能是负值。

``--cdda-skip=<yes|no>``
    (从不)接受不完美的数据重建。

``--cdda-cdtext=<yes|no>``
    打印CD文本。这在默认情况下是禁用的，因为它破坏了CD-ROM驱动器的性能，原因不明。

``--dvd-speed=<speed>``
    尝试限制DVD速度（默认： 0，没有变化）。DVD的基本速度是1385 kB/s，所以一个8倍速的驱动器的读取速度可以达到11080 kB/s。较慢的速度使硬盘更安静。对于观看DVD，2700 kB/s应该是足够安静和快速的。至少100的值意味着速度，单位是kB/s。小于100的值意味着1385 kB/s的倍数，即 ``--dvd-speed=8`` 选择11080 kB/s。

    .. note::

        你需要有对DVD设备的写入权限才能改变速度。

``--dvd-angle=<ID>``
    一些DVD包含可以从多个角度观看的场景。这个选项告诉mpv要使用哪个角度（默认： 1）。



Equalizer
---------

``--brightness=<-100-100>``
    调整视频信号的亮度（默认： 0）。不是所有的视频输出驱动都支持。

``--contrast=<-100-100>``
    调整视频信号的对比度（默认值： 0）。不被所有视频输出驱动支持。

``--saturation=<-100-100>``
    调整视频信号的饱和度（默认值： 0）。用这个选项可以得到灰度输出。不是所有的视频输出驱动都支持。

``--gamma=<-100-100>``
    调整视频信号的伽玛（默认值： 0）。不被所有视频输出驱动支持。

``--hue=<-100-100>``
    调整视频信号的色调（默认： 0）。你可以用这个选项得到图像的彩色底片。不被所有的视频输出驱动支持。

Demuxer
-------

``--demuxer=<[+]name>``
    强制使用解复用器类型。在名称前使用'+'来强制它；这将跳过一些检查。给出由 ``--demuxer=help`` 打印出来的解扰器名称。

``--demuxer-lavf-analyzeduration=<value>``
    分析流属性的最大长度（秒）。

``--demuxer-lavf-probe-info=<yes|no|auto|nostreams>``
    是否探测流信息（默认：自动）。技术上来说，这控制了是否调用libavformat的 ``avformat_find_stream_info()`` 函数。通常情况下，调用它比较安全，但它也会使启动速度变慢。

    ``auto`` 选择（默认）试图对一些已知安全的白名单格式跳过这个功能，而对其他所有格式都调用它。

    ``nostreams`` 选择只在文件打开后似乎不包含流的情况下才调用（在需要调用该函数来检测流的情况下很有帮助，例如FLV文件）。

``--demuxer-lavf-probescore=<1-100>``
    最低要求的libavformat探测分数。较低的值需要加载较少的数据（使流开始得更快），但使文件格式检测不那么可靠。可以用来强制自动检测 libavformat 解码器，即使 libavformat 认为检测不够可靠。(默认值： 26)

``--demuxer-lavf-allow-mimetype=<yes|no>``
    允许从HTTP MIME类型衍生出格式（默认： yes）。如果从HTTP播放文件时神秘地失败，即使同样的文件在本地磁盘上也能正常播放，则将此设置为no。

    这是默认的，以减少打开HTTP流时的延迟。

``--demuxer-lavf-format=<name>``
    强制使用一个特定的libavformat解扰器。

``--demuxer-lavf-hacks=<yes|no>``
    默认情况下，一些格式将通过明确的检查来处理，与其他格式不同。其中大多数是对libavformat解复用器的奇怪或不完美行为的补偿。传递 ``no`` 将禁用这些格式。仅用于调试和测试。

``--demuxer-lavf-o=<key>=<value>[,<key>=<value>[,...]]``
    将AVOptions传递给libavformat demuxer。

    注意，欢迎打一个补丁，使 *o=* 不需要，并通过AVOption系统传递所有未知的选项。AVOptions的完整列表可以在FFmpeg手册中找到。注意，有些选项可能会与mpv选项冲突。

    这是一个按键/值列表选项。详见 `List Options`_

    .. admonition:: 示例

        ``--demuxer-lavf-o=fflags=+ignidx``

``--demuxer-lavf-probesize=<value>``
    在检测阶段探测的最大数据量。在MPEG-TS的情况下，这个值确定了要扫描的最大TS数据包的数量。

``--demuxer-lavf-buffersize=<value>``
    为libavformat分配的流读取缓冲区的大小，以字节为单位（默认： 32768）。降低这个大小可以降低延迟。注意，libavformat可能会在内部重新分配缓冲区，或者不完全使用所有的缓冲区。

``--demuxer-lavf-linearize-timestamps=<yes|no|auto>``
    尝试对解复用流中的时间戳重置进行线性化处理（默认： auto）。这只对单一音频流进行了测试。不知道它对视频是否正常工作（但很可能不会）。请注意，无论哪种方式的实现都有一点不正确，并且会引入大约1个编解码器帧大小的不连续性。

    ``auto`` 模式对OGG音频流启用这个功能。这涵盖了OGG网络广播流的常见和恼人的情况。其中一些会在每次新歌开始时将时间戳重置为0。这就破坏了mpv的可寻址缓存，它无法处理时间戳的重置。请注意，FFmpeg/libavformat的搜索API也不能处理这个问题；如果这个选项对这个问题的破坏更大，而如果它被禁用，你至少可以在流中的第一首歌内搜索。好吧，如果在mpv的缓存之外寻找，你也不会得到任何有用的东西。

``--demuxer-lavf-propagate-opts=<yes|no>``
    传播FFmpeg级别的选项到递归打开的连接（默认：是）。这是需要的，因为FFmpeg会自动将这些设置应用到嵌套的AVIO上下文。另一方面，在某些情况下这可能会破坏 - 这是FFmpeg的API，你不可能赢。

    这尤其影响到 ``--timeout`` 选项和任何与 ``--demuxer-lavf-o`` 一起传递的东西。

    如果这个选项在未来的某个时候被认为是不必要的，它将被删除而不另行通知。

``--demuxer-mkv-subtitle-preroll=<yes|index|no>``, ``--mkv-subtitle-preroll``
    当在某处寻找时，更努力地显示嵌入式软字幕。通常情况下，由于一些容器文件格式的设计，可能会发生在寻找目标处的字幕不被显示。只有在寻找之前或正好在字幕首次出现的位置时，字幕才会出现。更糟的是，字幕的出现时间往往比相关的视频帧早很久，因此，寻找视频帧通常不会在该位置上解压字幕。

    启用这个选项可以使解复用器在搜索目标前一点开始读取数据，从而使字幕正确出现。请注意，这将使搜索速度变慢，而且不能保证总是有效。它只在字幕足够接近搜索目标时才起作用。

    只对内部的Matroska解扰器起作用。始终对绝对和hr-seeks启用，这个选项只改变相对或不精确的搜索行为。

    你可以使用 ``--demuxer-mkv-subtitle-preroll-secs`` 选项来指定解复用器最多应该预读多少数据，以便找到可能重叠的字幕包。将此设置为0将有效地禁用这种预滚轮机制。设置一个非常大的值会使搜索变得非常慢，而一个非常大的值会在每次搜索时从开始到搜索目标完全重读整个文件--在文件的最后，搜索会变得更慢。细节很乱，这个值实际上是四舍五入到与前一个视频关键帧的簇。

    一些文件，特别是用较新的mkvmerge版本混合的文件，有嵌入的信息，可以用来确定哪些字幕包与搜索目标重叠。在这些情况下，mpv会将读取的数据量降到最低。(尽管它仍然会读取 *所有* 包含第一个想要的字幕包的集群和搜索目标之间的数据)。如果指定了 ``index`` 的选择（这是默认的），那么只有在这个信息实际可用的情况下才会进行预滚动。如果使用这种方法，跳过的最大数据量可以由 ``--demuxer-mkv-subtitle-preroll-secs-index`` 来控制（它仍然使用没有 ``-index`` 的选项的值，如果该值更高的话）。

    See also ``--hr-seek-demuxer-offset`` option. 这个选项可以达到类似的效果，但是只有在hr-seek激活的情况下。它适用于任何解复用器，但会使搜索速度大大降低，因为它必须对音频和视频数据进行解码，而不是直接跳过它们。

    ``--mkv-subtitle-preroll`` 是一个deprecated的别名。

``--demuxer-mkv-subtitle-preroll-secs=<value>``
    参见 ``--demuxer-mkv-subtitle-preroll``

``--demuxer-mkv-subtitle-preroll-secs-index=<value>``
    参见 ``--demuxer-mkv-subtitle-preroll``

``--demuxer-mkv-probe-start-time=<yes|no>``
    检查Matroska文件的开始时间（默认： yes）。这只是读取第一个集群的时间戳，并假定它是开始时间。技术上来说，这也是读取第一个时间戳，这可能会增加一帧的延迟（这可能与直播流有关）。

``--demuxer-mkv-probe-video-duration=<yes|no|full>```
    当打开文件时，寻找文件的结尾，并检查最后一个视频数据包的时间戳，并将其报告为文件的持续时间。这仅仅是为了与Haali兼容。在这种模式下，打开文件的速度可能会变慢（特别是在通过http播放时），或者对破损文件的处理会更糟糕。所以不要使用这个选项。

    ``yes`` 模式只是使用索引，并从文件的末端读取少量的块。 ``full`` 模式实际上是遍历整个文件，即使没有索引也能做出可靠的估计（例如部分文件）。

``--demuxer-rawaudio-channels=<value>``
    如果使用 ``--demuxer=rawaudio`` ，通道的数量（或通道布局）（默认： stereo）。

``--demuxer-rawaudio-format=<value>``
    ``--demuxer=rawaudio`` 的采样格式（默认： s16le）。使用 ``--demuxer-rawaudio-format=help`` 来获得所有格式的列表。

``--demuxer-rawaudio-rate=<value>``
    ``--demuxer=rawaudio`` 的采样率（默认： 44kHz）。

``--demuxer-rawvideo-fps=<value>`` 为 ``--demuxer=rawaudio`` 的采样率（默认： 44kHz）。
    ``--demuxer=rawvideo`` 的每秒帧数（默认： 25.0）。

``--demuxer-rawvideo-w=<value>``, ``--demuxer-rawvideo-h=<value>``
    ``--demuxer=rawvideo`` 的图像尺寸，单位是像素。

    .. admonition:: 示例

        播放一个原始YUV样本：

            mpv sample-720x576.yuv --demuxer=rawvideo \
            --demuxer-rawvideo-w=720 --demuxer-rawvideo-h=576

``--demuxer-rawvideo-format=<value>``
    ``--demuxer=rawvideo`` 的颜色空间（fourcc）的十六进制或字符串（默认： ``YV12`` ）。

``--demuxer-rawvideo-mp-format=<value>``
    ``--demuxer=rawvideo`` 的内部视频格式的色彩空间。使用 ``--demuxer-rawvideo-mp-format=help`` 获得可能的格式列表。

``--demuxer-rawvideo-codec=<value>``
    设置视频编解码器，而不是在使用 ``--demuxer=rawvideo`` 时选择rawvideo编解码器。这使用与 ``--vd`` 中的编解码器名称相同的值（但它不接受解码器名称）。

``--demuxer-rawvideo-size=<value>``
    当使用 ``--demuxer=rawvideo`` 时，帧的大小以字节为单位。

``--demuxer-cue-codepage=<codepage>``
    指定CUE表的编码页。(详见 ``--sub-codepage`` )。

``--demuxer-max-bytes=<bytesize>``
    这控制了解复用器允许提前缓冲的数量。一般来说，解复用器会根据需要尽量提前读取，或者根据 ``--demuxer-readahead-secs`` 的要求来进行。该选项可以用来限制最大的读头。这限制了在文件破碎或播放不同步的情况下过多的readahead。一旦达到其中一个限制，解复用器将停止读取额外的数据包。(由于技术原因，这些限制仍然可以略微超出。)

    如果你得到一个数据包队列溢出的警告，并且你认为用一个更大的数据包队列可以正常播放，那么就把这些限制设置得更高。

    默认值和数值范围见 ``--list-options`` 。 ``<bytesize>`` 选项接受后缀，如 ``KiB`` 和 ``MiB``

``--demuxer-max-back-bytes=<bytesize>``
    这控制了demuxer允许保留多少过去的数据。这只有在启用缓存时才有用。

    与前向缓存不同，没有控制实际缓存的秒数--它将简单地使用该选项允许的内存。把这个选项设置为0将严格禁止任何后退缓冲，但这将导致前向寻址范围从当前播放位置之后开始的情况（因为它删除了作为寻址点的过去的数据包）。

    如果到达文件的末端，剩余的未使用的前向缓冲区空间将被 "捐献 "给后向缓冲区（除非后向缓冲区的大小被设置为0，或者 ``--demuxer-donate-buffer`` 被设置为 ``no`` ）。这仍然限制了缓存的总使用量为前向和后向缓存的总和，并有效地更好地利用了允许的总内存预算。(相反的情况不会发生：空闲的后向缓冲区永远不会被 "捐献 "给前向缓冲区。)

    请记住，播放器中的其他缓冲区（如解码器）会导致解复用器将 "未来 "帧缓存在后置缓冲区中，这可能会歪曲关于后置缓冲区包含多少数据的印象。

    参见 ``--list-options`` ，了解默认值和范围。

``--demuxer-donate-buffer=<yes|no>``
    是否让后置缓冲区使用前置缓冲区的一部分（默认： yes）。如果设置为 ``yes`` ，则启用 ``--demuxer-max-back-bytes`` 选项描述中的 "捐赠 "行为。这意味着后面的缓冲区可以使用的内存达到前进和后退缓冲区选项的总和，减去前进缓冲区的活动大小。如果设置为 ``no`` ，选项会严格限制正向和反向缓冲区的大小。

    注意，如果到达文件的末尾，缓冲的数据保持不变，即使你在缓冲区内回寻。这是因为只有在读取新的数据时才会减少后面的缓冲区。

``--demuxer-seekable-cache=<yes|no|auto>``
    调试选项，控制寻求是否可以使用demuxer缓存（默认： auto）。通常你不需要设置这个选项；如果 ``--cache`` 被设置为 ``yes`` （或者如果 ``--cache=auto`` ，则暗示为 ``yes`` ），默认的 ``auto`` 会做正确的事情并启用缓存搜索。

    如果启用，短的寻道偏移将不会触发低级别的解复用器寻道（这意味着，例如可以避免缓慢的网络往返或FFmpeg寻道错误）。如果寻求不能在缓存范围内发生，将触发一个低级别的寻求。在缓冲区外寻找将开始一个新的缓冲范围，但如果解复用器表现出某些不被支持的行为，可以丢弃旧的缓冲范围。

    特殊值 ``auto`` 表示在与 ``--cache-secs`` 相同的情况下 ``yes`` （即当流出现在网络流或流缓存被启用时）。

``--demuxer-force-retry-on-eof=<yes|no>``
    是否在解码器每次排队时不断重试，使Demuxer线程读取更多的数据包，即使已经到达文件的末端（默认： no）。这其实没有什么意义，但在mpv0.32.0和更早的版本中是默认行为。这个选项在一段时间后会被悄悄地删除，它的存在只是为了恢复旧的行为以备测试，以防在某些地方确实需要这样做。这对正在被追加的文件没有帮助（在这种情况下，使用 ``appending://`` ，或者禁用缓存）。

``--demuxer-thread=<yes|no>``
    在一个单独的线程中运行demuxer，并让它预取一定数量的数据包（默认： yes）。启用这个功能可以使播放更顺畅，启用预取等功能，并防止网络卡住使播放器冻结。另一方面，它可能会增加开销，或者后台预取会占用CPU资源。

    不建议禁用这个选项。只在调试时使用它。

``--demuxer-termination-timeout=<seconds>``
    播放器应该等待多少秒来关闭解复用器（默认： 0.1）。在强行关闭流层之前，播放器将最多等待这么多时间。强制关闭通常意味着网络I/O没有机会优雅地关闭它的连接（当然操作系统仍然可以正确地关闭TCP连接），可能会导致恼人的信息被记录下来，在某些情况下，会使远程服务器混乱。

    这个超时通常只在加载已经正常完成的情况下应用。如果加载被用户中止，或者在某些角落的情况下，比如在播放过程中移除来自网络的外部音轨，总是会使用强制关闭。

``--demuxer-readahead-secs=<seconds>``
    如果 ``--demuxer-thread`` 被启用，这控制了demuxer应该提前多少秒缓冲（默认： 1）。只要没有数据包的时间戳差异高于相对于返回给解码器的最后一个数据包的readahead量，解复用器就会继续读取。

    注意，启用缓存（如 ``--cache=yes`` ，或者如果输入被认为是网络流，并使用 ``--cache=auto`` ），这个选项大部分会被忽略。( ``--cache-secs`` 将覆盖这个选项。技术上讲，使用两个选项的最大值）。

    这个选项的主要目的是限制本地播放的读头，因为一个大的读头值在这种情况下没有太大作用。

    (这个值往往是模糊的，因为许多文件格式不存储线性时间戳。)

``--prefetch-playlist=<yes|no>``
    在当前项目的播放结束时预取下一个播放列表项目（默认：否）。

    这不会将下一个URL的视频数据预填充到缓存中。预取视频数据只支持当前的播放列表条目，并取决于demuxer缓存设置（默认为开启）。这只是在当前的URL被完全读取后，打开下一个播放列表的URL。

    这对由 ``youtube-dl`` 包装器解析的URL **不** ，也不会起作用。

    如果使用每个文件的选项，或者在预取开始和下一个文件播放之间的时间窗口内改变选项，这可能会产生微妙的错误结果。

    这可能偶尔会做出错误的预取决定。例如，它不能预测你是否在播放列表中往后走，并假设你不会编辑播放列表。

    高度实验性的。

``--force-seekable=<yes|no>``
    如果播放器认为媒体是不可寻址的（例如，从管道中播放，或者是http流的服务器不支持范围请求），寻址将被禁用。这个选项可以强行启用它。对于缓存中的搜索，有很大的成功机会。

``--demuxer-cache-wait=<yes|no>``
    在开始播放之前，读取数据，直到到达文件的末端，或者demuxer缓存达到最大容量。只有当这一切完成后，播放才开始。这故意发生在用 ``--start`` 触发的初始搜索之前。这不会改变初始缓存后的任何运行时行为。如果文件不能被完全缓存，这个选项就没有用。

``--rar-list-all-volumes=<yes|no>``
    当打开多卷rar文件时，打开所有卷以创建一个包含文件的完整列表（默认：否）。如果禁用，只有标题位于第一卷内的存档条目被列出（因此在用mpv打开.rar文件时播放）。这样做可以加快打开速度，而且典型的白痴用例，即播放包含单个媒体文件的未压缩的多卷rar文件，也变得更快。

    打开的速度仍然很慢，因为出于未知的、愚蠢的和不必要的原因，libarchive在播放主文件时还是会打开所有卷，尽管mpv还没有迭代出任何存档条目。

Input
-----

``--native-keyrepeat``
    使用系统设置的按键重复延迟和速率，而不是 ``--input-ar-delay`` 和 ``--input-ar-rate`` 。(这是否适用取决于VO的后端和它如何处理键盘输入。不适用于终端输入）。

``--input-ar-delay``
    在我们开始自动重复按键前的延迟，以毫秒为单位（0表示禁用）。

``--input-ar-rate``
    在自动重复中每秒产生的按键数量。

``--input-conf=<filename>``
    指定输入配置文件，而不是mpv配置目录中的默认位置（通常是 ``~/.config/mpv/input.conf`` ）。

``--no-input-default-bindings``
    禁用默认级别（"弱"）的键绑定。这些是配置文件（如 ``input.conf`` ）可以覆盖的绑定。目前它影响到内置的键绑定，以及脚本使用 ``mp.add_key_binding`` 绑定的键（但不包括 ``mp.add_forced_key_binding`` ，因为它覆盖了 ``input.conf`` ）。

``--no-input-builtin-bindings``
    在启动时禁止加载内置键绑定。这个选项只在(lib)mpv初始化时应用，如果使用的话，以后就不可能再启用它们。可能对libmpv客户端有用。

``--input-cmdlist``
    打印所有可以绑定到键的命令。

``--input-doubleclick-time=<milliseconds>``
    以毫秒为单位，将连续两次按键识别为双击的时间（默认： 300）。

``--input-keylist``
    打印所有可以与命令绑定的按键。

``--input-key-fifo-size=<2-65000>``
    指定缓冲按键事件的FIFO的大小（默认： 7）。如果它太小，一些事件可能会丢失。设置为一个非常大的值的主要缺点是，如果你按住一个键触发了一些特别慢的命令，那么播放器在处理所有排队的命令时可能没有反应。

``--input-test``
    输入测试模式。mpv不会在按键时执行命令，而是在OSD上显示按键和绑定的命令。必须和虚拟视频一起使用，正常的退出播放器的方法将不起作用（通常退出的键绑定将只显示在OSD上，就像其他的绑定一样）。见 `INPUT.CONF`_

``--input-terminal``, ``--no-input-terminal``
    ``--no-input-terminal`` 防止播放器从标准输入读取按键事件。在从标准输入读取数据时很有用。当在命令行中发现 ``-`` 时，这将自动启用。有些情况下，你必须手动设置，例如，如果你打开 ``/dev/stdin`` （或你系统中的等价物），在播放列表中使用stdin或打算以后通过loadfile或loadlist输入命令从stdin读取数据。

``--input-ipc-server=<filename>``
    启用IPC支持并在给定的路径上创建监听套接字。

    在Linux和Unix中，给定的路径是一个普通的文件系统路径。在Windows上，使用命名的管道，所以路径指的是管道命名空间（ ``\\.\pipe\<name>`` ）。如果缺少 ``\\.\pipe\`` 前缀，mpv会在创建管道前自动添加，所以 ``--input-ipc-server=/tmp/mpv-socket`` 和 ``--input-ipc-server=\\.\pipe\tmp\mpv-socket`` 对于Windows上的IPC是等同的。

    详见 `JSON IPC`_

``--input-ipc-client=fd://<N>``
    连接一个IPC客户端到指定的FD。这与 ``--input-ipc-server`` 有点类似，只是没有创建套接字，而传递的FD被当作从 ``accept()`` 收到的套接字连接。在实践中，你可以传递一个由 ``socketpair()`` 创建的FD，或者一个管道。在这两种情况下，你必须确保FD实际上是由mpv继承的（不要设置POSIX的 ``CLOEXEC`` 标志）。

    当连接被关闭时，玩家就会退出。

    这有点类似于被删除的 ``--input-file`` 选项，只是它只支持整数FD，而不能打开实际路径。

    .. admonition:: 示例

        ``--input-ipc-client=fd://123``

    .. note::

        在Windows上不工作，也不会工作。

    .. warning::

        在运行时写入 ``input-ipc-server`` 选项将为 ``input-ipc-client`` 选项启动另一个IPC客户端处理程序实例，因为初始化是捆绑的，这个东西很愚蠢。这是一个错误。在运行时写到 ``input-ipc-client`` 将为新的值启动另一个IPC客户端处理程序，而不停止旧的处理程序，即使FD值是相同的（但字符串是不同的，例如，由于空白）。这不是一个错误。

``--input-gamepad=<yes|no>``
    启用/禁用SDL2游戏板支持。默认情况下是禁用的。

``--input-cursor``, ``--no-input-cursor``
    允许mpv接收由视频输出驱动报告的指针事件。需要使用OSC，或在DVD菜单中选择按钮。支持与否取决于使用的VO。

``--input-media-keys=<yes|no>``
    在mpv可以选择接收媒体键或让系统处理媒体键的系统中，这个选项控制mpv是否应该接收媒体键。

    默认： yes（除了libmpv）。只有macOS和Windows，因为在其他地方mpv没有选择--系统决定是否将媒体密钥发送给mpv。例如，在X11或Wayland上，没有实现全系统的媒体键。当mpv窗口被聚焦时，媒体键是否起作用是由系统定义的。

``--input-right-alt-gr``, ``--no-input-right-alt-gr``
    (仅Cocoa和Windows)将右Alt键作为Alt Gr来产生特殊字符。如果禁用，将右键Alt算作Alt修改键。默认情况下启用。

``--input-vo-keyboard=<yes|no>``
    对于不能参与适当的键盘输入调度的VO，禁用所有键盘输入。可能不会影响所有的VO。一般来说只对嵌入有用。

    在X11上，一个启用了输入功能的子窗口会抓取所有的键盘输入，只要它是1.一个焦点窗口的子窗口，并且2.鼠标在子窗口内。它可以从嵌入mpv窗口的应用程序中窃取所有的键盘输入，另一方面，如果鼠标在mpv窗口之外，即使mpv有焦点，mpv窗口也不会收到任何输入。现代的工具包可以绕过这个奇怪的X11行为，但是天真的嵌入外国窗口会破坏它。

    唯一合理处理这个问题的方法是使用XEmbed协议，它是为了解决这些问题而设计的。GTK提供``GtkSocket``，它支持XEmbed。Qt似乎没有提供任何在较新版本中的工作。

    如果嵌入器支持XEmbed，输入应该在默认设置下工作，并且禁用这个选项。注意 ``input-default-bindings`` 在libmpv中也是默认禁用的--如果你想要mpv的默认键绑定，应该启用它。

    (这个选项由 ``--input-x11-keyboard`` 改名而来)。

OSD
---

``--osc``, ``--no-osc``
    是否加载屏幕控制器（默认： yes）。

``--no-osd-bar``, ``--osd-bar``
    禁用OSD栏的显示。

    你可以在input.conf中使用 ``osd-`` 前缀在每个命令的基础上进行配置，见 ``Input Command Prefixes`` 。如果你想完全禁用OSD，使用 ``--osd-level=0``

``--osd-on-seek=<no,bar,msg,msg-bar>``
    设置在搜索过程中OSD上显示的内容。默认是 ``bar``

    你可以在input.conf中使用 ``osd-`` 前缀对每个命令进行配置，见 ``Input Command Prefixes``

``--osd-duration=<time>``
    设置OSD信息的持续时间，单位是ms（默认： 1000）。

``--osd-font=<name>``
    指定OSD使用的字体。默认为 ``sans-serif``

    .. admonition:: 示例

        - ``--osd-font='Bitstream Vera Sans'``
        - ``--osd-font='Comic Sans MS'``

``--osd-font-size=<size>``
    指定OSD的字体大小。详见 ``--sub-font-size``

    默认值： 55

``--osd-msg1=<string>``
    在OSD级别1（默认可见）的OSD上显示这个字符串作为信息。该信息默认是可见的，只要没有其他信息覆盖它，并且OSD级别没有改变（见 ``--osd-level`` ）。扩展属性；见 `Property Expansion`_

``--osd-msg2=<string>``
    类似于 ``--osd-msg1`` ，但用于OSD级别2。如果这是一个空字符串（默认），那么将显示播放时间。

``--osd-msg3=<string>``
    类似于 ``--osd-msg1`` ，但用于OSD第三级。如果这是一个空字符串（默认），那么就会显示播放时间、持续时间和一些更多的信息。

    这用于 ``show-progress`` 命令（默认映射到 ``P`` ），如果用 ``--osd-on-seek`` 或input.conf中的 ``osd-`` 前缀启用，则用于搜索（参见 ``Input Command Prefixes`` ）。

    ``--osd-status-msg`` 是一个传统的等价物（但有一个小区别）。

``--osd-status-msg=<string>``
    在播放过程中显示一个自定义的字符串而不是标准的状态文本。这将取代 ``--osd-level=3`` 的状态文本，当使用 ``show-progress`` 命令时（默认映射为 ``P`` ），如果在input.conf中使用 ``--osd-on-seek`` 或 ``osd-`` 前缀，则在搜索时使用（见 ``Input Command Prefixes`` ）。扩展属性。参见 `Property Expansion`_

    这个选项已经被 ``--osd-msg3`` 取代。唯一的区别是该选项隐含了 ``${osd-sym-cc}`` 。如果 ``--osd-msg3`` 不是空的，这个选项将被忽略。

``--osd-playing-msg=<string>``
    当播放开始时在OSD上显示一条信息。字符串被扩展为属性，例如： ``--osd-playing-msg='file: ${filename}'`` 将显示信息 ``file:`` ，后面是空格和当前播放的文件名。

    参见 `Property Expansion`_

``--osd-bar-align-x=<-1-1>``
    OSD栏的位置。-1是最左边，0是中间，1是最右边。允许使用小数值（如0.5）。

``--osd-bar-align-y=<-1-1>``
    OSD条的位置。-1是顶部，0是中间，1是底部。允许使用小数值（如0.5）。

``--osd-bar-w=<1-100>``
    OSD条的宽度，以屏幕宽度的百分比表示（默认：75）。50的值意味着栏的宽度是屏幕的一半。

``--osd-bar-h=<0.1-50>``
    OSD条的高度，占屏幕高度的百分比（默认：3.125）。

`--osd-back-color=<color>```。
    见 ``--sub-color`` 。用于OSD文本背景的颜色。

``--osd-blur=<0..20.0>``
    高斯模糊系数。0表示不应用模糊（默认）。

``--osd-bold=<yes|no>``
    加粗的文本格式。

``--osd-italic=<yes|no>``
    以斜体字格式显示文本。

``--osd-border-color=<color>``
    参见 ``--sub-color`` 。用于OSD字体边框的颜色。

    .. note::

        当指定 ``--osd-back-color`` 时被忽略（或者更确切地说：当该选项没有设置为完全透明时）。

``--osd-border-size=<size>``
    OSD字体边框的大小，以像素为单位（详见 ``--sub-font-size`` ）。值为0时，禁用边框。

    默认： 3

``--osd-color=<color>``
    指定用于OSD的颜色。详见 ``--sub-color``

``--osd-fractions``
    显示以秒为单位的OSD时间（精度为毫秒）。对查看视频帧的精确时间戳很有用。

``--osd-level=<0-3>``
    指定OSD应该以何种模式启动。

    :0: OSD完全禁用（只有字幕）。
    :1: 启用（仅在用户互动时显示）。
    :2: 启用 + 默认可见当前时间
    :3: 启用 + ``--osd-status-msg`` (默认为当前时间和状态)

``--osd-margin-x=<size>``
    OSD的左右屏幕边距，按比例像素计算（详见 ``--sub-font-size`` ）。

    这个选项指定了OSD与左边的距离，以及OSD文本在与右边边界的哪个距离会被打断。

    默认： 25

``--osd-margin-y=<size>``
    OSD的顶部和底部屏幕边距，按比例像素计算（详见 ``--sub-font-size`` ）。

    这个选项指定了OSD的垂直边距。

    默认： 22

``--osd-align-x=<left|center|right>``
    控制OSD应该对准屏幕的哪个角（默认： ``left`` ）。

``--osd-align-y=<top|center|bottom>``
    垂直位置（默认： ``top`` ）。详见 ``--osd-align-x``

``--osd-scale=<factor>``
    OSD字体大小的乘数，与 ``--osd-font-size`` 值相乘。

``--osd-scale-by-window=<yes|no>``
    是否随窗口大小调整OSD的大小（默认： yes）。如果这个选项被禁用， ``--osd-font-size`` 和其他使用缩放像素的OSD选项总是以实际像素为准。其结果是，改变窗口大小不会改变OSD字体大小。

``--osd-shadow-color=<color>``
    参见 ``--sub-color`` 。用于OSD阴影的颜色。

``--osd-shadow-offset=<size>``
    OSD阴影的位移，按像素比例计算（详见 ``--sub-font-size`` ）。值为0时，阴影将被禁用。

    默认： 0

``--osd-spacing=<size>``
    水平OSD/子字体间距，按比例像素计算（详见 ``--sub-font-size`` ）。这个值会加到正常的字母间距上。允许使用负值。

    默认： 0

``--video-osd=<yes|no>``
    在视频窗口上启用OSD渲染（默认： yes）。这可以用在喜欢终端OSD的情况下。如果你只是想禁用所有的OSD渲染，使用 ``--osd-level=0``

    它不影响字幕或由脚本创建的覆盖物（特别是OSC需要用 ``--no-osc`` 来禁用）。

    这个选项在某种程度上是试验性的，将来可能会被另一种机制所取代。

``--osd-font-provider=<...>``
    参见 ``--sub-font-provider`` ，了解详情和可接受的值。注意，与字幕不同，OSD从不使用来自媒体文件的嵌入式字体。

Screenshot
----------

``--screenshot-format=<type>``
    设置用于保存屏幕截图的图像文件类型。

    可用的选择：

    :png:       PNG
    :jpg:       JPEG (默认)
    :jpeg:      JPEG （JPG的别名）
    :webp:      WebP

``--screenshot-tag-colorspace=<yes|no>``
    用适当的色彩空间标记屏幕截图。

    注意，不是所有的格式都被支持。

    默认： ``no``

``--screenshot-high-bit-depth=<yes|no>``
    如果可能的话，用与源视频相似的比特深度写入截图（默认： yes）。这对PNG来说特别有意思，因为这有时会触发写16位的PNG，文件大小很大。如果使用16比特，这也会在结果文件中包括一个未使用的alpha通道。

``--screenshot-template=<template>``
    指定用于保存屏幕截图的文件名模板。模板指定了不含文件扩展名的文件名，并可以包含格式指定符，在拍摄屏幕截图时将被替换。默认情况下，模板是 ``mpv-shot%n`` ，这导致文件名像 ``mpv-shot0012.png`` 。

    模板可以以相对路径或绝对路径开始，以指定应保存屏幕截图的目录位置。

    如果最终的截图文件名指向一个已经存在的文件，该文件将不会被覆盖。屏幕截图将不被保存，或者如果模板包含 ``%n`` ，则使用不同的、新生成的文件名保存。

    允许的格式指定器：

    ``%[#][0X]n``
        一个序列号，用零填充，长度为X（默认： 04）。例如，通过格式 ``%04n`` 将产生第12张截图的 ``0012`` 。每次截图或文件已经存在的情况下，数字会递增。长度 ``X`` 必须在0-9的范围内。有了可选的#号，mpv将使用最低的可用数字。例如，如果你拍了三张截图--0001, 0002, 0003--并删除了前两张，接下来的两张截图就不是0004和0005，而是0001和0002了。
    ``%f``
        当前播放的视频的文件名。
    ``%F``
        与 ``%f`` 相同，但剥离文件扩展名，包括点。
    ``%x``
        当前播放的视频的目录路径。如果视频不在文件系统上（但如 ``http://`` ），这将扩展为一个空字符串。
    ``%X{fallback}``
        与 ``%x`` 相同，但如果视频文件不在文件系统上，返回 ``{...}`` 内的回退字符串。
    ``%p``
        当前播放时间，格式与OSD中使用的相同。其结果是一个 "HH:MM:SS "形式的字符串。例如，如果视频处于5分34秒的时间位置， ``%p`` 将被替换为 "00:05:34"。
    ``%P``
        类似于 ``%p`` ，但扩展为以毫秒为单位的播放时间。它的格式是 "HH:MM:SS.mm"，其中 "mm "是播放时间的毫秒部分。

        .. note::

            这是一个获得独特的每帧时间戳的简单方法。(帧数会更直观，但不容易实现，因为容器格式通常使用时间戳来识别帧。)
    ``%wX``
        使用格式字符串 ``X`` 指定当前播放时间。 ``%p`` 就像 ``%wH:%wM:%wS`` ， ``%P`` 就像 ``%wH:%wM:%wS.%wT``

        有效的格式指定器：
            ``%wH``
                小时（用0到2位数填充）。
            ``%wh``
                小时（没有填充）。
            ``%wM``
                分钟（00-59）。
            ``%wm``
                总时间（包括小时，与 ``%wM`` 不同）
            ``%wS``
                秒 (00-59)
            ``%ws``
                总秒数 (包括小时和分钟)
            ``%wf``
                像 ``%ws`` 一样，但作为浮点数
            ``%wT``
                毫秒(000-999)

    ``%tX``
        使用格式 ``X`` 指定当前的本地日期/时间。这个格式指定器在内部使用UNIX的 ``strftime()`` 函数，并插入传递"%X "到 ``strftime`` 的结果。例如， ``%tm`` 将插入当前月份的数字。你必须使用多个 ``%tX`` 指定器来建立一个完整的日期/时间字符串。
    ``%{prop[:fallback text]}``
        插入输入属性'prop'的值。例如： ``%{filename}`` 与 ``%f`` 相同。如果该属性不存在或不可用，将插入一个错误文本，除非指定一个回退文本。
    ``%%``
        用 ``%`` 字符本身替换。

``--screenshot-directory=<path>``
    将屏幕截图存储在这个目录中。该路径与 ``--screenshot-template`` 产生的文件名联合。如果模板文件名已经是绝对的，该目录将被忽略。

    如果该目录不存在，它将在第一次截图时被创建。如果它不是一个目录，在试图写入截图时将产生一个错误。

    这个选项在默认情况下没有设置，因此将把截图写到mpv启动的目录中。在pseudo-gui模式下（见 `PSEUDO GUI MODE`_ ），这被设置为桌面。

``--screenshot-jpeg-quality=<0-100>``
    设置JPEG的质量水平。越高意味着质量越好。默认是90。

``--screenshot-jpeg-source-chroma=<yes|no>``
    编写与视频相同的色度子采样的JPEG文件（默认： yes）。如果禁用，将使用libjpeg的默认值。

``--screenshot-png-compression=<0-9>``
    设置PNG压缩级别。更高意味着更好的压缩。这将影响写入屏幕截图文件的大小和写入屏幕截图的时间。太高的压缩可能会占用足够的CPU时间而中断播放。默认值是7。

``--screenshot-png-filter=<0-5>``
    设置在PNG压缩前应用的过滤器。0是没有，1是 "sub"，2是 "up"，3是 "average"，4是 "Paeth"，5是 "mixed"。这影响到可以实现的压缩水平。对于大多数图像，"混合 "实现了最好的压缩率，因此它是默认的。

``--screenshot-webp-lossless=<yes|no>``
    编写无损的WebP文件。 ``--screenshot-webp-quality`` 如果设置了这个选项，将被忽略。默认为否。

``--screenshot-webp-quality=<0-100>``
    设置WebP质量等级。越高意味着质量越好。默认值是75。

``--screenshot-webp-compression=<0-6>``
    设置WebP的压缩级别。更高意味着更好的压缩，但需要更多的CPU时间。注意，在使用有损的WebP文件时，这也会影响截图质量。默认是4。

``--screenshot-sw=<yes|no>``
    是否对截图使用软件渲染（默认： no）。

    如果设置为no，如果可能的话，屏幕截图将由当前VO渲染（目前只有vo_gpu）。这样做的好处是，这将（可能）总是像在视频窗口中那样显示，因为渲染时使用的是相同的代码。但是由于渲染器需要重新初始化，这可能会很慢，而且会中断播放。(除非 ``window`` 模式与 ``screenshot`` 命令一起使用)。

    如果设置为 yes，则使用软件缩放器将视频转换为RGB（或目标截图要求的任何内容）。在这种情况下，转换将在一个单独的线程中运行，可能不会中断播放。软件渲染器可能缺乏一些能力，比如HDR渲染。

Software Scaler
---------------

``--sws-scaler=<name>``
    指定与 ``--vf=scale`` 一起使用的软件缩放器算法。这也影响到缺乏硬件加速的视频输出驱动，例如 ``x11`` 。参见 ``--vf=scale``

    要获得可用的缩放器列表，请运行 ``--sws-scaler=help``

    默认： ``bicubic``

``--sws-lgb=<0-100>``
    软件缩放器的高斯模糊滤波器（luma）。参见 ``--sws-scaler``

``--sws-cgb=<0-100>``
    软件缩放器高斯模糊滤波器（色度）。参见 ``--sws-scaler``

``--sws-ls=<-100-100>``
    软件缩放器锐化滤波器（luma）。参见 ``--sws-scaler``

``--sws-cs=<-100-100>``
    软件缩放器锐化滤波器（色度）。参见 ``--sws-scaler``

``--sws-chs=<h>``
    软件缩放器的色度水平移位。参见 ``--sws-scaler``

``--sws-cvs=<v>``
    软件缩放器的色度垂直移动。参见 ``--sws-scaler``

``--sws-bitexact=<yes|no>``
    未知功能（默认： no）。请参考libswscale源代码。就libswscale API而言，其主要目的是为所有平台上的相同输入产生完全相同的输出（输出在任何地方都有相同的 "比特"，因此是 "bitexact"）。通常是禁用优化。

``--sws-fast=<yes|no>``
    允许优化，这有助于提高性能，但会降低质量（默认： no）。

    像 ``drm`` 和 ``x11`` 这样的虚拟机将从使用 ``--sws-fast`` 中获益良多。你可能需要设置其他选项，如 ``--sws-scaler`` 。内建的 ``sws-fast`` 配置文件设置了这个选项和其他一些选项，以获得性能而降低质量。也请看 ``--sws-allow-zimg``

``--sws-allow-zimg=<yes|no>``
    允许使用zimg（如果使用内部swscale包装器的组件明确允许这样做）（默认：是）。在这种情况下，如果内部的zimg包装器支持输入和输出格式，就 *可* 以使用zimg。如果这些条件之一不适用，它将默默地或无声地退回到libswscale。

    如果使用了zimg，其他的 ``--sws-`` 选项将被忽略，而使用 ``--zimg-`` 选项来代替。

    如果使用swscale包装器的内部组件正确地挂上了日志，一个冗长的优先级日志信息将显示是否使用了zimg。

    大多数需要软件转换的东西都可以利用这个。

    .. note::

        请注意，zimg *可能* 比libswscale慢。通常，它在x86平台上更快，但在ARM上更慢（由于缺乏ARM特定的优化）。mpv zimg包装器对某些格式使用了未经优化的重新打包，这不能怪zimg。

``--zimg-scaler=<point|bilinear|bicubic|spline16|spline36|lanczos>``
    要使用的Zimg luma缩放器（默认： lanczos）。

``--zimg-scaler-param-a=<default|float>``, ``--zimg-scaler-param-b=<default|float>``
    设置缩放器参数。默认情况下，这些参数被设置为特殊的字符串 ``default`` ，它映射到一个特定的缩放器默认值。如果标度器是不可调整的，则忽略不计。

    ``lanczos``
        ``--zimg-scaler-param-a`` 是抽头的数量。

    ``bicubic``
        a和b是二进制的b和c参数。

``--zimg-scaler-chroma=...``
    与 ``--zimg-scaler`` 相同，用于色度插值（默认： bilinear）。

``--zimg-scaler-chroma-param-a``, ``--zimg-scaler-chroma-param-b``
    与 ``--zimg-scaler-param-a`` / ``--zimg-scaler-param-b`` 相同，用于色度。

``--zimg-dither=<no|ordered|random|error-diffusion>``
    抖动（默认： random）。

``--zimg-threads=<auto|integer>``
    设置用于缩放的最大线程数（默认： auto）。 ``auto`` 使用当前机器上的逻辑核心数量。注意，缩放器可能会根据情况使用更少的线程（甚至只有1个线程）。传递一个1的值可以禁用线程，并且总是在一个单一的操作中缩放图像。更高的线程数会浪费资源，但通常会使它更快。

    注意，一些zimg的git版本有bug，如果使用了线程，会破坏输出。

``--zimg-fast=<yes|no>``
    允许进行有助于性能的优化，但会降低质量（默认： yes）。目前，这可能会简化伽马转换操作。


Audio Resampler
---------------

它控制mpv所做的任何重采样的默认选项（但不是在libavfilter中，在系统音频API重采样中，或任何其他地方）。

它也为 ``lavrresample`` 音频过滤器设置默认值。

``--audio-resample-filter-size=<length>``
    滤波器相对于低采样率的长度。(默认： 16)

``--audio-resample-phase-shift=<count>``
    多相条目数的对数。(..., 10->1024, 11->2048, 12->4096, ...) (默认： 10->1024)

``--audio-resample-cutoff=<cutoff>``
    截止频率（0.0-1.0），默认设置取决于滤波器的长度。

``--audio-resample-linear=<yes|no>``
    如果设置，那么滤波器将在多相条目之间进行线性插值。(默认： no)

``--audio-normalize-downmix=<yes|no>``
    如果环绕声被降频为立体声，启用/禁用规范化（默认： no）。如果这个功能被禁用，降混可能会导致削波。如果它被启用，输出可能会太安静。这取决于源音频。

    技术上来说，这改变了 "lavrresample "音频滤波器的 ``normalize`` 子选项，它执行了降噪。

    如果降频由于某种原因发生在mpv之外，或发生在解码器（解码器降频），或发生在音频输出（系统混合器），这就没有影响了。

``--audio-resample-max-output-size=<length>``
    限制一次过滤的音频帧的最大尺寸，单位是ms（默认： 40）。输出大小的限制是为了使重采样速度变化反应更快。特别是当解码器或滤波器输出非常大的帧大小时（如一些无损编解码器或一些DRC滤波器），这是必要的。这个选项不会以任何方式影响重采样算法。

    仅用于测试/调试。可以在任何时候删除或改变。

``--audio-swresample-o=<string>``
    在SwrContext或AVAudioResampleContext上设置AVOptions。这些应该由FFmpeg或Libav来记录。

    这是一个按键/值列表选项。详见 `List Options`_

Terminal
--------

``--quiet``
    使控制台输出不那么冗长；特别是防止显示状态行（即AV: 3.4 (00:00:03.37) / 5320.6 ...）。在慢速终端或不能正确处理回车的坏终端（即 ``\r`` ）上特别有用。

    也请参见： ``--really-quiet`` 和 ``--msg-level``

``--really-quiet``
    显示比 ``--quiet`` 更少的输出和状态信息。

``--no-terminal``, ``--terminal``
    禁用任何终端和stdin/stdout/stderr的使用。这将使任何信息输出完全沉默。

    与 ``--really-quiet`` 不同，这也是禁用输入和终端初始化。

``--no-msg-color``
    禁用终端上彩色的控制台输出。

``--msg-level=<module1=level1,module2=level2,...>``
    直接控制每个模块的粗略程度。 ``all`` 模块可以改变所有模块的粗制滥造程度。从这个选项中改变verbosity是按照从左到右的顺序进行的，而且每一项都可以覆盖前一项。

    用 ``--msg-level=all=trace`` 运行mpv，可以看到mpv输出的所有信息。你可以使用输出中打印的模块名称（每行前缀为 ``[...]`` ）来限制输出到感兴趣的模块。

    这也会影响到 ``--log-file`` ，在某些情况下也会影响到libmpv API的日志记录。

    .. note::

        有些信息在命令行被解析之前就被打印出来，因此不受 ``--msg-level`` 的影响。要控制这些信息，你必须使用 ``MPV_VERBOSE`` 环境变量；详情见 `ENVIRONMENT VARIABLES`_

    可用的级别：

        :no:        完全沉默
        :fatal:     仅限致命信息
        :error:     错误信息
        :warn:      警告信息
        :info:      信息性消息
        :status:    状态信息（默认）。
        :v:         冗长的信息
        :debug:     调试信息
        :trace:     非常嘈杂的调试信息

    .. admonition:: 示例

        ::

            mpv --msg-level=ao/sndio=no

        完全关闭ao_sndio的输出，它使用日志前缀 ``[ao/sndio]``

        ::

            mpv --msg-level=all=warn,ao/alsa=error

        只显示警告或更糟，让ao_alsa输出只显示错误。

``--term-osd=<auto|no|force>``
    控制在没有视频输出时是否在控制台显示OSD信息（默认： auto）。

    :auto:      在没有视频输出时使用终端OSD。
    :no:        禁用终端OSD
    :force:     即使视频输出激活，也使用终端OSD。

    如果设置了 ``--video-osd=no`` ， ``auto`` 模式也可以启用终端OSD。

``--term-osd-bar``, ``--no-term-osd-bar``
    启用在终端的状态行下打印一个进度条。(默认情况下是禁用的。)

``--term-osd-bar-chars=<string>``
    自定义 ``--term-osd-bar`` 功能。该字符串预计由5个字符组成（开始，左边的空格，位置指示器，右边的空格，结束）。你可以使用Unicode字符，但要注意双倍宽度的字符将不会被正确处理。

    默认： ``[-+-]``

``--term-playing-msg=<string>``
    开始播放后打印出一个字符串。该字符串会被扩展为属性，例如： ``--term-playing-msg='file: ${filename}'`` 将打印字符串 ``file:`` 后面是空格和当前播放的文件名。

    参见 `Property Expansion`_

``--term-status-msg=<string>``
    在播放过程中打印出一个自定义的字符串，而不是标准的状态行。扩展属性。请看`属性扩展'_。

``--term-title=<string>``
    设置终端的标题。目前，这只是将设置窗口标题的转义序列与提供的（属性扩展）字符串连接起来。如果扩展的字符串包含结束转义序列的字节，或者终端不理解该序列，这将会造成混乱。后者可能包括令人遗憾的win32.

    展开属性。参见 `Property Expansion`_

``--msg-module``
    在每个控制台信息前加上模块名称。

``--msg-time``
    在每个控制台信息中预置时间信息。时间的单位是玩家进程开始后的秒数（技术上来说，实际上稍晚），使用单调的时间源，取决于操作系统。在正常的UNIX系统中，这是 ``CLOCK_MONOTONIC``

Cache
-----

``--cache=<yes|no|auto>``
    决定是否使用网络缓存设置（默认： auto）。

    如果启用，使用最大的 ``--cache-secs`` 作为缓存大小（但仍然限制在 ``--demuxer-max-bytes`` ），并使缓存数据可寻（如果可能）。如果禁用， ``--cache-pause`` 和相关的都隐式禁用。

    ``auto`` 的选择是根据流是否被认为涉及网络访问或其他慢速媒体来启用（这是一个不完美的启发式方法）。

    在mpv0.30.0之前，这个选项曾经接受一个数字，指定缓存的大小，单位是KB。使用例如 ``--cache --demuxer-max-bytes=123k`` 代替。

``--no-cache``
    关闭输入流缓存。参见 ``--cache``

``--cache-secs=<seconds>``
    如果缓存激活，要预取多少秒的音频/视频。这将覆盖``--demuxer-readahead-secs`` 选项，如果且仅当缓存被启用且数值较大时。默认值被设置为非常高的值，所以实际达到的读秒数通常会受到 ``--demuxer-max-bytes`` 选项的限制。设置这个选项通常只对限制readahead有用。

``--cache-on-disk=<yes|no>``
    将数据包写入一个临时文件，而不是将它们保存在内存中。这只有在 ``--cache`` 下才有意义。如果正常的缓存被禁用，这个选项将被忽略。

    你需要设置 ``--cache-dir`` 来使用它。

    缓存文件是只附加的。即使播放器出现修剪数据，它所释放的文件空间也不会被重新使用。缓存文件在播放结束时被删除。

    注意，数据包的元数据仍然保留在内存中。 ``--demuxer-max-bytes`` 和相关选项 *只* 适用于元数据。这种元数据的大小不尽相同，但每小时50MB的媒体是典型的。缓存统计将报告这个元数据的大小，而不是缓存文件的大小。如果元数据达到了大小限制，元数据就会被剪掉（但不会剪掉缓存文件）。

    当媒体被关闭时，缓存文件被删除。缓存文件在媒体关闭后一般是没有价值的，而且很难从里面检索到任何媒体数据（设计上不支持）。

    如果该选项在运行时被启用，缓存文件会被创建，但旧的数据会保留在内存缓存中。如果该选项在运行时被禁用，旧的数据将保留在磁盘缓存中，并且缓存文件在媒体关闭之前不会被关闭。如果该选项被禁用并再次启用，将继续使用首先打开的缓存文件。

``--cache-dir=<path>``
    创建临时文件的目录（默认： none）。

    目前，这只用于 ``--cache-on-disk``

``--cache-pause=<yes|no>``
    当缓存中的数据用完后，播放器是否应该自动暂停，并停止解码/播放（默认： yes）。如果启用，一旦有更多的数据可用，它就会暂停和解除暂停，也就是 "缓冲"。

``--cache-pause-wait=<seconds>``
    如果输入了 "缓冲"，数据包缓存在再次开始播放之前应该有多少秒的缓冲时间（默认： 1）。这可以用来控制如果 ``--cache-pause`` 被启用，解复用器欠费时，播放器回退的时间。如果给定的时间高于 ``--cache-secs`` 或 ``--demuxer-readahead-secs`` 设置的最大时间，或者由于其他原因（如文件结束或达到配置的最大缓存大小）预取结束，播放将提前恢复。

``--cache-pause-initial=<yes|no>``
    在开始播放前进入 "缓冲 "模式（默认：否）。这可以用来确保播放顺利开始，以换取等待一些时间来预取网络数据（由 ``--cache-pause-wait`` 控制）。例如，一些常见的行为是，播放开始了，但随着播放的进行，试图解码更多的数据时，网络缓存立即不足。

    另一个可能发生的情况是，网络预取对CPU的要求很高（由于在后台进行解复用），以至于播放一开始就掉帧了。在这种情况下，启用这个选项，并将 ``--cache-secs`` 和 ``--cache-pause-wait`` 设置为大致相同的值，会有帮助。

    这个选项也会在寻道后重新开始播放时触发。

``--cache-unlink-files=<immediate|whendone|no>``
    是否或何时解除缓存文件的链接（默认： immediate）。这影响到缓存文件，这些文件本身是临时性的，在播放器终止后留在磁盘上没有意义。这是一个调试选项。

    ``immediate``
        在缓存文件被创建后解除其链接。缓存文件将不再可见，即使它们还在使用。这可以确保当播放器终止时，它们被保证从磁盘中删除，即使它崩溃了。

    ``whendone``
        关闭后删除缓存文件。

    ``no``
        不要删除缓存文件。它们会消耗磁盘空间而没有用途。

    目前，这只用于 ``--cache-on-disk``

``--stream-buffer-size=<bytesize>``
    低层流字节缓冲区的大小（默认： 128KB）。它被用作解复用器和低级I/O（例如套接字）之间的缓冲区。一般来说，它可以非常小，主要用途类似于C标准库中的内部缓冲区FILE。

    缓冲区的一半总是用于保证回寻，这对不可回寻的输入很重要。

    有一些已知的情况，这可以帮助性能设置一个大的缓冲区。

        1. mp4文件。libavformat可能会在两个方向上触发许多小的寻道，这取决于文件是如何被混频的。

        2. 某些网络文件系统，它们没有缓存，小的读取可能是低效的。

    在其他情况下，将其设置为一个大的值会降低性能。

    通常情况下，读取访问是在缓冲区大小的一半，但可能会发生访问是在较小和较大的大小交替进行的情况（这是由于内部环形缓冲区的缠绕）。

    默认值和取值范围见 ``--list-options`` 。 ``<bytesize>`` 选项接受后缀，如 ``KiB`` 和 ``MiB`` 。

``--vd-queue-enable=<yes|no>, --ad-queue-enable``
    启用在一个单独的线程上运行视频/音频解码器（默认： no）。如果启用，解码器将在一个单独的线程上运行，并在解码器和高层播放逻辑之间放置一个帧队列。帧队列的大小由下面的其他选项定义。

    This is probably quite pointless. libavcodec已经有了多线程解码（默认启用），这使得它基本上没有必要。在一些高带宽视频解码缓慢的角落里，它可能会有帮助（在这些情况下，libavcodec会阻塞播放逻辑，而使用解码线程会均匀地分配解码时间，而不影响播放逻辑）。在其他情况下，它只是会使搜索速度变慢，并使用明显更多的内存。

    队列大小受其他 ``--vd-queue-...`` 选项的限制。最终的队列大小是具有最低限制的选项所指示的最小值。每个解码器/磁道都有自己的队列，可以使用全部配置的队列大小。

    大多数队列选项可以在运行时改变。 ``--vd-queue-enable`` 本身（和音频等价物）只有在解码完全重新初始化时才会更新。然而，设置 ``--vd-queue-max-samples=1`` 应该几乎导致与 ``--vd-queue-enable=no`` 相同的行为，因此该值可用于有效的运行时启用/禁用队列。

    这不应该被用于硬件解码。有可能为音频启用这个功能，但这更没有意义。

``--vd-queue-max-bytes=<bytesize>``, ``--ad-queue-max-bytes``
    队列的最大近似允许大小。如果超过了，解码将被停止。最大尺寸可以超过大约1帧。

    默认值和数值范围见 ``--list-options`` 。 ``<bytesize>`` 选项接受后缀，如 ``KiB`` 和 ``MiB``

``--vd-queue-max-samples=<int>``, ``--ad-queue-max-samples``
    队列的最大帧数（视频）或样本数（音频）。音频的大小可能会超过1帧左右。

    默认值和取值范围见 ``--list-options``

``--vd-queue-max-secs=<seconds>``, ``--ad-queue-max-secs``
    队列中媒体的最大秒数。特殊值0意味着不设置限制。队列大小可能会超过2帧左右。时间戳重置可能导致队列大小的随机使用。

    参见 ``--list-options`` ，了解默认值和数值范围。

Network
-------

``--user-agent=<string>``
    使用 ``<string>`` 作为HTTP流媒体的用户代理。

``--cookies``, ``--no-cookies``
    在进行HTTP请求时支持cookies。默认情况下是禁用的。

``--cookies-file=<filename>``
    从<filename>读取HTTP cookies。该文件被认为是Netscape的格式。

``--http-header-fields=<field1,field2>``
    在访问HTTP流时设置自定义HTTP字段。

    这是一个字符串列表选项。详见 `List Options`_

    .. admonition:: 示例

        ::

            mpv --http-header-fields='Field1: value1','Field2: value2' \
            http://localhost:1234

        Will generate HTTP request::

            GET / HTTP/1.0
            Host: localhost:1234
            User-Agent: MPlayer
            Icy-MetaData: 1
            Field1: value1
            Field2: value2
            Connection: close

``--http-proxy=<proxy>``
    HTTP/HTTPS代理的URL。如果设置了这个， ``http_proxy`` 环境就被忽略了。 ``no_proxy`` 的环境变量仍然被尊重。如果该选项不是以 ``http://`` 开头，则会被默默地忽略。代理不用于https URLs。设置这个选项并不试图让ytdl脚本使用代理。

``--tls-ca-file=<filename>``
    用于TLS的证书授权数据库文件。(在较早的FFmpeg或Libav版本中默默失效)。

``--tls-verify``
    当使用TLS时，验证对方的证书（例如，用 ``https://...`` ）。(在较早的FFmpeg或Libav版本中默默失败。)

``--tls-cert-file``
    一个包含证书的文件，用于与对方握手。

``--tls-key-file``
    一个包含证书的私钥的文件。

``--referrer=<string>``
    为HTTP请求指定一个推荐人路径或URL。

``--network-timeout=<seconds>``
    指定网络超时，以秒为单位（默认： 60秒）。这至少会影响到HTTP。特殊值0使用FFmpeg/Libav的默认值。如果使用的协议不支持超时，这个选项会被默默地忽略。

    .. warning::

        这破坏了RTSP协议，因为FFmpeg的API在其内部超时选项上不一致。RTSP超时选项不仅接受不同的单位（秒而不是微秒，导致mpv传递给它巨大的数值），而且还会溢出FFmpeg的内部计算结果。最糟糕的是，仅仅设置该选项就会使RTSP进入监听模式，这就破坏了任何客户端的使用。在写这篇文章的时候，这个修正还没有生效。由于这个原因，这个选项在RTSP URL上被忽略（或应该被忽略）。你仍然可以直接用 ``--demuxer-lavf-o`` 设置超时选项。

``--rtsp-transport=<lavf|udp|udp_multicast|tcp|http>``
    选择RTSP传输方式（默认： tcp）。在播放 ``rtsp://...`` 网址时，这将选择底层网络传输。值 ``lavf`` 将决定权留给libavformat。

``--hls-bitrate=<no|min|max|<rate>>``
    如果播放HLS流，该选项控制默认选择哪些流。该选项允许以下参数：

    :no:        不要做任何特别的事情。通常，这将简单地选择它能找到的第一个音频/视频流。
    :min:       挑选比特率最低的数据流。
    :max:       相同的，但最高的比特率。(默认。)

    此外，如果选项是一个数字，那么将选择最高速率等于或低于选项值的流。

    所用的比特率是由服务器发送的，不能保证它是真正有意义的。

DVB
---

``--dvbin-prog=<string>``
    这定义了要调谐的节目。通常，你可以通过使用流URI来指定，如 ``"dvb://ZDF HD"`` ，但你可以通过在运行时写入此属性来调谐到不同的频道。也可以参见 ``dvbin-channel-switch-offset`` ，以获得更有用的频道切换功能。

``--dvbin-card=<0-15>``
    指定使用卡号0-15（默认： 0）。

``--dvbin-file=<filename>``
    指示mpv从 ``<filename>`` 中读取通道列表。默认是在mpv配置目录下（通常是 ``~/.config/mpv`` ），文件名是 ``channels.conf.{sat,ter,cbl,atsc}`` （根据你的卡类型）或 ``channels.conf`` 作为最后手段。对于DVB-S/2卡，推荐使用VDR 1.7.x格式的频道表，因为它可以调谐到DVB-S2频道，启用字幕并对PMT进行解码（这在很大程度上改善了解扰）。仍然支持经典的mplayer格式的频道表（没有这些改进），对于其他卡类型，只实现了有限的VDR格式频道表支持（欢迎打补丁）。对于有动态PID切换或不完整的 ``channels.conf`` 的频道，推荐使用 ``-dvbin-full-transponder`` 或神奇的PID ``8192``

``--dvbin-timeout=<1-30>``
    试图调整一个频率时，在放弃前等待的最大秒数（默认： 30）。

``--dvbin-full-transponder=<yes|no>``
    不对程序的PID进行过滤，只对频率进行调整，并将全转发器传给解复用器。在这种情况下，播放器前端从全转发器中选择流，所以最初显示的节目可能与所选频道不一致。通过循环 ``program`` 属性，可以在节目之间进行切换。这对于在一个转发器上录制多个节目，或解决 ``channels.conf`` 中的问题很有用。我们也建议对那些即时切换PID的频道使用这个功能，例如区域新闻。

    默认： ``no``

``--dvbin-channel-switch-offset=<integer>``
    这个值不是用来通过配置设置的，而是用于频道切换。一个 ``input.conf`` 可以 ``cycle`` 这个值， ``up`` 和 ``down`` 执行通道切换。这个数字有效地提供了在频道列表中最初调整的频道的偏移量。

    一个例子 ``input.conf`` 可以包含：``H cycle dvbin-channel-switch-offset up``, ``K cycle dvbin-channel-switch-offset down``

ALSA audio output options
-------------------------


``--alsa-device=<device>``
    已Deprecated，使用 ``--audio-device`` （需要 ``alsa/`` 前缀）。

``--alsa-resample=yes``
    启用ALSA重采样插件。(这在默认情况下是禁用的，因为一些驱动程序在某些情况下报告了不正确的音频延迟)。

``--alsa-mixer-device=<device>``
    设置与 ``ao-volume`` 一起使用的混音器设备（默认： ``default`` ）。

``--alsa-mixer-name=<name>``
    设置混音器元素的名称（默认： ``Master`` ）。例如，这是 ``PCM`` 或 ``Master``

``--alsa-mixer-index=<number>``
    设置混音器通道的索引（默认： 0）。考虑到 "``amixer scontrols``" 的输出，那么索引就是元素名称后面的数字。

``--alsa-non-interleaved``
    允许输出非交错格式（如果音频解码器使用这种格式）。目前默认是禁用的，因为一些流行的ALSA插件在使用非交错格式时完全失效。

``--alsa-ignore-chmap``
    不要读取或设置ALSA设备的通道图--只请求所需的通道数，然后将音频原封不动地传给它。这个选项很可能不应该被使用。它在调试中可能很有用，或者对于有特殊设计的ALSA配置的静态设置（在这种情况下，你应该总是用 ``--audio-channels`` 强制使用相同的布局，否则它只对使用ALSA设备隐含布局的文件有效）。

``--alsa-buffer-time=<microseconds>``
    以微秒为单位设置请求的缓冲时间。如果数值为0，就可以不向ALSA API请求任何东西。这个选项和 ``--alsa-periods`` 选项使用ALSA的 ``near`` 函数来设置要求的参数。如果这样做的结果是一个空的配置集，那么就跳过设置这些参数。

    这两个选项都控制缓冲区的大小。低的缓冲区大小会导致较高的CPU使用率和音频掉线，而高的缓冲区大小则会导致音量变化和其他过滤的延迟。

``--alsa-periods=<number>``
    从ALSA API请求的周期数。参见 ``--alsa-buffer-time`` 以了解更多信息。


GPU renderer options
-----------------------

以下视频选项目前都是针对 ``--vo=gpu``, ``--vo=libmpv`` and ``--vo=gpu-next`` 的，它们是唯一实现这些选项的VO。

``--scale=<filter>``
    缩放视频时使用的过滤器函数。

    ``bilinear``
        双线性硬件纹理过滤（最快，质量很低）。由于兼容性原因，这是默认的。

    ``spline36``
        中等质量和速度。这是使用 ``gpu-hq`` 时的默认值。

    ``lanczos``
        Lanczos 缩放。提供中等质量和速度。一般来说比 ``spline36`` 差，但它的结果是图像稍微清晰，对某些内容类型来说是好的。可以用 ``scale-radius`` 来控制抽头的数量，但最好不做改变。

        (这个过滤器是 ``sinc``-windowed ``sinc`` 的别名)

    ``ewa_lanczos``
        椭圆加权平均Lanczos缩放法。也被称为Jinc。相对较慢，但质量非常好。半径可以用 ``scale-radius`` 来控制。增加半径会使滤镜更清晰，但会增加振铃。

        (这个过滤器是 ``jinc``-windowed ``jinc`` 的别名)

    ``ewa_lanczossharp``
        ewa_lanczos的一个稍微锐化的版本，预设为使用一个理想的半径和参数。如果你的硬件可以运行它，这可能是你应该默认使用的。

    ``mitchell``
        Mitchell-Netravali。 ``B`` 和 ``C`` 参数可以用 ``--scale-param1`` 和 ``--scale-param2`` 设置。这个过滤器在缩小比例方面非常好（见 ``--dscale`` ）。

    ``oversample``
        近邻的一个版本，（天真地）对像素进行过度采样，因此，重叠在边缘的像素会被线性内插，而不是被圆整。这基本上消除了由近邻插值引起的小缺陷和抖动伪影，以换取增加一些模糊度。这个滤波器擅长时间插值，也被称为 "smoothmotion"（见 ``--tscale`` ）。

    ``linear``
        一个 ``--tscale`` 的滤波器。

    还有一些过滤器，但大多数没有那么有用。要获得完整的列表，请把 ``help`` 作为值，例如::

        mpv --scale=help

``--cscale=<filter>``
    与 ``--scale`` 一样，但用于插值色度信息。如果图像没有进行子采样，这个选项将完全被忽略。

``--dscale=<filter>``
    和 ``--scale`` 一样，但在降尺度时应用这些过滤器。如果这个选项没有设置，将应用由 ``--scale`` 暗示的过滤器。

``--tscale=<filter>``
    用于插值时间轴（帧）的过滤器。只有当 ``--interpolation`` 被启用时才会使用。 ``--tscale`` 的唯一有效选择是可分离的卷积滤波器（使用 ``--tscale=help`` 来获得一个列表）。默认是 ``mitchell``

    常见的 ``--tscale`` 选择包括 ``oversample``, ``linear``, ``catmull_rom``, ``mitchell``, ``gaussian``, or ``bicubic`` 。这些都是按照平滑度/模糊度递增的顺序排列的， ``bicubic`` 是最平滑/最模糊的， ``oversample`` 是最清晰/最不平滑的。

``--scale-param1=<value>``, ``--scale-param2=<value>``, ``--cscale-param1=<value>``, ``--cscale-param2=<value>``, ``--dscale-param1=<value>``, ``--dscale-param2=<value>``, ``--tscale-param1=<value>``, ``--tscale-param2=<value>``
    设置过滤器参数。默认情况下，这些参数被设置为特殊的字符串 ``default`` ，它映射到一个特定的缩放器默认值。如果过滤器是不可调的，则忽略。目前，这影响到下列滤波器参数。

    bcspline
        花键参数（ ``B`` 和 ``C`` ）。两者的默认值为0.5。

    gaussian
        比例参数（ ``t`` ）。增加这个参数会使结果更模糊。默认值为1。

    oversample
        使用插值之前与边缘的最小距离。设置为0将总是插值边缘，而设置为0.5将永远不插值，因此表现为使用常规的最近的邻居算法。默认值是0.0。

``--scale-blur=<value>``, ``--scale-wblur=<value>``, ``--cscale-blur=<value>``, ``--cscale-wblur=<value>``, ``--dscale-blur=<value>``, ``--dscale-wblur=<value>``, ``--tscale-blur=<value>``, ``--tscale-wblur=<value>``
    内核/窗口的缩放系数（也被称为模糊系数）。减少它可以使结果更清晰，增加它可以使结果更模糊（默认为0）。如果设置为0，将使用内核的首选模糊系数。注意，设置太低（例如0.5）会导致不好的结果。通常建议使用0.8到1.2之间的值。

``--scale-clamp=<0.0-1.0>``, ``--cscale-clamp``, ``--dscale-clamp``, ``--tscale-clamp``
    指定一个权重偏置，以乘以负系数。指定 ``--scale-clamp=1`` 的效果是完全去除负的权重，从而有效地将数值范围限制在[0-1]。可以指定0.0和1.0之间的值，只对负权重进行适度减弱。这对 ``--tscale`` 特别有用，它可以减少时域的过度振铃伪影（通常表现为短促的闪光或黑色的边缘，主要是在移动的边缘），以换取可能增加的模糊度。 ``--tscale-clamp`` 的默认值是1.0，其他的默认值是0.0。

``--scale-cutoff=<value>``, ``--cscale-cutoff=<value>``, ``--dscale-cutoff=<value>``
    一旦数值范围下降到这个阈值以下，就提前切断过滤器的内核。这样做可以更积极地修剪可跳过的系数，不考虑LUT中被窗函数有效清零的部分。只影响极地（EWA）滤波器。默认是0.001，这在感觉上是透明的，但可以提供10%-20%的速度，这取决于所选择的确切半径和滤波器内核。

``--scale-taper=<value>``, ``--scale-wtaper=<value>``, ``--dscale-taper=<value>``, ``--dscale-wtaper=<value>``, ``--cscale-taper=<value>``, ``--cscale-wtaper=<value>``, ``--tscale-taper=<value>``, ``--tscale-wtaper=<value>``
    内核/窗口锥度系数。增加这个系数可以使滤波函数变平。值的范围是0到1。值为0（默认值）意味着没有平坦化，值为1使滤波器完全平坦（相当于一个盒式函数）。介于两者之间的值意味着某些部分将是平坦的，实际的滤波函数将被挤压到两者之间的空间中。

``--scale-radius=<value>``, ``--cscale-radius=<value>``, ``--dscale-radius=<value>``, ``--tscale-radius=<value>``
    为可调整的过滤器设置半径，必须是0.5到16.0之间的浮点数。如果没有指定，则默认为过滤器的首选半径。不是对每个缩放器和VO的组合都有效。

    注意，根据过滤器的实现细节和视频缩放比例，实际使用的半径可能是不同的（很可能被增加一点）。

``--scale-antiring=<value>``, ``--cscale-antiring=<value>``, ``--dscale-antiring=<value>``, ``--tscale-antiring=<value>``
    设置反响强度。这试图消除振铃，但在这个过程中可能会引入其他伪影。必须是0.0和1.0之间的浮点数。默认值为0.0，完全禁止反响。

    注意，这不影响特殊的滤镜 ``bilinear`` 和 ``bicubic_fast`` ，也不影响任何极地（EWA）缩放器。

``--scale-window=<window>``, ``--cscale-window=<window>``, ``--dscale-window=<window>``, ``--tscale-window=<window>``
    (仅限高级用户）为内核选择一个自定义的窗口功能。如果没有设置，则默认为过滤器的首选窗口。使用 ``--scale-window=help`` 来获得支持的窗口功能的列表。

``--scale-wparam=<window>``, ``--cscale-wparam=<window>``, ``--cscale-wparam=<window>``, ``--tscale-wparam=<window>``
    (仅限高级用户）配置由 ``--scale-window`` 等给出的窗口函数的参数。默认情况下，这些参数被设置为特殊的字符串 ``default`` ，它映射到一个特定窗口的默认值。如果窗口不能调整，则忽略不计。目前，这影响到以下窗口参数。

    kaiser
        窗口参数（alpha）。默认为6.33。
    blackman
        窗口参数（alpha）。默认为0.16。
    gaussian
        比例参数（t）。增加这个参数使窗口变宽。默认值为1。

``--scaler-lut-size=<4..10>``
    设置缩放器内核的查找纹理的大小（默认： 6）。纹理的实际大小是 ``2^N`` ，选项值为 ``N`` 。所以默认设置下的查找纹理使用64个样本。

    所有的权重都是从这些样本中线性插值出来的，所以增加查找表的大小可能会提高缩放器的精度。

``--scaler-resizes-only``
    如果视频图像没有调整大小，则禁用缩放器。在这种情况下， ``bilinear`` 会被用来代替 ``--scale`` 设置的任何东西。如果不进行缩放，双线性将完美再现源图像。默认情况下是启用的。注意，这个选项不会影响到 ``--cscale``

``--correct-downscaling``
    当使用基于卷积的过滤器时，在降频时扩展过滤器的大小。增加了质量，但降低了降尺度时的性能。

    这对变形视频来说会有轻微的次优表现（但仍然比没有好），因为它将扩大尺寸，只与轴之间的比例因子中较温和的那个相匹配。

    注意：当使用双线性降维（默认）时，该选项被忽略。

``--linear-downscaling``
    在降尺度时以线性光的方式进行缩放。它只能用于至少有16位精度的 ``--fbo-format`` 。这个选项对HDR内容没有影响。

``--linear-upscaling``
    在升格时以线性光进行缩放。和 ``--linear-downscaling`` 一样，它只能用于至少有16位精度的 ``--fbo-format`` 。除了测试/特殊目的外，通常不建议这样做。建议用户启用 ``--sigmoid-upscaling`` 或保持两个选项都禁用（即在伽玛光下缩放）。

``--sigmoid-upscaling``
    当升频时，使用正弦波颜色变换以避免强调振铃假象。这与 ``--linear-upscaling`` 不兼容，并取代了它。(注意sigmoidization也需要线性化，所以 ``LINEAR`` 渲染步骤在两种情况下都会启动)

``--sigmoid-center``
    用于 ``--sigmoid-upscaling`` 的sigmoid曲线的中心，必须是0.0到1.0之间的浮点数。如果没有指定，默认为0.75。

``--sigmoid-slope``
    用于 ``--sigmoid-upscaling`` 的sigmoid曲线的斜率，必须是1.0到20.0之间的浮点数。如果没有指定，默认为6.5。

``--interpolation``
    减少由视频帧数和显示刷新率不匹配引起的停顿（也称为抖动）。

    .. warning:: 这需要将 ``--video-sync`` 选项设置为 ``display-`` 模式之一，否则它将被默默禁用。这在mpv0.14.0之前是不需要的。

    这实质上是试图通过沿时间轴卷积视频来插补缺失的帧。使用的过滤器可以用 ``--tscale`` 设置来控制。

``--interpolation-threshold=<0..1,-1>``
    低于这个阈值的帧率插值将被禁用（默认： ``0.01`` ）。计算方法是 ``abs(disphz/vfps - 1) < threshold`` ，其中 ``vfps`` 是速度调整后的视频FPS， ``disphz`` 是显示刷新率。(速度调整后的视频FPS大致等于正常的视频FPS，但是应用了减速和加速。如果你使用 ``--video-sync=display-resample`` 来使视频与显示FPS同步运行，或者改变 ``speed`` 属性，这就很重要了）。

    默认的目的是在使用 ``--video-sync=display-*`` 的重定时不能充分调整视频速度以实现流畅播放的情况下启用插值。例如，如果一个视频是60.00FPS，而你的显示器刷新率是59.94Hz，插值将永远不会被激活，因为不匹配是在刷新率的1%以内。默认值还处理了mpv不能确定容器FPS的情况，比如在某些直播流中，可能会动态地切换插值的开启和关闭。在这种情况下，默认情况是不使用插值，而是允许 ``--video-sync=display-*`` 来重新计时视频以匹配显示器的刷新率。参见 ``--video-sync-max-video-change`` 以了解更多关于mpv如何重新计时视频的信息。

    还要注意的是，如果你使用 ``--video-sync=display-vdrop`` ，速率的微小偏差会使插值失效，每隔一分钟就会引入一个不连续。

    将此设置为 ``-1`` 来禁用这个逻辑。

``--interpolation-preserve``
    即使渲染器参数发生变化，也会保留前几帧的插值结果 - 与剪裁和视频放置有关的选项除外，这些选项总是会使缓存失效。启用该选项可以使渲染器设置的动态更新更加顺畅，但代价是对这种变化的响应延迟会稍高。默认为开启。(只影响到 ``--vo=gpu-next`` ，注意 ``-vo=gpu`` 总是使插值的帧失效)

``--opengl-pbo``
    启用PBOs的使用。在某些驱动上，这可能会更快，特别是当源视频尺寸很大时（例如所谓的 "4K "视频）。在其他驱动上，这可能会更慢或导致延迟问题。

``--dither-depth=<N|no|auto>``
    将抖动目标深度设置为N，默认： no

    no
        禁用mpv所做的任何抖动。
    auto
        自动选择。如果不能检测到输出位深度，则假定每个分量为8位。
    8
        抖动到8比特输出。

    注意，连接的视频显示设备的深度不能被检测到。通常情况下，LCD面板会自己进行抖动，这与这个选项相冲突，导致输出很难看。

``--dither-size-fruit=<2-8>``
    设置抖动矩阵的大小（默认： 6）。矩阵的实际大小是 ``(2^N) x (2^N)`` ，选项值为 ``N`` ，所以值为6时，大小为64x64。矩阵在启动时生成，一个大的矩阵可能需要相当长的时间来计算（秒）。

    只在 ``--dither=fruit`` 模式下使用。

``--dither=<fruit|ordered|error-diffusion|no>``
    选择抖动算法（默认： fruit）。(通常情况下， ``--dither-depth`` 选项控制是否启用抖动。)

    ``error-diffusion`` 选项需要计算着色器支持。它也需要大量的共享内存来运行，其大小取决于内核（见下面的 ``--error-diffusion`` 选项）和视频窗口的高度。如果没有足够的共享内存来运行着色器，它将退回到 ``fruit`` 抖动。

``--temporal-dither``
    启用时间性抖动。(只有在一般情况下启用抖动时才会激活。)通过改变平铺的抖动矩阵的方向，在每一帧中改变8种不同的抖动模式。不幸的是，这可能会导致LCD显示器上的闪烁，因为这些显示器有很高的反应时间。

``--temporal-dither-period=<1-128>``
    决定在使用 ``--temporal-dither`` 时，抖动模式的更新频率。1（默认）将在每一帧视频上更新，2在每隔一帧更新，等等。

``--error-diffusion=<kernel>``
    当设置了 ``--dither=error-diffusion`` 时，使用的错误扩散内核。

    ``simple``
        只向相邻的两个像素传播误差。最快但质量低。

    ``sierra-lite``
        速度快，质量合理。这是默认的。

    ``floyd-steinberg``
        最值得注意的误差扩散内核。

    ``atkinson``
        看起来与其他内核不同，因为在抖动过程中只有部分错误会被传播。这个内核的典型用途是保存抖动的屏幕截图（在窗口模式下）。这个内核产生的文件稍小，但抖动质量仍然合理。

    还有其他的内核（使用 ``--error-diffusion=help`` 列出），但它们中的大多数都要慢得多，而且需要更大的共享内存。在这些内核中， ``burkes`` 在性能和质量之间取得了良好的平衡，可能是你想首先尝试的内核。

``--gpu-debug``
    启用GPU调试。这意味着什么，取决于API类型。对于OpenGL，它调用 ``glGetError()`` ，并请求一个调试环境。对于Vulkan，它启用验证层。

``--opengl-swapinterval=<n>``
    两次缓冲区互换之间的显示帧数间隔。1相当于启用VSYNC，0相当于禁用VSYNC。如果没有指定，默认为1。

    注意，这取决于正确的OpenGL vsync支持。在某些平台和驱动上，只有在全屏模式下才能可靠地工作。如果使用多个显示器，它可能还需要特定的驱动程序黑客，以确保mpv同步到正确的显示器。合成窗口管理器也会导致不好的结果，就像缺少或不正确的显示FPS信息一样（见 ``--overrid-display-fps`` ）。

``--vulkan-device=<device name>``
    用于渲染和演示的Vulkan设备的名称。使用 ``--vulkan-device=help`` 来查看可用设备的列表和它们的名称。如果没有指定，将使用第一个列举的硬件Vulkan设备。

``--vulkan-swap-mode=<mode>``
    控制vulkan swapchain的呈现模式。这与 ``--opengl-swapinterval`` 选项相似。

    auto
        使用vulkan上下文的首选swapchain模式。(默认)
    fifo
        非撕裂，vsync被阻止。与 "VSync on "类似。
    fifo-relaxed
        撕裂，vsync被阻止。迟来的帧会撕裂而不是结巴。
    mailbox
        不撕裂，不阻断vsync。类似于 "三重缓冲"。
    immediate
        撕裂，不被vsync阻断。类似于 "VSync关闭"。

``--vulkan-queue-count=<1..8>``
    控制用于渲染的VkQueues的数量（由你的设备支持的数量限制）。理论上，使用更多的队列可以在帧之间实现一些并行性（当使用 ``--swapchain-depth`` 高于1时），但在队列之间没有真正的并行性的硬件上，它也会使事情变得缓慢。(默认： 1)

``--vulkan-async-transfer``
    在支持的vulkan设备上启用异步传输队列的使用。使用它们可以使纹理上传和混合等传输操作与实际渲染同时进行，从而提高整体吞吐量和功耗。默认情况下是启用的，而且应该是相对安全的。

``--vulkan-async-compute``
    在支持的vulkan设备上启用异步计算队列的使用。从理论上讲，使用它可以实现计算着色器与图形着色器的失序调度，从而使硬件在等待管线气泡和内存操作时能够做更有效的工作。不是在所有的GPU上都有好处。值得注意的是，如果启用了异步计算，并且设备支持的计算队列多于图形队列（受 ``--vulkan-queue-count`` 的限制），mpv将在内部尝试并尽可能优先使用计算着色器而不是片段着色器。默认情况下是启用的，尽管Nvidia用户可能想禁用它。

``--vulkan-disable-events``
    禁用VkEvents，用于调试或与一些不提供VkEvent支持的旧驱动/ vulkan移植层兼容。

``--vulkan-display-display=<n>``
    当使用 ``displayvk`` GPU上下文时，选定的Vulkan设备上的显示器的索引将呈现在上面。使用 ``--vulkan-display-display=help`` 来查看可用的显示器列表。如果没有指定，将使用第一个列举的显示器。


``--vulkan-display-mode=<n>``
    当使用 ``displayvk`` GPU上下文时，所选Vulkan显示器的显示模式的索引。使用 ``--vulkan-display-mode=help`` 来查看可用模式的列表。如果没有指定，将使用第一个列举的模式。

``--vulkan-display-plane=<n>``
    当使用 "displayvk "GPU上下文时，选定的Vulkan设备上的平面的索引，以呈现在上面。使用 ``--vulkan-display-plane=help`` 来查看可用平面的列表。如果没有指定，将使用第一个列举的平面。

``--d3d11-exclusive-fs=<yes|no>``
    当全屏视频被请求时，将D3D11交换链的全屏状态切换为 "全屏"。在其他应用程序中也被称为 "独占全屏 "或 "D3D全屏"。让mpv完全控制在交换链的屏幕上进行渲染。默认情况下是关闭的。

``--d3d11-warp=<yes|no|auto>``
    使用WARP（Windows高级光栅化平台）与D3D11 GPU后端（默认： auto）。这是一个高性能的软件渲染器。默认情况下，只有当系统没有支持D3D11的硬件适配器时才会使用它。虽然扩展的GPU功能将与WARP一起工作，但它们可能非常慢。

``--d3d11-feature-level=<12_1|12_0|11_1|11_0|10_1|10_0|9_3|9_2|9_1>``
    在使用D3D11 GPU后端时，选择一个特定的特性级别。默认情况下，会使用最高的可用特性级别。这个选项可以用来选择一个较低的功能级别，这主要是对调试有用。大多数扩展的GPU特性在9_x特性级别下将无法工作。

``--d3d11-flip=<yes|no>``
    启用翻转模型展示，通过与DWM共享表面来避免不必要地复制backbuffer（默认： yes）。这可能会导致旧驱动的性能问题。如果不支持翻转模型展示（例如，在没有平台更新的Windows 7上），mpv将自动退回到旧的bitblt展示模型。

``--d3d11-sync-interval=<0..4>``
    安排每一帧的VBlank间隔数。(默认值：1) 设置为1将启用VSync，设置为0将禁用它。

``--d3d11-adapter=<adapter name|help>``
    选择一个特定的D3D11适配器来进行D3D11渲染。如果没有设置，将选择默认的适配器。当给出 "help "这个名字时，会列出其他的适配器。

    根据字符串的开头来检查是否匹配，不区分大小写。因此，如果适配器的描述以厂商名称开始，就可以利用它作为选择参数。

    利用D3D11渲染抽象的辅助功能来接收设备的硬件解码器，如D3D11VA或DXVA2的DXGI模式，将受此选择影响。

``--d3d11-output-format=<auto|rgba8|bgra8|rgb10_a2|rgba16f>``
    选择一种特定的D3D11输出格式，用于D3D11渲染。"auto "是默认的，它将根据配置的桌面位深度选择rgba8或rgb10_a2。rgba16f和bgra8不在自动检测逻辑中，可用于手动测试。

    .. note::

        桌面位深度的查询只来自于Windows 10的API。因此在旧系统上，它只能自动利用rgba8输出格式。

``--d3d11-output-csp=<auto|srgb|linear|pq|bt.2020>``
    选择一个特定的D3D11输出颜色空间，用于D3D11渲染。"auto "是默认值，它将选择交换链所在的桌面的颜色空间。

    除了 "srgb "和 "pq "以外的值在测试中出现了问题，所以它们主要用于手动测试。

    .. note::

        交换链颜色空间的配置只能从Windows 10的API中获得。因此，在旧系统上它将无法工作。

``--d3d11va-zero-copy=<yes|no>``
    默认情况下，当使用硬件解码时 ``--gpu-api=d3d11`` ，视频图像将从解码器表面复制（GPU到GPU）到着色器资源。设置这个选项可以避免复制，直接从解码器图像中采样。这可能会提高性能并降低功耗，但是由于填充的原因，可能会导致图像在底部和右侧边缘的采样不正确，并且可能会引发驱动错误，因为Direct3D 11在技术上不允许从解码器表面采样（尽管大多数驱动支持它）。

    目前只与 ``--gpu-api=d3d11`` 有关。

``--wayland-app-id=<string>``
    为基于Wayland的视频输出方法设置客户端应用程序ID（默认为： ``mpv`` ）。

``--wayland-disable-vsync=<yes|no>``
    禁用wayland上下文的vsync（默认： no）。当与 ``video-sync=display-desync``, ``--no-audio``, and ``--untimed=yes`` 结合使用时，对wayland上下文进行基准测试很有用。只适用于 ``--gpu-context=wayland`` 和 ``--gpu-context=waylandvk``

``--wayland-edge-pixels-pointer=<value>``
    定义一个边缘边界的大小（默认： 10），以便在wayland上下文中用鼠标启动客户端的调整事件。这只有在没有来自合成器的服务器端装饰时才会激活。

``--wayland-edge-pixels-touch=<value>``
    定义边缘边界的大小（默认： 32），在wayland上下文中用触摸事件启动客户端调整大小的事件。

``--spirv-compiler=<compiler>``
    控制哪个编译器用于将GLSL翻译成SPIR-V。这（目前）只与 ``--gpu-api=vulkan`` 和 ``--gpu-api=d3d11`` 有关。目前可能的选择只有。

    auto
        使用第一个可用的编译器。(默认)
    shaderc
        使用libshaderc，它是一个围绕glslang的API包装器。如果有的话，这通常是最受欢迎的。

    .. note::

        这个选项已deprecated，因为只有一个合理的值。它可能在将来被删除。

``--glsl-shader=<file>``, ``--glsl-shaders=<file-list>``
    自定义GLSL钩子。这些是一种灵活的方式来添加自定义片段着色器，可以在渲染管道中几乎任意的点注入，并访问所有先前的中间纹理。

    每次使用 ``--glsl-shader`` 选项都会在内部着色器列表中添加另一个文件，而 ``--glsl-shaders`` 则需要一个文件列表，并用它覆盖内部列表。后者是一个路径列表选项（详见 `List Options`_ ）。

    .. admonition:: 警告

        语法还不稳定，可能随时会改变。

    用户着色器的一般语法是这样的：:

        //!METADATA ARGS...
        //!METADATA ARGS...

        vec4 hook() {
           ...
           return something;
        }

        //!METADATA ARGS...
        //!METADATA ARGS...

        ...

    每一段元数据，连同它后面的非元数据行，都定义了一个单一的块。目前有两种类型的块，HOOKs和TEXTUREs。

    一个 ``TEXTURE`` block可以设置以下选项：

    TEXTURE <name> (required)
        这个纹理的名称。然后Hooks可以用BIND绑定这个名字下的纹理。这必须是纹理块的第一个选项。

    SIZE <width> [<height>] [<depth>] (required)
        纹理的尺寸。高度和深度是可选的。纹理的类型（1D、2D或3D）取决于指定的组件数量。

    FORMAT <name> (required)
        The texture format for the samples. Supported texture formats are listed in debug logging when the ``gpu`` VO is initialized (look for ``Texture formats:``). Usually, this follows OpenGL naming conventions. For example, ``rgb16`` provides 3 channels with normalized 16 bit components. One oddity are float formats: for example, ``rgba16f`` has 16 bit internal precision, but the texture data is provided as 32 bit floats, and the driver converts the data on texture upload.

        虽然格式名称遵循通用的命名规则，但并不是所有的硬件、驱动、GL版本等都能使用这些格式。

    FILTER <LINEAR|NEAREST>
        从该纹理取样时使用的最小/放大率过滤器。

    BORDER <CLAMP|REPEAT|MIRROR>
        从该纹理取样时使用的边界包裹模式。

    元数据之后是一串十六进制的字节，定义了原始纹理数据，对应于 ``FORMAT`` 指定的格式，在单行上，没有多余的空白。

    ``HOOK`` block可以设置以下选项：

    HOOK <name> (required)
        要挂钩的纹理。在一个元数据块中可以出现多次，最多是一个预定的限制。请看下面的可钩住的纹理列表。

    DESC <title>
        用户友好型的通证描述。这是在属性 ``vo-passes`` 的通行证列表中代表该着色器时使用的名称。

    BIND <name>
        加载一个纹理（可以来自mpv，也可以来自 ``TEXTURE`` 块），并使其可用于该通道。当从mpv中绑定纹理时，这也将设置宏，以方便正确访问它。列表见下文。默认情况下，没有纹理被绑定。特殊名称HOOKED可以用来指代触发这个传递的纹理。

    SAVE <name>
        给出纹理的名称，以便将这次传递的结果保存到其中。默认情况下，它被设置为特殊名称HOOKED，具有覆盖挂钩纹理的效果。

    WIDTH <szexpr>, HEIGHT <szexpr>
        指定本次处理结果的纹理尺寸。 ``szexpr`` 指的是RPN（反向波尔符号）中的表达式，使用运算符+ - * / > < !，浮点字数，以及对现有纹理（如MAIN.width或CHROMA.height）、OUTPUT或NATIVE_CROPPED（经过平移扫描、视频对齐-x/y、视频-pan-x/y等裁剪的输入纹理的尺寸，可能还有预缩放）的引用。默认情况下，这些被设置为HOOKED.w和HOOKED.h，分别是。

    WHEN <szexpr>
        指定一个需要为真（非零）的条件，以使着色器阶段被评估。如果它失败了，它将被默默地省略。(注意，像这样的着色器阶段，如果依赖于一个可选的钩子点，仍然会导致钩子点被保存，这有一些小的开销)

    OFFSET <ox oy | ALIGN>
        表示这个通道所引入的像素偏移（offset）。这些像素偏移将被累积，并在下一个缩放通道（ ``cscale`` 或 ``scale`` ）中被纠正。默认值是0 0，对应于无偏移。请注意，在不覆盖挂钩纹理时，偏移量会被忽略。

        一个特殊的值  ``ALIGN`` 将试图通过将其与参照物对齐来修复HOOKED的现有偏移。它要求HOOKED是可调整大小的（见下文）。它与片段着色器透明地工作。对于计算着色器，需要使用预定义的 ``texmap`` 宏来处理坐标映射。

    COMPONENTS <n>
        指定这个通道的输出有多少个相关的组件，并且应该存储在纹理中，最多4个（rgba）。默认情况下，这个值等于HOOKED中的组件数。

    COMPUTE <bw> <bh> [<tw> <th>]
        Specifies that this shader should be treated as a compute shader, with the block size bw and bh. The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will be tw*th threads, forming a single work group. In other words: tw and th specify the work group size, which can be different from the block size. So for example, a compute shader with bw, bh = 32 and tw, th = 8 running on a 500x500 texture would dispatch 16x16 blocks (rounded up), each with 8x8 threads.

        Compute shaders in mpv are treated a bit different from fragment shaders. Instead of defining a ``vec4 hook`` that produces an output sample, you directly define ``void hook`` which writes to a fixed writeonly image unit named ``out_image`` (this is bound by mpv) using `imageStore`. To help translate texture coordinates in the absence of vertices, mpv provides a special function ``NAME_map(id)`` to map from the texel space of the output image to the texture coordinates for all bound textures. In particular, ``NAME_pos`` is equivalent to ``NAME_map(gl_GlobalInvocationID)``, although using this only really makes sense if (tw,th) == (bw,bh).

    每个绑定的mpv纹理（通过 ``BIND`` ）将为该着色器通道提供以下定义，其中NAME是绑定纹理的名称：

    vec4 NAME_tex(vec2 pos)
        用来访问某个点的纹理的采样函数（在纹理坐标空间，范围[0,1]）。这将处理任何必要的归一化转换。
    vec4 NAME_texOff(vec2 offset)
        以像素为单位在某一偏移处对纹理进行采样。工作原理与NAME_tex类似，但还负责必要的旋转，例如在vec2(-1,0)处取样，总是向左倾斜一个像素。
    vec2 NAME_pos
        该纹理的局部纹理坐标，范围[0,1]。
    vec2 NAME_size
        纹理的（旋转）尺寸，单位为像素。
    mat2 NAME_rot
        与该纹理相关的旋转矩阵。(将像素空间旋转到纹理坐标)
    vec2 NAME_pt
        单个像素的（未旋转的）尺寸，范围[0,1]。
    float NAME_mul
        需要乘以纹理内容的系数，以便将其归一化为[0,1]的范围。
    sampler NAME_raw
        原始绑定纹理本身。除非绝对必要，否则应避免使用这个。

    通常情况下，用户应该使用NAME_tex或NAME_texOff来读取纹理。然而，对于某些着色器来说，从NAME_RAW中进行自定义采样，性能会更好，在这种情况下，需要注意尊重NAME_mul和NAME_rot。

    除了这些参数外，以下uniforms也是全局可用的：

    float random
        范围为[0-1]的随机数，每帧不同。
    int frame
        一个简单的渲染帧数，每一帧增加一个，永不重置（不考虑寻求）。
    vec2 input_size
        输入图像的像素大小（可能经过裁剪和预缩放）。
    vec2 target_size
        缩放后（可能是裁剪后）的图像的可见部分的像素大小。
    vec2 tex_offset
        由用户着色器或panscan、video-align-x/y、video-pan-x/y等选项引入的纹理偏移。

    在内部，vo_gpu可以生成以下任意数量的纹理。每当一个纹理被vo_gpu渲染并保存时，所有钩住它的通道都会按照用户添加的顺序运行。这是一个合法钩点的列表。

    RGB, LUMA, CHROMA, ALPHA, XYZ (resizable)
        源平面（原始）。其中哪个火取决于源的图像格式。

    CHROMA_SCALED, ALPHA_SCALED (fixed)
        源平面（放大）。这些只在次采样的内容上启动。

    NATIVE (resizable)
        合并后的图像，在源色彩空间中，转换为RGB之前。

    MAINPRESUB (resizable)
        转换为RGB后的图像，但在应用 ``--blend-subtitles=video`` 之前。

    MAIN (resizable)
        主图像，在转换为RGB后，但在升格前。

    LINEAR (fixed)
        线性灯光图像，在缩放之前。这只在 ``--linear-upscaling``, ``--linear-downscaling`` or ``--sigmoid-upscaling`` 生效的情况下发生。

    SIGMOID (fixed)
        在缩放之前，对光线进行Sigmoid处理。这只在 ``--sigmoid-upscaling`` 生效的情况下发生。

    PREKERNEL (fixed)
        缩放器内核运行前的图像。

    POSTKERNEL (fixed)
        缩放器内核运行后的图像。

    SCALED (fixed)
        在进行色彩管理之前，最终升格的图像。

    OUTPUT (fixed)
        最终的输出图像，在色彩管理之后但在抖动和绘制到屏幕之前。

    只有标有 ``resizable`` 的贴图可以通过该通道进行转换。当覆盖一个标有 ``fixed`` 的纹理时，WIDTH、HEIGHT和OFFSET必须保持其默认值。

``--glsl-shader=<file>``
    CLI/配置文件只是 ``--glsl-shaders-append`` 的别名。

``--deband``
    启用debanding算法。这大大减少了可见的条带、阻塞和其他量化伪影的数量，代价是使一些最细微的细节变得非常模糊。在实践中，它几乎总是一种改进--禁用它的唯一原因是为了性能。

``--deband-iterations=<1..16>``
    每个样本要执行的去带步骤的数量。每一步都会减少一点带状物，但需要时间来计算。注意，每一步的强度下降得很快，所以高数字（>4）实际上是无用的。(默认： 1)

``--deband-threshold=<0..4096>``
    除杂滤波器的截止阀值。较高的数字会大大增加除杂强度，但会逐渐减少图像细节。(默认： 32)

``--deband-range=<1..64>``
    除杂滤波器的初始半径。半径在每次迭代中线性增加。较高的半径会找到更多的梯度，但较低的半径会更积极地平滑。(默认： 16)

    如果你增加了 ``--deband-iterations`` ，你可能应该减少这个半径来进行补偿。

``--deband-grain=<0..4096>``
    给图像添加一些额外的噪声。这大大有助于掩盖剩余的量化伪影。更高的数字会增加更多的噪声。(默认： 48)

``--sharpen=<value>``
    如果设置为0以外的值，则启用非锐化屏蔽滤波器。正值将锐化图像（但增加更多的振铃和混叠）。负值会使图像变得模糊。如果你的GPU足够强大，可以考虑使用 ``ewa_lanczossharp`` 比例滤波器或 ``--scale-blur`` 选项。(只适用于 ``--vo=gpu`` )

``--opengl-glfinish``
    在交换缓冲区之前调用 ``glFinish()`` （默认：禁用）。速度较慢，但在进行帧掠夺时可能会改善结果。可以完全破坏性能。细节完全取决于OpenGL驱动。

``--opengl-waitvsync``
    在每次缓冲区交换后调用 ``glXWaitVideoSyncSGI`` （默认：禁用）。这可能会也可能不会对视频计时的准确性和丢帧有帮助。这有可能使视频输出变慢，或者根本没有影响。

    仅限X11/GLX。

``--opengl-dwmflush=<no|windowed|yes|auto>``
    在Windows下交换缓冲区后调用 ``DwmFlush`` （默认： auto）。它还设置了 ``SwapInterval(0)`` ，以忽略OpenGL的时间。值是：no（禁用），windowed（仅在windowed模式下），yes（也在全屏下）。

    值 ``auto`` 将尝试确定合成器是否处于活动状态，只有当它似乎处于活动状态时才调用 ``DwmFlush``

    这可能有助于获得更一致的帧间隔，特别是对于高帧率的剪辑--这也可能减少丢帧。通常，一个 ``windowed`` 的值就足够了，因为全屏可能会绕过DWM。

    仅限Windows。

``--angle-d3d11-feature-level=<11_0|10_1|10_0|9_3>``
    在D3D11中使用ANGLE后端时，选择一个特定的功能级别。默认情况下，会使用最高的可用特征级别。这个选项可以用来选择一个较低的特征级别，这主要对调试有用。请注意，OpenGL ES 3.0只支持10_1或更高的特性级别。大多数扩展的OpenGL功能在较低的功能级别下无法工作（类似于 ``--gpu-dumb-mode`` ）。

    Windows只支持ANGLE。

``--angle-d3d11-warp=<yes|no|auto>``
    当使用ANGLE后端和D3D11时，使用WARP（Windows高级光栅化平台）（默认： auto）。这是一个高性能的软件渲染器。默认情况下，当Direct3D硬件不支持Direct3D 11功能级别9_3时，会使用它。虽然扩展的OpenGL功能将与WARP一起工作，但它们可能非常慢。

    Windows只使用ANGLE。

``--angle-egl-windowing=<yes|no|auto>``
    使用ANGLE的内置EGL窗口功能来创建交换链（默认： auto）。如果设置为 ``no`` ，并且正在使用D3D11渲染器，ANGLE内置的交换链将不被使用，而是创建一个为视频渲染而优化的自定义交换链。如果设置为 ``auto`` ，自定义交换链将用于D3D11，而内置交换链将用于D3D9。这个选项主要是为了调试，以防自定义交换链的性能不佳或不工作。

    如果设置为 ``yes`` ，  ``--angle-max-frame-latency``, ``--angle-swapchain-length`` 和 ``--angle-flip``  选项将没有影响。

    只在Windows中使用ANGLE。

``--angle-flip=<yes|no>``
    启用翻转模型演示，这可以避免通过与DWM共享表面而不必要地复制backbuffer（默认： yes）。这可能会导致旧驱动的性能问题。如果不支持翻转模型展示（例如，在没有平台更新的Windows 7上），mpv将自动退回到旧的bitblt展示模型。

    如果设置为 ``no`` ， ``--angle-swapchain-length`` 选项将没有影响。

    只在Windows中使用ANGLE。

``--angle-renderer=<d3d9|d3d11|auto>``
    在使用ANGLE后端时强制使用特定的渲染器（默认： auto）。在自动模式下，对于支持Direct3D 11功能级别9_3或更高的系统，它会选择D3D11，否则会选择D3D9。这个选项主要是为了调试的目的。通常情况下，没有理由强制使用特定的渲染器，尽管 ``--angle-renderer=d3d9`` 在旧硬件上可能会有稍好的性能。请注意，D3D9渲染器只支持OpenGL ES 2.0，所以如果选择了这个渲染器，大多数扩展的OpenGL功能将无法工作（类似于 ``--gpu-dumb-mode`` ）。

    只支持ANGLE的Windows。

``--macos-force-dedicated-gpu=<yes|no>``
    停用自动图形切换并强制使用专用GPU。(默认： no)

    仅限macOS。

``--cocoa-cb-sw-renderer=<yes|no|auto>``
    在使用cocoa-cb时使用苹果软件渲染器（默认： auto）。如果设置为 ``no`` ，软件渲染器永远不会被使用，而是在无法创建通常的像素格式时失败， ``yes`` 将永远只使用软件渲染器，而 ``auto`` 只在无法创建通常的像素格式时退回到软件渲染器。

    仅限macOS。

``--cocoa-cb-10bit-context=<yes|no>``
    为上下文的创建创建一个10bit的像素格式（默认： yes）。要求使用16位的半浮点帧缓冲器，而不是8位的整数帧缓冲器。

    仅限macOS。

``--macos-title-bar-appearance=<appearance>``
    设置标题栏的外观（默认：自动）。并非所有的外观和 ``--macos-title-bar-material`` 材料的组合都是有意义的或者是唯一的。当前macOS版本不支持的外观会退回到默认值。

    ``<appearance>`` 可以是下列之一：

    :auto:                     检测系统设置并适当地设置标题栏的外观。在macOS 10.14上，它也能检测到运行时的变化。
    :aqua:                     标准的macOS Light外观。
    :darkAqua:                 标准的macOS暗色外观。(macOS 10.14+)
    :vibrantLight:             充满活力的浅色外观。
    :vibrantDark:              深色的活力外观。
    :aquaHighContrast:         浅色无障碍外观。(macOS 10.14+)
    :darkAquaHighContrast:     深色无障碍外观。(macOS 10.14+)
    :vibrantLightHighContrast: 轻度活力的可访问性外观。(macOS 10.14+)
    :vibrantDarkHighContrast:  深色活力的可访问性外观。(macOS 10.14+)

``--macos-title-bar-material=<material>``
    设置标题栏的材质（默认：标题栏）。所有被废弃的材质不应该在macOS 10.14+上使用，因为它们的功能没有保证。不是所有的材质和 ``--macos-title-bar-appearance`` 的组合都有意义，也不是唯一的。你当前的macOS版本不支持的材料会退回到默认值。 仅限macOS和cocoa-cb

    ``<material>`` 可以是以下的一种：

    :titlebar:              标准的macOS titel bar材料。
    :selection:             标准的macOS选择材料。
    :menu:                  标准的macOS菜单材料。(macOS 10.11以上)
    :popover:               标准的macOS弹出窗口材料。(macOS 10.11+)
    :sidebar:               标准的macOS侧边栏材料。(macOS 10.11+)
    :headerView:            标准的macOS标题视图材料。(macOS 10.14+)
    :sheet:                 标准的macOS页面材料。(macOS 10.14+)
    :windowBackground:      标准的macOS窗口背景材料。(macOS 10.14+)
    :hudWindow:             标准的macOS hudWindow材质。(macOS 10.14+)
    :fullScreen:            标准的macOS全屏素材。(macOS 10.14+)
    :toolTip:               标准的macOS工具提示材质。(macOS 10.14+)
    :contentBackground:     标准的macOS内容背景材料。(macOS 10.14+)
    :underWindowBackground: 标准的 macOS 窗口下的背景材料。(macOS 10.14+)
    :underPageBackground:   标准的macOS页面下的背景材料。(在macOS 10.14以上版本中被弃用)
    :dark:                  标准的macOS暗色材料。(在macOS 10.14+中被废弃)
    :light:                 标准的macOS光照材料。(macOS 10.14以上版本)
    :mediumLight:           标准的macOS mediumLight材质。(macOS 10.11+, deprecated in macOS 10.14+)
    :ultraDark:             标准的macOS ultraDark材质。(macOS 10.11+, deprecated in macOS 10.14+)

``--macos-title-bar-color=<color>``
    设置标题栏的颜色（默认：完全透明）。受 ``--macos-title-bar-appearance`` 和 ``--macos-title-bar-material`` 的影响。颜色语法见 ``--sub-color``

``--macos-fs-animation-duration=<default|0-1000>``
    设置全屏调整动画的持续时间，单位是ms（默认： default）。默认值略小于系统的动画持续时间（500ms），以防止当一个异步动画的结束与系统全屏动画的结束同时发生时出现一些问题。设置任何高于500ms的时间都只会在系统宽屏动画结束后过早地取消调整大小的动画。上限仍然设置为1000ms，因为苹果或用户有可能改变系统的默认值。不过任何高于1000ms的东西都显得太长了，无论如何都不应该被设置。(仅限macOS和cocoa-cb)


``--macos-app-activation-policy=<regular|accessory|prohibited>``
    改变应用程序的激活策略。有了附件，Dock中的mpv图标可以被隐藏。(默认： regular)

    仅限macOS。

``--macos-geometry-calculation=<visible|whole>``
    这将改变用于计算窗口的屏幕位置和大小的矩形（默认： visible）。 ``visible`` 考虑到菜单栏和Dock，窗口只在可见的屏幕框架矩形内定位/大小， ``whole`` 考虑到整个屏幕框架矩形，忽略了菜单栏和Dock。之前的其他限制仍然适用，比如窗口不能放在菜单栏的上面等等。

    仅限macOS。

``--android-surface-size=<WxH>``
    设置Android gpu上下文使用的渲染表面的尺寸。如果尺寸在运行期间发生变化（例如，如果设备被旋转），需要由嵌入的应用程序通过surfaceChanged回调进行设置。

    安卓系统只有 ``--gpu-context=android``

``--gpu-sw``
    即使检测到软件渲染器也会继续。

``--gpu-context=<sys>``
    值 ``auto`` （默认）选择GPU上下文。你也可以通过 ``help`` 来获得后端编译的完整列表（按自动探针顺序排序）。

    auto
        自动选择(默认)
    cocoa
        Cocoa/macOS（deprecated，使用--vo=libmpv代替）
    win
        Win32/WGL
    winvk
        VK_KHR_win32_surface
    angle
        Direct3D11通过OpenGL ES翻译层ANGLE。这几乎支持 ``win`` 后端所做的一切（如果ANGLE的构建足够新）。
    dxinterop (实验性)
        Win32，使用WGL进行渲染，使用Direct3D 9Ex进行展示。在Nvidia和AMD上工作。较新的英特尔芯片和最新的驱动也可以工作。
    d3d11
        Win32，使用本地Direct3D 11渲染。
    x11
        X11/GLX
    x11vk
        VK_KHR_xlib_surface
    wayland
        Wayland/EGL
    waylandvk
        VK_KHR_wayland_surface
    drm
        DRM/EGL
    displayvk
        VK_KHR_display。这个后端大致相当于DRM/EGL的Vukan，允许通过Vulkan直接渲染而无需显示管理器。
    x11egl
        X11/EGL
    android
        Android/EGL。要求 ``--wid`` 被设置为 ``android.view.Surface``

``--gpu-api=<type>``
    控制哪种类型的图形API将被接受：

    auto
        使用任何可用的API(默认)
    opengl
        只允许OpenGL（需要OpenGL 2.1+或GLES 2.0+）。
    vulkan
        只允许Vulkan（需要一个有效的/工作的 ``--spirv-compiler`` ）。
    d3d11
        只允许 ``--gpu-context=d3d11``

``--opengl-es=<mode>``
    控制哪种类型的OpenGL上下文将被接受。

    auto
        允许所有类型的OpenGL（默认）。
    yes
        只允许GLES
    no
        只允许桌面/核心GL

``--fbo-format=<fmt>``
    选择用于FBO的纹理的内部格式。该格式可以影响视频输出的性能和质量。 ``fmt`` 可以是：rgb8, rgb10, rgb10_a2, rgb16, rgb16f, rgb32f, rgba12, rgba16, rgba16f, rgba16hf, rgba32f之一。

    默认： ``auto`` ，首先尝试使用16位浮点（rgba16f, rgba16hf），如果没有这些浮点，则退回到rgba16。最后，如果前面所有的格式都不可用，则尝试使用rgb10_a2或rgba8。

``--gamma-factor=<0.1..2.0>``
    设置一个额外的原始伽马系数（默认：1.0）。如果用其他方式调整伽玛（比如用 ``--gamma`` 选项或按键绑定和 ``gamma`` 属性），该值将与其他伽玛值相乘。

    基于环境亮度的推荐值：

    1.0
        漆黑或灯光昏暗的房间（默认值）
    1.1
        中等亮度的房间，家庭
    1.2
        明亮的房间，办公室

    注意：这是基于典型电影内容的假设，其中包含了从场景到显示的约0.8的隐含端到端。对于明亮的环境，取消这一点可能是有用的。

``--gamma-auto``
    根据环境照明条件自动修正伽马值（为明亮的房间增加一个伽马增强）。

    在环境照度为16lux的情况下，mpv会选择1.0的伽玛值（没有提升），在256lux的情况下，会稍微增加提升，直到1.2。

    注意：只在macOS上实现。

``--image-lut=<file>``
    指定一个自定义的LUT文件（Adobe .cube格式），在图像解码过程中应用到颜色上。LUT的确切解释取决于 ``--image-lut-type`` 的值。(只适用于 ``--vo=gpu-next`` )

``--image-lut-type=<value>``
    控制送入和送出指定为 ``--image-lut`` 的LUT的颜色值的解释。有效值是：

    auto
        从标记的元数据中自动选择LUT的解释，否则就退回到 ``native`` 。(默认)
    native
        在解码为RGB之前，在其原始色彩空间中应用于原始图像内容。例如，对于HDR10图像，这将是在0.0 - 1.0的范围内输入PQ编码的YCbCr值。
    normalized
        应用于规范化的RGB图像内容，从其原始色彩编码解码后，但在线性化之前。
    conversion
        完全取代了颜色解码。这种类型的LUT应该摄入图像的原生色彩空间，并输出规范化的非线性RGB。

``--target-colorspace-hint``
    如果可能的话，自动配置显示器的输出色彩空间，以通过流的输入值（例如，用于HDR透射）。需要一个支持的驱动程序和 ``--vo=gpu-next``

``--target-prim=<value>``
    指定显示器的基色。当不使用ICC色彩管理时，视频色彩将被调整到这个色彩空间。有效值是：

    auto
        禁用任何适应，除了非典型色彩空间。具体来说，宽/非典型色域会自动适应BT.709，而标准色域（即BT.601和BT.709）的内容不会被触及。(默认)
    bt.470m
        ITU-R BT.470M
    bt.601-525
        ITU-R BT.601（525线标清系统，如NTSC），SMPTE 170M/240M
    bt.601-625
        ITU-R BT.601（625线标清系统，如PAL/SECAM），ITU-R BT.470 B/G
    bt.709
        ITU-R BT.709（高清），IEC 61966-2-4（sRGB），SMPTE RP177附件B
    bt.2020
        ITU-R BT.2020 (UHD)
    apple
        苹果RGB
    adobe
        Adobe RGB (1998)
    prophoto
        ProPhoto RGB (ROMM)
    cie1931
        CIE 1931 RGB (不要与CIE XYZ混淆)
    dci-p3
        DCI-P3（数字影院色彩空间），SMPTE RP431-2
    v-gamut
        松下V-Gamut（VARICAM）底片
    s-gamut
        索尼S-Gamut（S-Log）底片

``--target-trc=<value>``
    指定显示器的传输特性（伽玛）。当不使用ICC色彩管理时，视频色彩将被调整到此曲线。有效值是：

    auto
        禁用任何适应，除了非典型的传输。具体来说，HDR或线性光源材料会自动转换为伽玛2.2，而SDR内容则不被触及。(默认)
    bt.1886
        ITU-R BT.1886曲线（假设对比度为无限）。
    srgb
        IEC 61966-2-4（sRGB）。
    linear
        线性光输出
    gamma1.8
        纯功率曲线（伽玛1.8），也用于苹果RGB
    gamma2.0
        纯功率曲线（伽玛2.0）
    gamma2.2
        纯功率曲线(伽玛2.2)
    gamma2.4
        纯功率曲线(伽玛2.4)
    gamma2.6
        纯功率曲线(伽玛2.6)
    gamma2.8
        纯功率曲线（伽玛2.8），也用于BT.470-BG
    prophoto
        ProPhoto RGB (ROMM)
    pq
        ITU-R BT.2100 PQ（感知量化器）曲线，又称SMPTE ST2084
    hlg
        ITU-R BT.2100 HLG（混合对数伽马）曲线，又名ARIB STD-B67
    v-log
        松下V-Log（VARICAM）曲线
    s-log1
        索尼S-Log1曲线
    s-log2
        索尼S-Log2曲线

    .. note::

        当使用HDR输出格式时，mpv将按照指定的曲线进行编码，但它不会设置任何HDMI标志或其他信号，这些信号可能是目标设备正确显示HDR信号所需的。用户在使用这些信号格式进行显示之前，应该独立保证这一点。

``--target-peak=<auto|nits>``
    指定输出显示器的测量峰值亮度，单位是cd/m^2（又称尼特）。这个亮度的解释取决于配置的 ``--target-trc`` 。在所有情况下，它对将被发送到显示器的信号值施加了一个限制。如果信号源超过了这个亮度水平，将插入一个音调映射滤波器。对于HLG来说，它还有一个额外的作用，就是对逆向OOTF进行参数化，以便获得与母版显示器一致的色度结果。对于SDR，或者当使用ICC（配置文件）（ ``--icc-profile`` ）时，将其设置为高于203的值，基本上会使显示器被视为变相的HDR显示器。(见下面的说明)

    在 ``自动`` 模式下（默认），选择的峰值是基于使用中的TRC的一个适当的值。对于SDR曲线，它使用203。对于HDR曲线，它使用203 * 传递函数的额定峰值。

    .. note::

        当使用SDR传输函数时，通常不需要这样做，而且设置它可能会导致非常意外的结果。它*有用的一次是如果你想用传统的传递函数和校准设备来校准HDR显示器。在这种情况下，你可以将你的HDR显示器设置为高亮度，如800cd/m^2，然后将其校准为一个标准曲线，如gamma2.8。将这个值设置为800，然后指示mpv将其作为一个具有给定峰值的HDR显示器。在不可能向显示器输入PQ或HLG的环境中，这可能是一个很好的选择，并且使mpv有可能使用HDR显示器，而不管操作系统是否支持HDMI HDR元数据。

        在这样的配置中，我们强烈建议将 ``--tone-mapping`` 设置为 ``mobius`` 或甚至 ``clip``

``--target-lut=<file>``
    指定一个自定义的LUT文件（Adobe .cube格式），在屏幕上显示之前应用于颜色。这个LUT是在编码到目标色彩空间后，以归一化的RGB值输入的，所以在应用 ``---target-trc`` 后。(只适用于 ``--vo=gpu-next`` )

``--tone-mapping=<value>``
    指定用于将图像色调映射到目标显示器上的算法。这与HDR->SDR转换和降低色域有关（例如，在标准色域显示器上播放BT.2020内容）。有效值是。

    auto
        根据内部启发式方法选择最佳曲线。(默认)
    clip
        硬性夹住任何超出范围的数值。当你关心范围内值的完美色彩准确性时，使用这个方法，代价是完全扭曲范围外的值。一般不推荐使用。
    mobius
        莱因哈德对莫比乌斯变换的概括，具有线性截面。平滑地映射范围外的值，同时尽可能地保留范围内材料的对比度和颜色。当你关心颜色的准确性而不是细节的保留时，使用这个。这介于 ``clip`` 和 ``reinhard`` 之间，取决于 ``--tone-mapping-param``
    reinhard
        Reinhard色调映射算法。非常简单的连续曲线。保留了图像的整体亮度，但使用了非线性对比度，这导致了细节的扁平化和色彩精度的下降。
    hable
        类似于 ``reinhard`` ，但更好地保留了暗部和亮部的细节（略带sigmoidal），代价是所有东西都略微变暗/变不饱和。由John Hable开发，用于视频游戏中。当你关心细节的保存而不是颜色/亮度的准确性时，就使用这个。这大致相当于 ``--tone-mapping=reinhard --tone-mapping-param=0.24`` 。如果可能的话，你还应该启用 ``--hdr-compute-peak`` ，以获得最佳效果。
    bt.2390
        ITU-R报告BT.2390中规定的感知色调映射曲线（EETF）。
    gamma
        拟合色调曲线之间的对数转移。
    linear
        将整个参考色域线性地拉伸到显示的（线性倍数）。
    spline
        感知上线性的单支点多项式。( ``--vo=gpu-next`` 仅适用)
    bt.2446a
        在ITU-R报告BT.2446中指定的HDR<->SDR映射，方法A。这是推荐的用于精心制作的内容的曲线。( ``--vo=gpu-next`` )

``--tone-mapping-param=<value>``
    设置音调映射参数。默认情况下，它被设置为特殊的字符串 ``default`` ，它映射到一个特定算法的默认值。如果音调映射算法不可调整，则忽略。这影响到下列音调映射算法。

    clip
        指定一个额外的线性系数，在削波前乘以信号。默认为1.0。
    mobius
        指定从线性到莫比乌斯变换的过渡点。低于这个点的每一个值都被保证为1:1的映射。这个值越高，结果就越精确，但代价是失去明亮的细节。默认值是0.3，由于初始斜率很陡，它仍然相当准确地保留了范围内的颜色。
    reinhard
        指定显示峰值处的局部对比度系数。默认值为0.5，这意味着在gamut值中的亮度将是削波时的一半左右。
    gamma
        指定函数的指数。默认为1.8。
    linear
        指定拉伸时使用的比例因子。默认为1.0。
    spline
        指定膝点（在PQ空间）。默认为0.30。

``--inverse-tone-mapping``
    如果设置，允许反色调映射（将SDR扩展到HDR）。不是所有色调映射曲线都支持。请谨慎使用。( ``--vo=gpu-next`` 只支持)

``--tone-mapping-crosstalk=<0.0..0.30>``
    如果不为零，在音调映射前应用一个额外的串扰矩阵。可以帮助改善强饱和的单色高光的外观。(默认值： 0.04, 只影响到 ``--vo=gpu-next`` )

``--tone-mapping-max-boost=<1.0..10.0>``
    允许色调映射算法通过过度曝光提高图像平均亮度的上限。默认值为1.0，不允许额外提高亮度。2.0的值允许过度曝光2倍，以此类推。提高这个设置可以帮助揭示黑暗场景中隐藏的细节，但提高得太高会使黑暗场景显得不自然地明亮。(只有 ``-vo=gpu`` )

``--tone-mapping-mode``
    控制色调映射功能如何应用到颜色上。

    auto
        自动选择最佳模式。(默认)
    rgb
        每个通道的色调映射（RGB）。有严重扭曲颜色的倾向，使高光部分不饱和，一般不大推荐。然而，这是许多显示器和电视（特别是早期的）使用的模式，所以有时需要它来再现电影的艺术意图。
    max
        对视频中最亮的部分进行色调映射。有一种倾向，即导致奇怪的过饱和的颜色，以及黑暗细节的损失。
    hybrid
        一种混合方法，对中间色调使用线性色调映射，对高光使用每通道色调映射。
    luma
        基于亮度的方法，来自ITU-R BT.2446a，包括固定的色域减少，以考虑到与亮度有关的感知不均匀性。( ``--vo=gpu-next`` 仅适用)

``--gamut-mapping-mode``
    指定在完成任何色调映射后，用于降低目标显示器的图像色域的算法。

    auto
        自动选择最佳模式。(默认)
    clip
        硬夹到色域（每个通道）。
    warn
        简单地突出显示超出伽马值的像素。
    desaturate
        将色域外的颜色向白色去饱和。
    darken
        线性地使整个图像变暗，然后剪辑到颜色体积。与 ``clip`` 不同，这不会破坏饱和区域的细节，但代价是有时会大大降低输出亮度。(只有 ``--vo=gpu-next`` )。

``--hdr-compute-peak=<auto|yes|no>``
    每一帧计算HDR峰值和帧平均亮度，而不是依赖标记的元数据。这些值是对局部区域以及几帧的平均值，以防止数值抖动太大。这个选项基本上为你提供了动态的、每个场景的色调映射。需要计算着色器，这是一个相当新的OpenGL特性，而且在某些驱动上可能会表现得很糟糕，所以启用时要自己承担风险。如果支持计算着色器和SSBO，特殊值 ``auto`` （默认）将自动启用HDR峰值计算。

``--allow-delayed-peak-detect``
    当使用 ``--hdr-compute-peak`` 时，如果对性能有利，允许将检测到的峰值延迟一帧。特别是，当不需要高级渲染时，需要这样做以避免不必要的FBO中介。如果已经有一个间接通道，例如启用高级缩放时，则没有影响。默认为开。(只影响到 ``--vo=gpu-next`` ，注意 ``--vo=gpu`` 总是延迟峰值。)

``--hdr-peak-decay-rate=<1.0..1000.0>``
    用于HDR峰值检测算法的衰减率（默认： 100.0）。这只与 ``--hdr-compute-peak`` 启用时有关。更高的值使峰值衰减得更慢，导致更稳定的数值，但代价是更多类似 "眼睛适应 "的效果（尽管这在一定程度上被 ``--hdr-scene-threshold`` 缓解）。1.0的值（可能的最低值）可以禁止所有的平均化，这意味着每一帧的值都直接作为测量值使用，但是对于 "噪声 "源不建议这样做，因为它可能导致过度的闪烁。(在信号理论方面，这控制了IIR低通滤波器的时间常数 "tau")

``--hdr-scene-threshold-low=<0.0..100.0>``, ``--hdr-scene-threshold-high=<0.0..100.0>``
    亮度差异被认为是场景变化的最低和最高阈值（单位：dB）（默认：5.5低，10.0高）。这只有在启用 ``--hdr-compute-peak`` 时才相关。通常情况下，画面亮度的小波动会被峰值平均机制补偿，但对于亮度的大跳动，会导致画面过亮或过暗长达几秒钟，这取决于 ``--hdr-peak-decay-rate`` 的值。为了解决这个问题，当运行中的平均值和当前帧之间的亮度超过低阈值时，mpv将使平均过滤器更加积极，直到高阈值的极限（此时过滤器会变得即时）。

``--use-embedded-icc-profile``
    加载媒体文件（如PNG图像）中的嵌入式ICC配置文件。(默认： yes)。请注意，这个选项只有在同时使用显示ICC配置文件（ ``--icc-profile`` 或 ``--icc-profile-auto`` ）时才有效，而且还需要LittleCMS 2支持。

``--icc-profile=<file>``
    加载一个ICC配置文件，并使用它来转换视频RGB到屏幕输出。需要LittleCMS 2的编译支持。这个选项覆盖了 ``--target-prim``, ``--target-trc`` 和 ``--icc-profile-auto`` 选项。

``--icc-profile-auto``
    自动选择当前由操作系统的显示设置指定的ICC显示配置文件。

    注意：在Windows上，默认配置文件必须是一个ICC配置文件。不支持WCS配置文件。

    使用libmpv和渲染API的应用程序需要通过 ``MPV_RENDER_PARAM_ICC_PROFILE`` 提供ICC配置文件。

``--icc-cache-dir=<dirname>``
    在这个目录中存储和加载从ICC配置文件中创建的3D LUTs。这可以用来加快加载速度，因为LittleCMS 2创建一个3D LUT可能需要一段时间。请注意，这些文件包含了未压缩的LUTs。它们的大小取决于 ``--icc-3dlut-size`` ，而且可能非常大。

    注意：这不是自动清理的，所以旧的、未使用的缓存文件可能会无限期地存在着。

``--icc-intent=<value>``
    指定用于颜色转换的ICC意图（当使用 ``--icc-profile`` 时）。

    0
        感知性
    1
        相对色度(默认)
    2
        饱和度
    3
        绝对比色法

``--icc-3dlut-size=<r>x<g>x<b>``
    从ICC配置文件生成的3D LUT在每个维度的大小。默认是64x64x64。尺寸范围从2到512。

``--icc-force-contrast=<no|0-1000000|inf>``
    用一个特定的值覆盖目标设备的检测对比度。如果可能的话，这是从配置文件中自动检测出来的，但对于某些配置文件来说，它可能会丢失，导致对比度被认为是无限的。因此，视频可能看起来比预期的更暗。如果是这种情况，设置这个选项可能有帮助。这只影响BT.1886内容。默认的 ``no`` 意味着使用配置文件的值。特殊值 ``inf`` 会使BT.1886曲线被当作纯功率伽玛2.4函数处理。

``--lut=<file>``
    指定一个自定义的LUT（Adobe .cube格式），作为颜色转换的一部分应用到颜色上。具体解释取决于 ``--lut-type`` 的值。(只适用于 ``--vo=gpu-next`` )

``--lut-type=<value>``
    控制送入和送出指定为 ``--lut`` 的LUT的颜色值的解释。有效值是：

    auto
        从标记的元数据中自动选择LUT的解释，否则就退回到 ``native`` 。(默认)
    native
        在转换到输出颜色空间之前，应用于原始RGB颜色空间的原始图像内容（非线性光）。
    normalized
        在转换到输出色彩空间之前，应用于线性光线下的标准化RGB图像内容。
    conversion
        完全取代了从图像颜色空间到输出颜色空间的转换。如果有这样的LUT，它具有最高的优先权，并优先于任何ICC配置文件，以及与色调映射和输出测色有关的选项（ ``--target-prim``, ``--target-trc`` 等）。

``--blend-subtitles=<yes|video|no>``
    在插值和/或色彩管理之前，将字幕直接混合到升格的视频帧上（默认： no）。启用这个功能会使字幕受到 ``--icc-profile``, ``--target-prim``, ``--target-trc``, ``--interpolation``, ``--gamma-factor`` 和 ``--glsl-shaders`` 的影响。当使用 ``--interpolation`` 时，它还能提高字幕的性能。

    启用这个功能的缺点是它将字幕限制在视频的可见部分，所以你不能让字幕存在于视频下面的黑边上（例如）。

    如果选择 ``video`` ，行为类似于 ``yes`` ，但字幕是以视频的原始分辨率绘制的，并随着视频的缩放而缩放。

    .. warning:: 这改变了处理字幕颜色的方式。通常情况下，字幕的颜色被假定为sRGB，并按此进行色彩管理。启用这个选项后，它们将被视为在视频的色彩空间中。如果你想让软配音的ASS标志与视频颜色相匹配，这样做很好，但可能会导致SRT字幕或类似的东西看起来有点不对劲。

``--alpha=<blend-tiles|blend|yes|no>``
    决定在输入有阿尔法成分的情况下如何处理。

    blend-tiles
        在16x16的灰色/白色瓷砖背景下混合画面（默认）。
    blend
        将框架与背景颜色（ ``--background`` ，通常是黑色）混合。
    yes
        尝试创建一个有阿尔法成分的帧缓冲区。这只有在视频包含阿尔法信息时才有意义（这极为罕见），或者你让背景颜色透明。可能不是所有平台都支持。如果alpha帧缓冲器不可用，它就会默默地回到正常的帧缓冲器上。注意，如果你把 ``--fbo-format`` 选项设置为非默认值，必须指定一个带alpha的格式，否则这将无法工作。这是否真的有效，取决于窗口系统和桌面环境。
    no
        忽略alpha组件。

``--opengl-rectangle-textures``
    强制使用矩形纹理（默认： no）。通常情况下，这不应该比普通纹理有任何优势。请注意，硬件解码会覆盖这个标志。可以在任何时候删除。

``--background=<color>``
    用来绘制mpv窗口中没有被视频覆盖的部分的颜色。关于如何定义颜色，请看 ``--sub-color`` 选项。

``--gpu-tex-pad-x``, ``--gpu-tex-pad-y``
    将视频源的纹理放大这么多像素。仅用于调试（通常纹理的大小是准确的，但由于硬件解码的互操作，我们可能需要处理额外的填充，这可以用这些选项来测试）。可以在任何时候被删除。

``--opengl-early-flush=<yes|no|auto>``
    在渲染完一帧后，在试图显示之前调用 ``glFlush()`` （默认： auto）。在某些情况下可以解决卡顿问题，在其他情况下可能会导致卡顿。 ``auto`` 模式只有在渲染器在渲染后要等待一段时间时才会调用 ``glFlush()`` ，而不是立即翻转GL前后缓冲区（也就是说，在显示同步模式下不会调用）。

    在macOS上，这个功能总是被停用，因为它只会导致性能问题和其他倒退。

``--gpu-dumb-mode=<yes|no|auto>``
    这种模式是非常受限制的，并将禁用大多数扩展功能。这包括高质量的缩放器和自定义着色器!

    它是为不支持FBOs的硬件（包括GLES，它对FBOs的支持不够），或者从坏的或旧的硬件中获得更多的性能。

    如果需要的话，这个模式会自动强制执行，这个选项在调试时非常有用。如果没有使用需要FBO的功能，默认的 ``auto`` 会自动启用它。

    这个选项在未来可能会被悄悄地删除。

``--gpu-shader-cache-dir=<dirname>``
    在这个目录中存储和加载已编译的GLSL着色器。通常情况下，着色器的编译速度非常快，所以通常不需要这样做。对于需要在内部重新编译着色器到其他语言的GPU API来说，这一点非常重要，例如任何基于ANGLE或Vulkan的语言。启用它可以提高这些平台的启动性能。

    注意：这不是自动清理的，所以旧的、未使用的缓存文件可能会无限期地存在。

Miscellaneous
-------------

``--display-tags=tag1,tags2,...``
    设置应在终端上显示的标签列表。列表中的标签，但在播放的文件中不存在，将不会被显示。如果一个值以 ``*`` 结尾，所有的标签都按前缀匹配（尽管没有一般的globbing）。仅仅通过 ``*`` 本质上是过滤。

    默认包括一个通用的标签列表，用 ``--list-options`` 调用mpv来查看它。

    这是一个字符串列表选项。详见 `List Options`_

``--mc=<seconds/frame>``
    每一帧的最大A-V同步校正(以秒为单位)

``--autosync=<factor>``
    根据音频延迟测量结果逐步调整A/V同步。指定 ``--autosync=0`` ，默认情况下，将导致帧计时完全基于音频延迟测量。指定 ``--autosync=1`` 将做同样的事情，但会巧妙地改变A/V校正算法。如果在 ``--no-audio`` 的情况下视频帧数不均匀，通常可以通过将其设置为大于1的整数来解决。The higher the value, the closer the timing will be to ``--no-audio``. 试试 ``--autosync=30`` ，以平滑那些没有实现完美音频延迟测量的声音驱动的问题。有了这个值，如果发生大的A/V同步偏移，它们只需要1或2秒就可以解决了。这种对突然的A/V偏移的反应时间的延迟应该是打开这个选项的唯一副作用，对所有的声音驱动都是如此。

``--video-timing-offset=<seconds>``
    控制在视频显示目标时间之前多久应该渲染该帧（默认： 0.050）。如果一个视频帧应该在某个时间显示，VO将提前开始渲染该帧，然后将执行一个阻塞等待，直到显示时间，然后才 "交换 "该帧进行显示。渲染不能在前一帧显示之前开始，所以这个值隐含地受到视频帧率的限制。在正常的视频帧率下，默认值将确保渲染总是在前一帧显示完后立即开始。另一方面，设置一个太高的值会降低低FPS值的响应速度。

    这个选项对于使用渲染API的客户端用户来说很有意思，因为你可以阻止它限制你的FPS（见 ``mpv_render_context_render()`` 文档）。

    这只适用于音频计时模式（例如 ``--video-sync=audio`` ）。在其他模式下( ``--video-sync=display-...`` )，视频计时依赖于vsync阻塞，此选项不使用。

``--video-sync=<audio|...>``
    播放器如何使音频和视频同步。

    如果你使用这个选项，你通常想把它设置为 ``display-resample`` ，以启用一种计时模式，例如在24Hz的屏幕上播放24fps的视频时尽量不跳帧或重复。

    以 ``display-`` 开头的模式试图完全同步输出视频帧到显示器上，使用检测到的显示器垂直刷新率作为提示，显示帧的平均速度。这些模式会稍微改变视频速度以配合显示器。参见 ``--video-sync-...`` 选项进行微调。这种模式的稳健性因做了一些理想化的假设而进一步降低，这些假设在现实中可能并不总是适用。行为可能取决于VO和系统的视频和音频驱动。媒体文件必须使用恒定的帧速率。节段式的VFR可能对某些容器格式也有效（但不是如mkv）。

    在某些情况下，播放器会在一段时间内自动恢复到 ``audio`` 模式或永久地恢复。这可能发生在帧率很低的视频上，或者帧率无法被检测到。

    同样在显示同步模式下，视频播放的中断（比如切换全屏模式，或者简单地调整窗口大小）会跳过本应显示的视频帧，而 ``audio`` 模式会在渲染器恢复后显示它们（通常会导致短暂的A/V解同步和视频 "追赶"）。

    在mpv0.30.0之前，在严重的A/V解同步时有一个回退到 ``audio`` 模式。这一点被改变了，因为它不会零星地停止。现在， ``display-desync`` 做了它所承诺的事情，并可能以任意的数量与音频不同步，直到它被手动修复。

    这些模式也需要一个vsync封锁的演示模式。对于OpenGL来说，这相当于 ``--opengl-swapinterval=1`` 。对于Vulkan，它被翻译成 ``--vulkan-swap-mode=fifo`` （或 ``fifo-relaxed`` ）。

    名称中带有 ``desync`` 的模式并不试图保持音频/视频的同步。它们会缓慢（或快速）地取消同步，直到例如下一次寻道发生。这些模式是用来测试的，不是用来认真使用的。

    :audio:             为视频帧和音频计时。这是最稳健的模式，因为播放器不需要对显示器的行为进行任何假设。缺点是它可能会导致偶尔的丢帧或重复。如果音频被禁用，这将使用系统时钟。这是默认模式。
    :display-resample:  对音频重新取样以匹配视频。这种模式也将尝试调整音频速度以补偿其他漂移。(这意味着它将每隔一段时间以不同的速度播放音频，以减少A/V差异）。
    :display-resample-vdrop:  重新取样音频以匹配视频。删除视频帧以补偿漂移。
    :display-resample-desync: 与之前的模式一样，但没有A/V补偿。
    :display-vdrop。    删除或重复视频帧，以补偿视频的不同步。(虽然它应该有与``音频``相同的效果，但实施起来却非常不同)。
    :display-adrop:     删除或重复音频数据以补偿视频的不同步。如果真实的显示器刷新率与报告的或强制的刷新率相差太大，这种模式将导致严重的音频伪影。从mpv 0.33.0开始，这个模式作用于整个音频帧，而不是单个样本。
    :display-desync:    将视频与显示器同步，并让音频自行播放。
    :desync:            根据系统时钟同步视频，并让音频自行播放。

``--video-sync-max-factor=<value>``
    尝试将视频的FPS与显示器的FPS相适应的最大倍数（默认： 5）。

    例如，如果设置为1，只要速度变化不超过 ``--video-sync-max-video-change`` 设置的值，视频的FPS就会被强制为显示器FPS的整数倍。

    关于该选项如何影响插值，请参见 ``--interpolation-threshold``

    这主要是为了测试，该选项将来可能会随机改变而不另行通知。

``--video-sync-max-video-change=<value>``
    应用于 ``--video-sync=display-...`` 的视频的最大速度差（百分比）（默认： 1）。如果显示器和视频刷新方式在给定范围内不匹配，显示同步模式将被禁用。它也会尝试倍数：在60赫兹的屏幕上播放30帧的视频，每隔一帧就会重复一次。在60赫兹的屏幕上播放24帧的视频将以2-3-2-3-...的模式播放视频。

    默认设置不够宽松，无法将23.976帧的视频加速到25帧。我们认为音高变化过于极端，默认情况下不允许这种行为。将这个选项设置为 ``5`` 的值来启用它。

    注意，在 ``--video-sync=display-resample`` 模式下，如果需要A/V同步，音频速度将额外改变一小部分。参见 ``--video-sync-max-audio-change``

``--video-sync-max-audio-change=<value>``
    在 ``--video-sync=display-...`` 的情况下，应用于音频的最大*附加速度差（百分比）（默认： 0.125）。通常情况下，播放器会以视频的速度播放音频。但如果音频和视频的位置差异太大，例如，由于漂移或其他时间错误，它将试图通过这个额外的因素来加快或减慢音频的速度。太低的值可能会导致视频丢帧或重复，如果A/V解同步不能得到补偿，太高的值可能会导致混乱的丢帧，因为音频 "过冲"，在同步逻辑能反应之前跳过多个视频帧。

``--mf-fps=<value>``
    当用 ``mf://`` 从多个PNG或JPEG文件解码时使用的帧速率（默认： 1）。

``--mf-type=<value>``
    ``mf://`` 的输入文件类型（可用：jpeg, png, tga, sgi）。默认情况下，这是从文件扩展名猜测出来的。

``--stream-dump=<destination-filename>``
    不播放一个文件，而是读取它的字节流并将其写入给定的目标文件。目标文件被覆盖。对测试网络相关的行为可能很有用。

``--stream-lavf-o=opt1=value1,opt2=value2,...``
    在用libavformat打开的流上设置AVOptions。未知或拼写错误的选项会被默默地忽略。(它们会在终端输出的粗略模式下被提及，即 ``--v`` 。一般来说，我们不能打印错误，因为其他的选项，例如用户代理，并不是所有的协议都可以使用的，而打印未知选项的错误最终会显得过于嘈杂）。

    这是一个按键/值列表选项。详见 `List Options`_

``--vo-mmcss-profile=<name>``
    (仅适用于Windows。) 为视频渲染器线程设置MMCSS配置文件(默认： ``Playback`` )。

``--priority=<prio>``
    (仅适用于Windows。)根据Windows下的预定义优先级，为mpv设置进程优先级。

    ``<prio>`` 的可能值： idle|belownormal|normal|abovenormal|high|realtime

    .. warning:: 使用实时优先级会导致系统锁死。

``--force-media-title=<string>``
    强制将 ``media-title`` 属性的内容变成这个值。对于想要设置标题的脚本很有用，而不需要推翻用户在 ``--title`` 中的设置。

``--external-files=<file-list>``
    加载一个文件并添加其所有的音轨。这对一起播放不同的文件很有用（例如一个文件的音频，另一个文件的视频），或用于高级的 ``--lavfi-complex`` （如同时播放两个视频文件）。

    与 ``--sub-files`` 和 ``--audio-files`` 不同，它包括所有音轨，不会导致默认流选择在 "适当 "文件上。这使得它的干扰性略微降低。(在mpv0.28.0及以前，这一点并没有严格执行。)

    这是一个路径列表选项。详见 `List Options`_

``--external-file=<file>``
    CLI/配置文件只是 ``--external-files-append`` 的别名。每次使用该选项将添加一个新的外部文件。

``--cover-art-files=<file-list>``
    在播放音频时使用一个外部文件作为封面艺术。这使得它出现在轨道列表上，并受制于自动轨道选择。像 ``--audio-display`` 这样的选项控制是否应该选择这样的曲目。

    (与用 ``--external-files`` 加载文件的区别是，视频轨道将被标记为图片，这影响了自动选择的方法。如果传递的文件是视频，只有第一帧会被解码和显示。如果源文件是视频，在播放过程中启用封面艺术轨道可能会显示一个随机帧。通常情况下，你不应该把视频传给这个选项，所以这一段描述的是实现细节中巧合产生的行为)。

    这是一个路径列表选项。详见 `List Options`_

``--cover-art-file=<file>``
    CLI/配置文件只是 ``--cover-art-files-append`` 的别名。每次使用该选项将添加一个新的外部文件。

``--cover-art-auto=<no|exact|fuzzy|all>``
    是否自动加载_外部的封面设计。类似于 ``--sub-auto`` 和 ``--audio-file-auto`` 。如果一个视频已经有轨道（没有标记为封面），外部封面将不会被加载。

    :no:    不要自动加载封面艺术。
    :exact: 加载带有图像文件扩展名的媒体文件。
    :fuzzy: 载入所有包含媒体文件名和内部白名单中的文件名的封面艺术，如 ``cover.jpg`` （默认）。
    :all:   加载当前目录下的所有图片。

    参见 ``--cover-art-files`` ，了解构成封面艺术的细节。

    参见 ``--audio-display`` 如何控制封面艺术的显示（这可以用来禁用属于文件的封面艺术）。

``--autoload-files=<yes|no>``
    自动加载/选择外部文件（默认： yes）。

    如果设置为 ``no`` ，则不自动加载由 ``--sub-auto`` , ``--audio-file-auto`` 和 ``--cover-art-auto`` 指定的外部文件。如果外部文件被强行添加（如`--子文件'），它们将不会被自动选择。

    这不影响播放列表的扩展、重定向或其他参考文件的加载，如有序章节。

``--record-file=<file>``
    已deprecated，使用 ``--stream-record`` ，或 ``dump-cache`` 命令。

    记录当前流到给定的目标文件。目标文件将总是被覆盖而不需要询问。

    这deprecated，因为它不是很好用。首先，在启用这个功能时，寻道会直接反映在输出中，这并不有用，而且很烦人。

``--stream-record=<file>``
    将从解复用器接收/读取的数据写入给定的输出文件。输出文件将总是被覆盖而不问。输出格式由输出文件的扩展名决定。

    在录制过程中切换数据流或寻找可能会导致录制被停止和/或文件被破坏。请小心使用。

    在解复用器缓存之外寻找会导致输出文件的 "跳过"，但在解复用器缓存内寻找应该不会影响录制。一个例外是，当你向后寻找到足够远的距离，超过了前向缓冲区的大小，在这种情况下，缓冲区停止主动读取。如果是实时流，这将导致数据丢失。

    如果这是在运行时设置的，旧文件被关闭，而新文件被打开。注意，这将只写在缓存末尾附加的数据，已经缓存的数据不能被写入。你可以尝试使用 ``dump-cache`` 命令作为替代。

    外部文件（ ``--audio-file`` 等）会被忽略，它只对 "主 "文件起作用。对使用有序章节的文件或EDL文件使用这个命令，一般来说也不能正确工作。

    因为它使用FFmpeg的libavformat来编写输出文件，所以会有一些小问题。例如，典型的情况是，只有当输出格式与输入格式相同时，它才能工作。即使使用 ``ffmpeg`` 工具也是这种情况。其中一个原因是 ``ffmpeg`` 和它的库包含了某些针对这些问题的黑客和变通方法，外部用户无法使用。

    这取代了 ``--record-file`` 。它类似于古老的/被删除的 ``--stream-capture``/``-capture`` 选项，并在大多数情况下提供更好的行为（即实际工作）。

``--lavfi-complex=<string>``
    设置一个 "复杂的 "libavfilter过滤器，这意味着一个过滤器图可以接受来自多个音视频源轨道的输入。该图可以产生一个单一的音频或视频输出（或两者）。

    目前，过滤图的标签被用来选择参与的输入轨道和音频/视频输出。以下规则适用。

    - ``aidN`` 形式的标签选择音频轨道N作为输入（例如 ``aid1`` ）。
    - ``vidN`` 形式的标签选择视频轨道N作为输入。
    - 一个名为 ``ao`` 的标签将被连接到音频输出。
    - 一个名为 ``vo`` 的标签将被连接到视频输出。

    每个标签只能使用一次。如果你想把例如一个音频流用于多个过滤器，你需要使用 ``asplit`` 过滤器。多个视频或音频输出是不可能的，但你可以使用过滤器将它们合并成一个。

    在运行时不可能改变连接到过滤器的轨道，除非你明确改变 ``lavfi-complex`` 属性并设置新的轨道分配。当图形被改变时，轨道的选择也会根据使用的标签而改变。

    其他轨道，只要它们没有连接到过滤器，相应的输出也没有连接到过滤器，仍然可以用正常的方法自由改变。

    请注意，正常的过滤器链（ ``--af`` , ``--vf`` ）是应用在复杂图形（如 ``ao`` 标签）和实际输出之间。

    .. admonition:: 示例

        - ``--lavfi-complex='[aid1] [aid2] amix [ao]'`` 同时播放音轨1和2。
        - ``--lavfi-complex='[vid1] [vid2] vstack [vo]'`` 堆叠视频轨道1和2并同时播放它们。注意，两个轨道需要有相同的宽度，否则过滤器初始化会失败（你可以在 ``vstack`` 过滤器之前添加 ``scale`` 过滤器来固定尺寸）。要从其他文件加载视频轨道，你可以使用 ``--external-file=other.mkv``
        - ``--lavfi-complex='[aid1] asplit [t1] [ao] ; [t1] showvolume [t2] ; [vid1] [t2] overlay [vo]'`` 播放音轨1，并将每个扬声器的测量音量覆盖在视频轨1上。
        - ``null:// --lavfi-complex='life [vo]'``一个libavfilter的纯源滤波器（Conways的生命游戏）。

    有关可用过滤器的细节，请参见FFmpeg libavfilter文档。

``--metadata-codepage=<codepage>``
    各种输入元数据的编码页（默认： ``utf-8`` ）。这将影响到文件标签、章节标题等的解释方式。例如，你可以把它设置为 ``auto`` ，以启用编码页的自动检测。(这不是默认的，因为非UTF-8编码页是一种不明显的边缘使用情况)。

    参见 ``--sub-codepage`` 选项，关于如何指定编码页以及关于自动检测和编码页转换的进一步细节。(底层代码是相同的）。

    转换不应用于在运行时更新的元数据。


Debugging
---------

``--unittest=<name>``
    运行一个内部单元测试。有多个，名称指定哪个。

    特殊值 ``all-simple`` 运行所有不需要进一步设置的测试（其他参数之类的）。一些测试可能需要额外的参数来做一些有用的事情。

    成功时，播放器二进制文件以退出状态0退出，否则以未定义的非0退出状态返回（测试失败时可能崩溃或中止）。

    只有在使用 ``--enable-tests`` 构建的情况下才会启用，通常只应由开发人员启用和使用。
