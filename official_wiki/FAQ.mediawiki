== mpv有官方的图形用户界面吗？ ==

没有。但是有OSC(on-screen-controller)，它可以让你用鼠标控制播放。要求mpv在编译时支持Lua。

有一些[https://github.com/mpv-player/mpv/wiki/Applications-using-mpv#gui-frontends 第三方GUI前端在这里被列出]。

== 撕裂 ==

[https://en.wikipedia.org/wiki/Screen_tearing 撕裂] 是一个非常恼人的瑕疵，它使视频看起来像有一条横跨视频的水平线。视频没有正确地连接在那条线上。这条线可以是固定的，也可以是移动的。有时它不是一条线，而是一堆块。如果没有运动，它可能是不可察觉的，但如果摄像机移动，例如低速移动，则非常明显。

撕裂通常不是视频播放器可以做的事情。这取决于硬件、驱动程序、mpv（VO）中选择的视频输出，可能还有桌面环境/合成器。

改变合成器的设置有时可以帮助解决撕裂问题。

=== MacOS (OSX) ===

没见过它撕裂。

=== Windows ===

Windows现在默认使用本地的d3d11后端。如果你遇到问题，请尝试使用任何 <code>--d3d11-...</code> 选项。 https://mpv.io/manual/master/#options-d3d11-exclusive-fs 。

使用 <code>--d3d11-adapter=help</code> 来查看你系统中所有GPU的描述名称。 
<pre>示例;
可用的D3D11 adapters:
描述：Intel(R) HD Graphics 630
描述：NVIDIA GeForce GTX 1080 Ti
描述：AMD Radeon RX 5700 XT
描述：Radeon (TM) RX 470 Graphics
描述：Microsoft Basic Render Driver
</pre>
当你使用英特尔的i-GPU处理器时，Windows总是使用IntelHD作为默认，你可以尝试切换到另一个GPU来利用D3D11渲染， <code>--vo=gpu</code>, <code>--gpu-api=d3d11</code>, <code>--angle-renderer=auto</code>, <code>--d3d11-adapter=...</code>, <code>--d3d11-sync-interval=1</code> 。例如； <code>--d3d11-adapter=Radeon (TM) RX 470 Graphics</code> 。

你可以尝试用 <code>--gpu-context=...</code> 强制其他后端。 <code>dxinterop</code> 似乎通常表现最好（可能已经过时），但它会在一些老的有问题的英特尔驱动程序中随机崩溃。被废弃的 <code>--vo=direct3d</code> 应该大致表现得像 <code>--angle-renderer=d3d9</code> ，但由于使用固定功能的传统API，可能会更快（但不支持没有拷贝回的硬件解码）。 https://mpv.io/manual/master/#options-angle-d3d11-feature-level

=== X11/Nvidia ===

Nvidia一般不应该撕裂。有时，它在窗口模式下会撕裂，但在全屏模式下不会撕裂（解决方案未知）。在多显示器系统中还有其他问题。

<ul>
<li>尝试启用<code>ForceFullCompositionPipeline</code>。</li>
<li>尝试使用和不使用合成器。</li>
<li><p>尝试在xorg.conf中禁用复合扩展：</p>
<pre>Section "Extensions"
    Option "Composite" "Disable"
EndSection</pre></li>
<li>将性能模式设置为最高性能。节能往往会干扰vo_opengl的正常运行，有时甚至会出现撕裂现象。
<li><p>尝试<code>--vo=vdpau</code>。</p></li>
<li><p>为了解决KDE下的撕裂问题，创建文件<code>/etc/profile.d/kwin.sh</code>，内容是：</p>
<pre>export __GL_SYNC_TO_VBLANK=1
export __GL_YIELD=USLEEP</pre></li>
</ul>

=== X11/Nvidia with PRIME ===

如果你的Xorg服务器比ABI版本23老，或者你的内核比4.5版本老，或者你的Nvidia驱动不是最新的，那么由于缺乏[https://devtalk.nvidia.com/default/topic/957814/linux/prime-and-prime-synchronization/1 PRIME缓冲区同步]，你将不可避免地出现撕裂现象。你不能用本页描述的任何其他方法来解决这种撕裂现象。你可以采取胎儿姿势哭泣，或者转而使用你的英特尔GPU。

=== X11/Intel ===

英特尔在开箱时就出现了撕裂。<b>然而，在大多数情况下，使用gpu vo（默认）的撕裂可以通过启用合成器来解决。</b>如果这不适用于你，请尝试以下选项。

<ul>
<li><p>尝试启用SNA和<code>TearFree</code>选项。</p>
不幸的是，这可能导致稳定性问题--GL应用程序有时会随机崩溃。在某个地方，有人声称在你的内核参数中添加<code>i915.semaphores=1</code>可以修复崩溃。</li>
<li>尝试通过使用 UXA 来禁用 SNA（在旧硬件上）。</li>
<li>尝试<code>--x11-bypass-compositor=no</code></li>
<li>尝试<code>--vo=xv --xv-adaptor=N</code>，并尝试0或1的<code>N</code>。如果其他方法失败，这可能会解决撕裂问题，但请记住，强烈不建议将 Xv 与 mpv 一起使用。</li>
<li><p>尝试<code>--vo=vaapi</code>。尽管这是英特尔的原生视频输出方法，但它似乎只在极少数情况下解决了撕裂问题。但请记住，<code>vaapi</code> vo并不提供<code>gpu</code> vo所能提供的高质量的渲染</p></li>
<li><p>尝试<code>--vo=sdl</code>。这可能会使用您的2D加速，这意味着如果您在使用任何非<code>gpu</code> VO时遇到撕裂，这将无法修复撕裂。与<code>vo=vaapi</code>一样，它没有提供<code>gpu</code>所提供的功能。</p></li>

<li>如果你使用 Xorg 的新 "modesetting" 驱动程序，并且没有使用 [https://en.wikipedia.org/wiki/Compositing_window_manager compositing window manager] （例如，你使用 Awesome 这样的普通窗口管理器，而没有使用 Gnome 或 KDE 这样的桌面管理器），你可能需要在视频播放期间运行一个 compositor。[https://github.com/chjj/compton Compton] 如果用它的<em>glx</em>后端启动，可能会解决这个问题。
<ol>
<li>从软件包管理器中安装Compton或从源代码中编译</li>
<li> 在终端中启动Compton，如下所示。<code>compton --backend=glx</code></li>
<li> 启动 mpv </li>
</ol>
[https://whirm.eu/posts/fix-for-xorgs-modesetting-driver-tearing/ 这个帖子（死链接）]更详细地解释了这个程序。
</li>
</ul>

=== X11/AMD ===

<ul>
<li> 官方驱动程序(AMDGPU-PRO/fglrx)已经完全坏了，所以要完全避免它们。</li>
<li> 使用amdgpu，你需要启用TearFree选项（通过<code>xrandr --set TearFree on</code>或通过xorg.conf），以防止在非全屏状态下出现撕裂，除非你使用合成器。</li>
<li> 如果你在使用 vulkan 时在全屏模式下仍有撕裂现象，请在你的 <code>xorg.conf</code> 的 <code>Device</code> 部分添加 <code>option "EnablePageFlip" "off" </code>。</li>
<li> 不相关，但如果你有性能问题，试试<code>echo high > /sys/class/drm/card0/device/power_dpm_force_performance_level</code>.</li>
</ul>

==推荐的GPU硬件 ==

由于mpv通常用着色器而不是固定功能的视频硬件来渲染视频（它这样做是为了质量和一致性），GPU硬件及其驱动的质量对mpv的良好运行非常重要。

我们只是描写了Linux上的情况。作者并不了解Windows上的情况。苹果公司在图形领域是完全无能和邪恶的，请不要购买他们的产品。最值得注意的是，mpv在macOS上仍然使用可移植的API，苹果已经宣布废弃这些API，而这些API的更新似乎只是为了不断毁掉性能。

=== amdgpu (开源版驱动) ===

这些似乎工作得很好。有一些一致的问题，但也有希望。他们的独立GPU通常足够强大，甚至可以在高分辨率和帧率下处理高级渲染设置。较新的型号（Vega及以后的型号）似乎会引起更多问题。在各种内核版本中出现了一些稳定性问题，因为他们将糟糕的Windows代码移植到了Linux内核中（FPU使用和不恰当的上下文管理）。

=== amdgpu-pro (闭源版驱动) ===

未知。可能工作得很好，但在理论上可能引起额外的问题。由于开源的amdgpu驱动工作得很好（据说在某些情况下比amdgpu-pro更好），可能它们只是提供了一个额外的问题来源。

在任何情况下，你都可以切换到amdgpu驱动而不损失什么。

=== Intel ===

他们的硬件相对较弱，而且他们的驱动程序很混乱。如果你设法选择正确的驱动版本，事情可能会在中等设置下运行得非常好。然而，他们经常出现问题（其中一些问题似乎从未被修复），而且众所周知，驱动发布版本有git中不存在的错误。另外，他们总是启动新的驱动，而不是改进现有的驱动，这将使你作为一个英特尔用户的生活充满压力。

不推荐使用。然而，如果你的电脑是笔记本电脑，你可能应该选择纯英特尔而不是混合图形，至少在这个时候。

=== Nvidia ===

不，他们的硬件可能相当不错，但他们的驱动程序却有问题。它们是闭源的，而且在安装时往往会取代系统库。此外，他们往往落后于开源的API（例如，在他们的GL实现中仍然没有任何演示反馈）。Nvidia的驱动程序似乎也经常引起系统稳定性问题。有一些奇怪的怪癖，比如在初始化时有巨大的用户可察觉的超时，这根本就不应该存在。

虽然Nvidia过去曾被推荐过（至少是作者推荐的），但它一直在变得更糟。

=== 手机 ===

你为什么要买一个被设计用来监视你的设备，目的是让大企业更富有？这有点愚蠢，你知道。

总之，所有的移动GPU都很糟糕，无论是硬件实现、驱动程序，还是移动设备的功能都不是很强大，除非你对它们在几分钟内耗尽你的电池感到满意。如果你使用其固定功能的视频解码和渲染管道，移动GPU可以相当高效，但mpv并没有试图这样做。

=== ARM/Linux ===

有许多 "嵌入式 "或 "微型计算机 "板块采用强大的ARM芯片。消费者通常在上面运行Linux。它们在各方面都是垃圾。大致上和移动设备一样差，甚至更差。

虽然mpv对RPI和Rockchip设备有一些支持，但对你来说可能好用也可能不好用。

== 我在Windows上使用NVIDIA G-Sync，在全屏模式下运行mpv会降低其他显示器的帧率 ==

这可能是由G-Sync与Windows的合成器的交互方式造成的。使用 <code>--opengl-backend=win</code> 应该可以解决这个问题，因为mpv通过这种方式获得一个独占的全屏窗口。合成器不会重定向独占的全屏窗口，也不会被迫以其帧率运行。

== 我看不到OSC/OSD/GUI! ==

OSC需要Lua支持。安装Lua 5.1、5.2或LuaJIT中的任何一个，包括开发头文件，然后重建mpv。mpv不支持也不可能支持Lua 5.3或更新的版本。
如果你没有自己构建mpv，请要求打包者启用Lua。

另外，请注意，OSC在默认情况下是不可见的，但一旦你把鼠标移到mpv窗口上，它就会出现。

== 当mpv播放音频文件时，我看不到窗口。 ==

使用 <code>--force-window</code>

== 帮助mpv在播放时不关闭屏幕保护程序 ==

显然，一些屏幕保护程序不使用标准的API，需要在所有需要抑制屏幕保护程序的软件中使用奇怪的机制。我猜他们的想法是，"有一种非常流行的抑制屏幕保护程序的方法，我们与之互通有无，所以让我们不遗余力地去阻止它。" 在我听来，这些人不像是你应该信任你电脑上的软件的人。

例如，见 https://www.jwz.org/xscreensaver/faq.html#dvd

除了笑话(?)，如果你需要运行xscreensaver-command（用于XScreenSaver）或xdg-screensaver（用于GNOME?），你可以写一个Lua脚本来做。也可参见： https://mpv.io/manual/master/#disabling-screensaver

== 我使用GNOME Wayland，我有x/y/z问题！ ==

在过去，mutter的wayland合成器有几个严重的问题，但现在这些问题基本上已经被修复了，mpv播放效果很好。不过，仍然有一些小问题。

<ul>
<li>GNOME wayland 不支持 [https://gitlab.gnome.org/GNOME/mutter/issues/20 zwp idle inhibit manager protocol] 。这意味着在视频播放过程中会出现屏幕空白，这取决于用户的设置。有一个[https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/111 合并请求]正在进行中，以增加这一点。一个解决方法是使用 launch mpv 与 gnome 特定的 <code>gnome-session-inhibit</code> 命令。
<li>GNOME wayland 没有服务器端的装饰，因为他们故意不支持 [https://gitlab.gnome.org/GNOME/mutter/issues/217 xdg-decoration protocol]。mpv 确实有伪客户端的装饰（通过 osc），如果它被编译为 lua 支持，如果检测到合成器不支持 xdg-decoration，它会自动激活。本文档的作者个人更喜欢服务器端的装饰，但就功能而言，并没有什么严重的损失。
</ul>

== NVIDIA and Wayland ==

自从NVIDIA 495.29.05测试版发布后，NVIDIA现在支持GBM以及VK_KHR_wayland_surface。理论上，如果你的驱动足够新，Wayland上的mpv现在可以在NVIDIA上工作。在这个阶段，没有任何mpv开发者尝试过它，所以没有人可以说它的工作效果如何。就一般的桌面体验而言，我们已经看到有报告称Sway可以正常工作，但GNOME和KDE都有硬编码的驱动程序检测<sup>1</sup>，这意味着尽管有新的GBM支持，它们仍将使用EGLStreams。在这一点改变之前，你不会看到Wayland在这些桌面环境中的体验有任何改善。具体到mpv，可以通过 `--opengl-es=yes` 选项来制作GLES，虽然Vulkan被声称从470.63.01开始的新驱动支持，但这还没有得到独立验证。无论如何，在测试时不要试图使用任何特定合成器的EGLStreams后端。

1. 在Mutter的主分支和KWin 5.23.2以上版本中，硬编码的EGLStreams检测已被放弃。
<ul>
<li>https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2052
<li>https://invent.kde.org/plasma/kwin/-/merge_requests/1526#note_325139
</ul>

== 我应该使用X11还是Wayland？ ==

mpv将支持X11和Wayland，直到文明的尽头（好吧，也许在那之前会有一个新的窗口系统）。只要你有可用的驱动/硬件（即不是[https://github.com/mpv-player/mpv/wiki/FAQ#NVIDIA_and_Wayland NVIDIA]），并且没有使用一些坏的窗口管理器/合成器，X11和Wayland后端应该表现得同样好。任何一个比另一个的优势都与窗口系统本身有关。你可以选择你更喜欢的那个实现。

mpv尽力做到独立于特定的桌面环境和合成器，所以我们只支持上游的wayland-protocols，而不支持其他特定的桌面库或特定的合成器协议。某些wayland合成器只支持特定的wayland协议，所以它们可能不具备mpv wayland后端支持的所有功能。下面是一个快速列表，列出了mpv使用的一些著名的协议，以及哪些合成器支持什么。

<ul>
<li>[https://gitlab.freedesktop.org/wayland/wayland-protocols/tree/master/unstable/xdg-decoration xdg-decoration] (用于服务器端的装饰）。Plasma和Sway/wlroots
<li>[https://gitlab.freedesktop.org/wayland/wayland-protocols/tree/master/unstable/idle-inhibit idle-inhibit] (用于防止屏幕空白）。Plasma 和 Sway/wlroots
<li>[https://gitlab.freedesktop.org/wayland/wayland-protocols/tree/master/stable/presentation-time presentation-time] （用于演示反馈）。GNOME/Mutter, Sway/wlroots, 和 Weston
</ul>

== opengl-hq、gpu-hq等的区别是什么？ ==

使用基于GPU着色器的渲染的VO（视频输出）被重新命名并更新过几次。目前，以下事情是成立的。

* <code>--vo=gpu</code> 基本上是默认的（取代了<code>--vo=opengl</code>)
* <code>--profile=gpu-hq</code>是用来选择一个预设的高级缩放等（取代<code>--vo=opengl-hq</code>和<code>-profile=opengl-hq</code>)
* GPU支持多个后端，如 "d3d..."、opengl、vulkan（它们默认按照这个顺序使用）；使用<code>--gpu-api=vulkan</code>来强制使用例如vulkan，使用<code>--gpu-context=...</code>来选择特定后端。

== 硬件解码不工作 ==

* 使用<code>--hwdec=auto</code>或<code>--hwdec=auto-safe</code>或<code>--hwdec=auto-copy</code>或<code>--hwdec=auto-copy-safe</code>而不是其他东西
* 确保所有的hwdec后端都被编译进去了。
* 确保你正在播放的文件可以被硬件解码（例如，10位h264视频就不是这种情况）。
* 有些编解码器需要明确地用<code>--hwdec-codecs=...</code>来启用。

== 我正在使用vo=vaapi或vo=vdpau，但有问题 ==

首先。不要使用这些VO。它们是坏的和旧的。没有理由使用它们。只要不覆盖VO的选择，使用默认的就行了。一些用户似乎认为使用这些VO是硬件解码的需要。这是不正确的。如果你想要硬件解码，请使用 --hwdec=auto ，它可能会使用其中一些API进行解码。(在旧的Nvidia驱动上，你可能还需要<code>--gpu-context=x11</code>。)

这些VO使用相当老的视频输出API，这些API大多已经被其供应商放弃了。特别是，已知大多数英特尔驱动程序中的vaapi已经彻底损坏。看到重大的错误和问题并不奇怪，而且mpv对此无能为力。

在某些情况下，为了性能，使用它们可能是合理的（它们可能使用硬件叠加，虽然大多数情况下这些只是用着色器模拟的）。

== RPI上的视频不工作，或太慢 ==

你需要建立支持mmal的FFmpeg--这在FFmpeg中默认是不启用的。mpv也需要用mmal和Broadcom固件libEGL编译。否则，硬件解码和缩放不能被启用。

你可以用<code>mpv --hwdec=help|grep mmal</code>检查链接到mpv的FFmpeg（libavcodec）是否用mmal构建。在mpv 0,.28之前，这可能被称为<code>rpi</code>而不是<code>mmal</code>，而hwdec的帮助输出并不表明FFmpeg是否真的被支持构建。如果输出为空，说明FFmpeg没有被正确构建。你可以用<code>mpv --vo=help|grep rpi</code>检查mpv是否是用mmal构建的。

要让它正确构建是相当复杂的，因为RPI的用户环境是一团糟。不要向我们寻求帮助，因为我们不知道你的具体系统。请记住，固件的libEGL和Mesa的libEGL（通常由发行商提供）是不兼容的。

一旦所有这些都完成了，用<code>mpv --hwdec=rpi --vo=rpi file.mkv</code>运行mpv。否则mpv可能会使用软件解码，这往往是太慢了。

如果你得到错误<code>mmal: mmal_vc_port_enable: failed to enable port vc.ril.video_render:in:0（I420）: ENOMEM</code>, 尝试增加<code>gpu_mem</code>在<code>/boot/config.txt</code>.

== (如何)能播放YouTube的播放列表? ==

和其他事情差不多，只要把播放列表的URL传给mpv。注意，你需要一个链接到实际的播放列表（<code>https://www.youtube.com/playlist?list=...</code>），而不是播放列表中的视频（<code>https://www.youtube.com/watch?v=...&list=...&index=...</code>）。你可以通过点击右边的播放列表的标题来获得该链接。

== 如果我点击mpv，什么都不会发生。 ==

mpv是一个命令行程序，不提供实际的图形用户界面。你需要用一个媒体文件来启动它。在Windows上，你可以用 <code>Open with…</code> 上下文菜单创建一个文件关联。此外，如果你从<code>explorer.exe</code>启动<code>mpv.exe</code>，它将进入[http://mpv.io/manual/master/#pseudo-gui-mode pseudo-gui mode]。对于Linux，提供了一个<code>mpv.desktop</code>文件。

你也可以用<code>mpv --player-operation-mode=pseudo-gui</code>启动mpv。你可以通过把文件放到窗口上播放。

== 如何改变YouTube上的视频质量? ==

通过 '''youtube-dl''' 检查视频的可用格式。

<pre>youtube-dl --list-formats <link></pre>
或<br />
<code>youtube-dl -F <link></code>

比如说:

<pre>youtube-dl -F https://www.youtube.com/watch?v=SYM-RJwSGQ8
[info] Available formats for SYM-RJwSGQ8:
format code  extension  resolution note
...
251          webm       audio only DASH audio  149k , opus @160k, 4.29MiB
135          mp4        854x480    480p 1159k , avc1.4d401e, 25fps, video only, 16.02MiB
247          webm       1280x720   720p 1372k , vp9, 25fps, video only, 20.12MiB
136          mp4        1280x720   720p 2318k , avc1.4d401f, 25fps, video only, 30.37MiB
248          webm       1920x1080  1080p 2402k , vp9, 25fps, video only, 35.54MiB
137          mp4        1920x1080  1080p 3770k , avc1.640028, 25fps, video only, 55.70MiB
22           mp4        1280x720   hd720 , avc1.64001F,  mp4a.40.2@192k (best)
...</pre>
选择格式和类型

<pre>mpv --ytdl-format [format code] https://www.youtube.com/watch?v=SYM-RJwSGQ8</pre>
对于1280x720。

<pre>mpv --ytdl-format 22 https://www.youtube.com/watch?v=SYM-RJwSGQ8</pre>
你可以混合不同的视频+音频。

<pre>mpv --ytdl-format [video format code] + [audio format code] link</pre>
对于mp4 1080p视频（3770k）和webm音频（149k, opus @160k）。

<pre>mpv --ytdl-format 137+251 https://www.youtube.com/watch?v=SYM-RJwSGQ8</pre>

你也可以使用特殊的别名 '''bestvideo''' 和 '''bestaudio''' ，也可以使用条件式。(参见'''youtube-dl --help''' 获取完整文档）。举个例子，如果你总是想使用最好的视频流，但只能达到1440p--并且在不播放DASH流时退回到最好的单文件格式--你可以使用这样的方法。

<pre>ytdl-format=bestvideo[height<=?1440]+bestaudio/best</pre>
== 如何用鼠标滚轮改变音量? ==

默认情况下，音量是通过水平滚动改变的。如果你想使用垂直滚动来实现（而不是寻求），在你的<code>input.conf</code>中放上这个。

<pre>AXIS_UP    add volume 2
AXIS_DOWN  add volume -2</pre>

== 我怎样才能找出与每个键相关的名称和命令？ ==

在[http://mpv.io/manual/master/#options-input-test 输入测试模式]中运行mpv。

<code>mpv --input-test --force-window --idle</code>

== 与mpv一起使用的首选是FFmpeg还是Libav? ==

一般来说，FFmpeg只是因为它有更多的功能。不要指望字幕能在Libav上工作。Libav的支持有时可能会被破坏，因为他们还没有加入某些FFmpeg的API变化，而mpv则依赖于此。

不要把Libav和例如libavcodec混为一谈。libavcodec是一个由FFmpeg和Libav项目共同提供的库。它们的API几乎是一样的，只有细微的差别。

== 如何让mpv成为macOS(OSX)上打开电影文件的默认应用程序? ==

<ul>
<li><p>用Homebrew安装mpv作为一个应用程序：</p>
<source lang="bash">$ brew cask install mpv</source>
<li><p>如果你在应用程序/Launchpad中需要一个别名，在/usr/local/Caskroom/mpv/your_mpv_version/打开一个Finder窗口。在那里，mpv.app bundle已经生成。在按住Cmd+Alt的同时，将这个.app拖入应用程序文件夹。</p>
<li><p>使用[https://github.com/moretension/duti <code>duti</code>]将文件与应用程序联系起来：</p>
<source lang="bash">$ brew install duti
$ duti -s io.mpv avi all
$ duti -s io.mpv mkv all
$ duti -s io.mpv mp4 all</source></li></ul>

对于macOS Big Sur和更高版本，你也可以使用[https://github.com/jdek/openwith <code>openwith</code>]

== 我想在Linux上找回旧的PulseAudio音量控制 ==

在mpv 0.18.1中，音量控制被强制为softvol，而 <code>--softvol</code> 选项被移除。PulseAudio的音量控制（如在服务器中改变每个客户的音量）不再被使用。在默认设置的用户看来，以下事情发生了变化。

* 在mpv中改变音量现在只影响到当前的mpv实例。
* 音量不会被保存在所有的实例中（尽管如果你使用后期观察功能，它会被保存在当前的实例/媒体文件中）。
* 音量不再被限制为100%
* 您不能使用mpv音量控制来设置比您当前PulseAudio音量设置更高的音量。

建议你使用一个单独的、非mpv的键绑定来控制你的全局音量。

如果你想要以前的行为，你必须手动切换你的按键绑定到音频输出音量控制上。

* 打开你的input.conf（默认位置见[https://mpv.io/manual/master/#files 这里]）。
* 添加以下几行:

<pre>9 add ao-volume -2
0 add ao-volume 2</pre>

*或者用<code>ao-volume</code>替换任何出现的<code>volume</code>
* 不要忘了以<code>#</code>开头的行是有注释的（默认的input.conf有所有条目的注释）。
* 注意，mpv 0.18.1有一个错误，如果步骤是<code>1</code>而不是<code>2</code>，会使PulseAudio "卡住"--这在后来的版本中已经被修复。
* 像<code>--volume</code>这样的选项不能影响服务器的值
* 你可以对静音键的绑定做同样的事情(<code>mute</code> -&gt; <code>ao-mute</code>)

你也可以从[https://raw.githubusercontent.com/mpv-player/mpv/master/etc/input.conf default input.conf]中抓取所有音量绑定来改变所有<code>volume</code>的绑定。

注意这也适用于其他音频输出和平台。哪种音量<code>ao-volume</code>控制完全取决于音频API。一些API使其成为全局系统音量，一些使其成为每个客户或每个流的私人音量。

对于有技术倾向的人来说：也有一个分支添加了改变，允许用一个选项来改变所有的键绑定，但到目前为止还没有被证明是受欢迎的：https://github.com/mpv-player/mpv/commit/7621a028bf555c9ed0430501bc6eac2fa204114c

== 我想要回以前的OSC ==

在mpv 0.21.0中，默认的OSC布局被改成了bottombar，同时还有其他的设置，与之配合更好。

在mpv的配置目录下创建一个 <code>lua-settings/osc.conf</code> 文件，并使用以下设置。

<source lang="ini">layout=box
seekbarstyle=slider
deadzonesize=0
minmousemove=3</source>
在mpv 0.22.0中，bottombar和topbar布局在<code>scalewindowed=1</code>中被放大到与之前的<code>scalewindowed=1.5</code>有相同的尺寸。

如果你已经在使用这些布局，并希望比例恢复到0.22.0之前的样子，请用<code>𝑥/1.5</code>来计算，其中𝑥是旧值。因此，如果要寻找与<code>scalewindowed=1</code>相当的东西，请使用这些<code>lua-settings/osc.conf</code>：

<source lang="ini">scalewindowed=0.666
scalefullscreen=0.666</source>
其他选项可在[https://mpv.io/manual/stable/#configurable-options 手册]中找到。

== youtube-dl是如何工作的？它会把流媒体下载到磁盘上吗？ ==

mpv youtube-dl包装脚本在以http(s)开头的URL上调用<code>youtube-dl --dump-single-json, -J</code>。这将返回一个直接的媒体链接，mpv直接从该链接中进行流式传输。没有任何东西被下载到磁盘。一旦播放开始，youtube-dl就退出了，不再活动了。

参见手册中的可用选项：https://mpv.io/manual/master/#options-ytdl

== 为什么一些缓存选项被删除或改变（流缓存）？ ==

从mpv 0.30.0开始，一些缓存选项被移除（<code>--cache-default</code>, <code>--cache-initial</code>, <code>--cache-seek-min</code>, <code>--cache-backbuffer</code>, <code>--cache-file</code>, <code>--cache-file-size</code>），或者改变（<code>--cache</code>不再取KB大小）。这是删除流缓存的结果，流缓存是解复用器和网络层之间的输入数据的环形缓冲器。

缓存现在是在解复用层（在解复用器和解码器之间）完成的，它由单独的选项控制。<code>--cache-secs</code>, <code>--demuxer-readahead-secs</code>, <code>--demuxer-max-bytes</code>, <code>--demuxer-max-back-bytes</code>. 取代了<code>--cache-file</code>，<code>--cache-on-disk</code>。

移除流缓存的原因是，它主要是浪费内存，降低性能，增加代码的复杂性，并且由于缓存层不能准确反映底层流的一些行为，往往会导致奇怪的bug。

== 在Windows上，为什么mpv.exe不能连接到控制台，mpv.com是做什么的？ ==

这是Windows平台的一个限制。在Windows上有两个所谓的子系统：GUI子系统和CLI子系统。一个Windows可执行文件只能使用其中之一。如果一个程序使用CLI子系统，它可以附加到控制台，在那里打印信息，并接受输入。然而，这样的程序如果还没有从控制台窗口运行的话，总是会打开一个自己的控制台窗口。另一方面，一个使用GUI子系统的程序不会附加到它被调用的控制台，控制权将立即返回到命令提示符。为了解决这个限制，mpv有一个单独的可执行文件，叫做mpv.com，它使用CLI子系统，为mpv.exe重定向输入和输出。由于Windows首先寻找后缀为.com的可执行文件（默认情况下；由%PATHEXT%变量定义），只要在命令提示符上输入没有后缀的mpv就会运行mpv.com，你会得到预期的控制台输出。

== 如何自动播放文件夹中的下一个文件？ ==

要么把所有的文件传给mpv，比如在有文件的目录下运行这个。
<pre>mpv *.*</pre>
或者使用一个像https://github.com/mpv-player/mpv/blob/master/TOOLS/lua/autoload.lua 的脚本。

== 为什么mpv不支持Lua 5.3或更新的版本? ==

有数以百计的mpv用户脚本针对Lua 5.1/5.2/jit。Lua 5.3是一种与5.1或5.2不同的语言。简单地切换到Lua 5.3或更新版本可能会破坏大多数用户脚本。与从5.1到5.2（或LuaJIT和5.1/5.2之间）的变化相比，使5.3不兼容的变化更大，影响更大。这尤其是由于引入了整数类型。此外，这将意味着放弃对LuaJIT的支持，因为LuaJIT只支持5.1/5.2语言。

这不是将mpv的Lua代码移植到Lua 5.3或更新版本的问题。问题在于Lua解释器所接受的语言，以及它如何与mpv开发者控制之外的数百个第三方Lua脚本不兼容。

理论上，在一段时间内支持两种语言是可能的。但这需要单独的后端，并需要付出巨大的努力来避免Lua 5.2和5.3之间的符号冲突（甚至可能无法使用发行版提供的libs），所以它不会被完成。

== 什么是rar文件格式，为什么它很愚蠢？ ==

RAR是一种像zip一样的存档文件格式。它是专有的，周围没有多少代码可以完全处理它。每个人都应该使用7zip格式来代替 - 没有理由使用rar。旨在销售处理它的软件的专有文件格式的时代应该结束了。RAR基本上是过去的遗物了。

与多媒体有关的，不幸的是，在未压缩的多卷RAR档案中分发大的视频文件是有些普遍的。这几乎是任何人都能想出的绝对最糟糕的分发媒体的方式。它是愚蠢的，因为它需要每个媒体播放器的支持（限制了你的选择），在某些方面将是低效的，而且是一个绝对不必要的来自过去的遗留物，在那里它也是愚蠢的。很明显，创造这些东西的人生活在过去。

目前mpv通过libarchive来处理这些问题。不幸的是，它对多卷档案的支持并不是很好。

请不要向 mpv 报告这方面的错误。请纠缠libarchive以获得更好的未压缩/多卷RAR支持。

mpv在0.30.0版之前有一些特殊的代码用于未压缩的RAR，以达到这个目的。这段代码来自VLC，但VLC几年前就删除了这段代码。这段代码曾经工作得比较好，但由于维护的原因，保留它是不可接受的。这段代码不太可能被重新编入。

== 为什么没有DVD/Bluray菜单支持？以及一般的DVD/BD支持。 ==

DVD菜单支持在早期就存在了，但被删除了，因为它是一个维护的恶梦。它深深地影响了播放器的无关部分，妨碍了改进更重要的功能。此外，它从来没有运行良好。后来，使用重写的代码再次添加了DVD菜单支持（然后是Bluray菜单支持）。然而，尽管进行了重写，它仍然影响了播放器的核心（阻止了其他领域的改进），而且仍然不能很好地工作。

开发人员的意见是，菜单支持是被诅咒的，反正不值得实施。除了要使它工作良好所需的巨大努力外，只有极少数用户能从中受益。事实上，播放DVD/BD时，如果翻录成文件，会有更好的用户体验，这就排除了菜单支持。

因此，mpv只对光学媒体光盘有一些后退支持。请不要向它报告问题，因为对它进行改进的可能性很小。

如果你是一个开发者，想改进mpv中的DVD/BD支持，我们欢迎你这样做。但请尽量保持代码的隔离，这样它就不会对播放核心产生太大的影响。大多数与之相关的代码必须隔离在一个单独的模块中（例如stream_blurray.c，尽管它允许改变模块的实现层）。在开发者IRC上询问。

== HDR在我的显示器上不工作？ ==

如果你不喜欢HDR的错误色域、错误亮度和丑陋的效果，请使用这个。
见 https://mpv.io/manual/master/#video-filters-format https://mpv.io/manual/master/#options-target-trc https://mpv.io/manual/master/#options-target-prim
```
# 这（可能）是对HD-TV 8位或8位+FRC（假的10位）的实践
--vf=format=colormatrix=bt.709:colorlevels=limited:primaries=bt.709:light=709-1886:gamma=srgb
                                  # 使用 colormatrix "bt.709" 或 "bt.601" 或 "auto"
                                  # 使用 primaries "bt.709" 或 "bt.601-625" 或 "bt.601-525" 或 "adobe" 或 "dci-p3" 或 "auto"
                                  # 使用 colorlevels "limited" 或 "auto"
                                  # 使用 light "709-1886" 或 "hlg" 或 "gamma1.2" 或 "display" 或 "auto"
                                  # 使用 gamma "bt.1886" 或 "srgb" 或 "pq" 或 "gamma1.8" 或 "gamma2.0" 或 "gamma2.2" 或 "linear" 或 "auto"

--video-output-levels=limited     # 有限的范围[(16-235每个分量)，电视和演播室水平]
--target-trc=srgb                 # 使用 "pq" 或 "srgb" 或 "bt.1886"
--target-prim=auto
--dither-depth=8                  # 使用 "auto" 或 "8"/"10"，取决于你的显示位深

# 对于PC，只需改变 "colorlevels=full or auto" 和 "-video-output-levels=full or limited or auto"
```

```
# 这（可能）是对SD-TV的做法
--vf=format=colormatrix=bt.601:colorlevels=limited:primaries=bt.601-525:light=auto:gamma=srgb
                                  # 使用 colormatrix "bt.709" 或 "bt.601" 或 "auto"
                                  # 使用 primaries "bt.709" 或 "bt.601-625" 或 "bt.601-525" 或 "adobe" 或 "dci-p3" 或 "auto"
                                  # 使用 colorlevels "有限" 或 "自动"
                                  # 使用 light "709-1886" 或 "hlg" 或 "gamma1.2" 或 "display" 或 "auto"
                                  # 使用 gamma "bt.1886" 或 "srgb" 或 "pq" 或 "gamma1.8" 或 "gamma2.0" 或 "gamma2.2" 或 "linear" 或 "auto"

--video-output-levels=limited # 有限的范围[(16-235每个分量)，电视和演播室水平]
--target-trc=srgb                 # 使用 "pq" 或 "srgb" 或 "bt.1886"
--target-prim=auto
--dither-depth=8                  # 使用 "auto" 或 "8"，取决于你的显示位深

# 对于PC，只需改变 "colorlevels=full or auto" 和 "--video-output-levels=full or limited or auto"
```

```
# 这（应该）适用于UHD-TV
--vf=format=colormatrix=bt.2020-ncl:colorlevels=limited:primaries=bt.2020:light=709-1886:gamma=bt.1886
                                  # 使用 colormatrix "bt.2020-cl" 或 "bt.2020-ncl" 或 "bt.709" 或 "smpte-240m" 或 "auto"
                                  # 使用 primaries "bt.2020" 或 "bt.709" 或 "adobe" 或 "dci-p3" 或 "auto"
                                  # 使用 colorlevels "limited" 或 "auto"
                                  # 使用 light "709-1886" 或 "hlg" 或 "gamma1.2" 或 "display" 或 "auto"
                                  # 使用 gamma "bt.1886" 或 "srgb" 或 "pq" 或 "gamma1.8" 或 "gamma2.0" 或 "gamma2.2" 或 "linear" 或 "auto"

--video-output-levels=limited # 有限的范围[(16-235每个分量)，电视和演播室水平]
--target-trc=pq                   # 使用 "pq" 或 "srgb" 或 "bt.1886"
--target-prim=auto                # 使用 "bt.2020" 或 "bt.709" 或 "adobe" 或 "dci-p3" 或 "auto"
--dither-depth=auto               # 使用 "auto" 或 "8"/"10"/"12"/"14"/"16"，取决于你的显示器位深。

# 对于PC，只需改变 "colorlevels=full or auto" 和 "--video-output-levels=full or limited or auto"
```

```
# 这(可能)对Apple TV有好处
--vf=format=colormatrix=bt.709:colorlevels=limited:primaries=apple:light=709-1886:gamma=1.8
                                  # 使用 colormatrix "bt.709" or "bt.2020-cl" or "bt.2020-ncl" or "bt.709" or "smpte-240m" or "auto"
                                  # 使用 primaries "bt.601-625" 或 "bt.601-525" 或 "bt.709" 或 "bt.2020" 或 "adobe" 或 "dci-p3" 或 "linear" 或 "auto"
                                  # 使用 colorlevels "limited" 或 "auto"
                                  # 使用 light "709-1886" 或 "hlg" 或 "gamma1.2" 或 "display" 或 "auto"
                                  # 使用 gamma "gamma1.8" 或 "gamma2.0" 或 "gamma2.2" 或 "linear" 或 "bt.1886" 或 "srgb" 或 "pq" 或 "auto"

--video-output-levels=limited     # 有限的范围[(16-235每个分量)，电视和工作室水平]
--gamma-auto                      # 根据环境照明条件自动修正伽玛值
--target-prim=apple               # 使用 "apple" 或 "bt.601-625" 或 "bt.601-525" 或 "bt.709" 或 "bt.2020" 或 "adobe" 或 "dci-p3" 或 "auto"
-dither-depth=auto # 使用 "auto" 或 "8"/"10"/"12"/"14"/"16" 和bla...bla...取决于你的显示器位深

# 对于显示器，只需改变 "colorlevels=full or auto" 和 "--video-output-levels=full or limited or auto"

# 你可以尝试强制传输显示器的特性（gamma），只需禁用/删除 "#--gamma-auto" 并启用"--target trc="
#--target-trc=gamma1.8            # 使用 "gamma1.8" 或 "gamma2.0" 或 "gamma2.2" 或 "linear" 或 "bt.1886" 或 "srgb" 或 "pq" 或 "auto"
```

见 https://mpv.io/manual/master/#options-tone-mapping
为了获得更好的显示效果，你可以使用色调映射图像到目标显示器上。这与HDR->SDR转换以及降低色域有关（例如，在标准色域显示器上播放BT.2020内容）。
```
选择一个；                         #使用 "mobius" 或 "reinhard" 或 "hable" 或 "bt.2390" 或 "linear" 或 "clip" 或 "gamma"
--tone-mapping=mobius
--tone-mapping-param=0.3
--tone-mapping-max-boost=1.0       # 数值1.0到10.0
--gamut-clipping

--tone-mapping=reinhard
--tone-mapping-param=0.5
--tone-mapping-max-boost=1.0
--gamut-clipping

--tone-mapping=linear
--tone-mapping-param=1.0
--tone-mapping-max-boost=1.0
--gamut-clipping

--tone-mapping=clip
--tone-mapping-param=1.0
--tone-mapping-max-boost=1.0
--gamut-clipping

--tone-mapping=gamma
--tone-mapping-param=1.8
--tone-mapping-max-boost=1.0
--gamut-clipping

--tone-mapping=bt.2390
--gamut-clipping
# 感知色调映射曲线（EETF）在ITU-R报告BT.2390中规定。这是MPV的默认，用于典型的HDR-mastered内容的曲线。

--tone-mapping=hable
--gamut-clipping
# 与Reinhard相似，但更好地保留了暗部和亮部的细节（略呈正方形），代价是使所有东西都略微变暗/变不饱和。由John Hable开发，用于视频游戏中。
```
你可以自己改变参数。

尝试设置<code>--d3d11-output-format=...</code>和<code>--d3d11-output-csp=...</code>可能会有帮助（*Windows）。https://mpv.io/manual/master/#options-d3d11-output-format

== 当切换到全屏时，播放器冻结？ ==
试着为D3D11后端添加一行<code>--angle-flip=no</code>或者<code>--d3d11-flip=no</code>。

== mpv与MPlayer有什么关系？ ==

这两个项目之间的关系主要是历史性的。它们应该被视为两个独立的项目。mpv和MPlayer是不同的软件，彼此不兼容。MPlayer和mpv之间的开发人员和其他项目成员没有重叠。mpv不是MPlayer的替代品，而且命令行开关和行为也不同。

MPlayer的用户不应该期望mpv在任何方面与它相似。两者都是CLI视频播放器，有共同的根基，但在某些方面，有根本的区别。一个旧的和过时的变化总结可以在这里找到：https://github.com/mpv-player/mpv/blob/master/DOCS/mplayer-changes.rst

mpv是基于MPlayer的代码。起初，有一个mplayer2项目，它大约在2008年从MPlayer中分叉出来，并与它走了不同的道路。(几年后，它被重新命名为mplayer2，引起了普遍的混乱）。2012年，一些新的开发者，在2011年左右加入了mplayer2的开发，再次分叉了mplayer2。第二次分叉后被重新命名为mpv。

这次分叉的原因是对开发方向的分歧。MPlayer专注于维护，不破坏旧的代码和功能，而mpv则希望向另一个方向发展，即现代化。这包括毫不留情地删除那些被认为是不值得维护的代码/功能，因为它们晦涩难懂，不被使用，或者重写现有的代码来清理和减少错误。通过用FFmpeg机制取代MPlayer代码来减少维护负担也是一个重点。mplayer2项目在mpv分叉后很快就不活跃了，今天已经完全消失。

我们认为mpv的激进方法是成功的，它使代码更容易操作，消除了bug，并使添加新功能变得更容易。我们增加了用户所需要的现代功能，以换取删除大量几乎没有人使用的功能。

一个结果是，mpv的开发与MPlayer的开发不再有任何关系。它们是完全独立的项目。mplayer2时期可能促成了这两个项目之间的相对隔离。经过这么多年的分道扬镳，把MPlayer和mpv合并成一个项目是没有意义的。

== 我如何创建一个适用于所有视频（或所有音频）的有条件自动配置文件？ ==

根据mpv手册，https://mpv.io/manual/master/，你可以创建自动配置文件，如果满足特定条件，将自动应用特定的选项。

以下配置文件（添加到你的配置文件中）分别自动适用于所有视频文件和所有音频文件。

```
# 这适用于所有视频
[video]
profile-cond=get("current-tracks/video/albumart") == false
# 用你想应用的选项替换这一行
```

```
# 这适用于所有音频
[audio]
profile-cond=not vid and not vo_configured or get("current-tracks/video/albumart")
# 用你想应用的选项替换这一行
```

== 如何旋转视频？ ==

以90°为单位循环使用 <code>video-rotate</code> 值 <code>input.conf</code> 的例子。

```
r cycle-values video-rotate 270 180 90 0
t cycle-values video-rotate 90 180 270 0
```
