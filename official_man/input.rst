命令接口
========

mpv的核心可以用命令和属性来控制。许多与播放器交互的方式都使用它们：按键绑定（ ``input.conf`` ），OSD（用属性显示信息），JSON IPC和客户端API（ ``libmpv`` ）。

input.conf
----------

input.conf文件由一系列按键绑定的列表组成，例如::

    s screenshot      # 用s键截屏
    LEFT seek 15      # 将向左键映射为向前搜寻15秒

每一行映射一个按键到一个输入命令。按键被指定为其按键名（如果与 ``Shift`` 结合，则为大写），或者为特殊键指定一个名称。例如， ``a`` 映射到 ``a`` 键，不需要shift，而 ``A`` 映射到 ``a`` 键，需要shift 。

该文件位于mpv设置目录下（通常在 ``~/.config/mpv/input.conf`` ，取决于平台）。默认的绑定在这里定义::

    https://github.com/mpv-player/mpv/blob/master/etc/input.conf

特殊按键的列表可以通过以下方式获得

    ``mpv --input-keylist``

一般来说，按键可以与 ``Shift`` ``Ctrl`` ``Alt`` 组合::

    ctrl+q quit

**mpv** 可以在输入测试模式下启动，在OSD上显示按键的绑定和它们所绑定的命令，而不会执行命令::

    mpv --input-test --force-window --idle

（只有关闭窗口才能使 **mpv** 退出，按下普通的键只是显示绑定的命令，即使被映射为quit）

另参见 `按键名称`_

input.conf语法
--------------

``[Shift+][Ctrl+][Alt+][Meta+]<key> [{<section>}] <command> ( ; <command> )*``

注意，默认情况下，右Alt键可以被创建为特殊字符，因此两个Alt不会注册为单个修饰键。选项 ``--input-right-alt-gr`` 可以改变这一行为。

换行总是开始一个新的绑定。 ``#`` 开始一个注释（在被引用的字符串参数之外）。为了将命令与 ``#`` 键绑定，可以使用 ``SHARP``

``<key>`` 是该按键的字面字符（ASCII或Unicode字符），或者是一个符号名称（正如由 ``--input-keylist`` 输出的内容）。

``<section>`` （用 ``{`` 和 ``}`` 括起来）是这个命令的输入部分。

``<command>`` 是命令本身。它由命令名称和多个（或无）参数组成，所有参数都用空格隔开。字符串参数应被引用，一般用 ``"`` 。参见  `Flat命令语法`_

你可以绑定多个命令到一个按键上。例如：

| a show-text "command 1" ; show-text "command 2"

也可以将一个命令与多个按键绑定：

| a-b-c show-text "command run after a, b, c have been pressed"

（这在一般的命令语法中没有展示）

按键匹配
--------

mpv 保留按键历史记录。如果当前按键触发了一个或多个已绑定的键序列（包括单键绑定），则 mpv 会选择其中最长的序列。如果该序列绑定到 ``ignore`` ，则继续跟踪历史记录，仿佛未匹配任何内容。否则，它将触发该序列绑定的命令并清除按键历史记录。

需要注意的是，虽然单键绑定会覆盖内置绑定，但多键序列并非如此。例如，input.conf 中的 ``b-c`` 序列会被内置绑定 ``b`` 覆盖。在这种情况下，如果你不在意 ``b``，可以将其绑定到 ``ignore`` 。

作为一个更复杂的示例，如果你想同时绑定 ``b`` 和 ``a-b-c`` ，那么这将无法工作，因为 ``b`` 会覆盖 ``a-b-c`` 。然而，将 ``a-b`` 绑定到 ``ignore`` 则可行，因为在 ``a-b`` 之后，最长的匹配序列 ``a-b`` 将被忽略，随后出现的 ``c`` 会触发序列 ``a-b-c``，而单独的 ``b`` 仍可正常工作。

按键名称
--------

所有的鼠标和键盘的输入都要转换为mpv指定的按键名称。键名要么是代表物理键的特殊符号标识，要么是文本键名，它是UTF-8编码的unicode码点。这些都是键盘输入通常会产生的，例如， ``a`` 代表A键。这些都会受到键盘修饰符的影响，例如 Shift 和 Caps Lock。因此，mpv使用由当前操作系统键盘布局转译的输入，而不是物理扫描代码。

目前有一个硬编码的假设，即每个文本键都可以表示为一个单一的unicode码点（NFKC形式）。

所有的键名都可以与修饰键 ``Shift`` ``Ctrl`` ``Alt`` ``Meta`` 结合。它们必须以实际的键名为前缀，每个修饰键后面都有一个 ``+`` （例如 ``ctrl+q`` ）。

.. note::

    需要注意一下 ``Shift`` 修饰键。一般来说，当 ``Shift`` 修饰符与产生文本的按键组合使用时，应使用按下 Shift 时实际产生文本的按键名称。

    例如在美式键盘布局下， ``Shift+2`` 通常应该在 ``input.conf`` 中指定为键名 ``@`` ，同样， ``Alt+Shift+2`` 的组合通常为 ``Alt+@`` ，等等。

    一般来说，与文本键名一起指定的 ``Shift`` 修饰符会被忽略：例如，mpv 将 ``Shift+2`` 解析为 ``2`` 。唯一的例外是 ASCII 字母，mpv 会对其进行规范化处理。例如， ``Shift+a`` 被解析为 ``A`` 。

    特殊的键名，如 ``Shift+LEFT`` ，按预期工作。如果有疑问 —— 使用 ``--input-test`` 来检查mpv是如何处理某个按键/组合的。

符号键名和修饰键名不区分大小写。Unicode键名是区分大小写的，就像实际的键盘文本输入一样。

另一种键名是十六进制键名，以 ``0x`` 开头，后面是按键的十六进制值。十六进制值既可以是 Unicode 码位值，也可以作为没有特殊 mpv 定义名称的特殊按键的后备值。一旦mpv为它们添加了合适的名字，它们之前的值就会失效，反之，你就可以当作单独的按键实用。

所有的符号键名都由 ``--input-keylist`` 列出。 ``--input-test`` 是一个特殊的模式，在OSD上输出出所有的输入。

对一些符号键名的注释：

``KP*``
    小键盘名。行为因后端而异（是否实现，以及如何处理numlock），但通常情况下，mpv尝试将小键盘上的按键映射到独立的名称，即使它们能输出与一般按键相同的文本。

``MOUSE_BTN*`` ``MBTN*``
    各种鼠标按钮

    取决于后端，鼠标滚轮也可被表示为一个按钮。此外， ``MOUSE_BTN3`` ``MOUSE_BTN4`` ``MOUSE_BTN5`` ``MOUSE_BTN6`` 分别是 ``WHEEL_UP`` ``WHEEL_DOWN`` ``WHEEL_LEFT`` ``WHEEL_RIGHT`` 的过时的别名。

    ``MBTN*`` 是 ``MOUSE_BTN*`` 的别名

``WHEEL_*``
    鼠标滚轮和触控板（通常）

    如果底层设备支持高分辨率滚动（如触摸板），这些按键在与可扩展命令一起使用时是可延展的。

``AXIS_*``
    ``WHEEL_*`` 的别名，已过时

``*_DBL``
    鼠标按键 双击

``MOUSE_MOVE`` ``MOUSE_ENTER`` ``MOUSE_LEAVE``
    由鼠标移动事件触发。当光标进入或离开mpv窗口（或当前光标区域，使用已过时的鼠标区域输入部分机制）时ENTER/LEAVE发生。

``CLOSE_WIN``
    当使用操作系统窗口管理器关闭mpv窗口时发出的虚拟键（例如，通过点击窗口标题栏的关闭按钮）

``GAMEPAD_*``
    由SDL游戏手柄后端触发的键

``UNMAPPED``
    匹配任何未映射的键的虚拟键（如果可能的话，你应该避免这样做，因为它可能会变更行为或在将来被移除）

``ANY_UNICODE``
    匹配任何产生文本的键的虚拟键（如果可能的话，你应该避免这样做，因为它可能会变更行为或在将来被移除）

Flat命令语法
------------

这是在input.conf中使用的语法，并在其它的一些地方被“input.conf语法”提及。

|
| ``<command>  ::= [<prefixes>] <command_name> (<argument>)*``
| ``<argument> ::= (<unquoted> | " <double_quoted> " | ' <single_quoted> ' | `X <custom_quoted> X`)``

``command_name`` 是一个不引用的包含命令名称本身的字符串。参见列表 `输入命令列表`_

参数之间用空格隔开，即使命令只有一个参数。带有空格或其他特殊字符的参数必须引用，否则命令不能被正确解析。

双引号引用解释JSON/C-style的转义，如 ``\t`` 或 ``\"`` 或 ``\\`` 。JSON根据RFC 8259进行转义，减去surrogate pair转义。这是唯一一种允许在值上加换行的形式 —— 如 ``\n``

单引号引用解释字面内容，并且不能在值中包含单引号的字符。

自定义引用也是解释字面内容，但比单引号引用更灵活。它们以 ````` （反引号）开始，后面是任何ASCII字符，并以同一对的第一次出现为结束，顺序相反，例如： ```-foo-``` 或 ````bar```` 。最后一对序列不允许出现在值中 —— 例子分别是 ``-``` 和 `````` 。在第二个例子中，值的最后一个字符也不能是反引号。

不支持对同一个参数的进行混合引用，如 ``'foo'"bar"`` 。

请注意，参数解析和属性扩展发生在不同阶段。首先，参数如上所述被确定，然后，如果适用的话，属性被扩展 —— 无视参数的引用。然而，仍然可以用 ``raw`` 前缀或 ``$>`` 防止被扩展。参见 `输入命令前缀`_ 和 `属性扩展`_

指定为数组的命令
----------------

这适用于部分API，例如Lua脚本中的 ``mp.commandv()`` 或 ``mp.command_native()`` （带有数组参数），或者C语言libmpv客户端API中的 ``mpv_command()`` 或 ``mpv_command_node()`` （带有 MPV_FORMAT_NODE_ARRAY ）。

命令以及所有的参数都以一个数组的形式传递。类似于 `Flat命令语法`_ ，你可以先把前缀作为字符串传递（每个都是单独的数组项），然后把命令名称作为字符串，然后把每个参数作为字符串或原生值。

由于这些API将参数作为单独的字符串或原生值来传递，所以它们不需要引用，并且支持转义。技术上讲，有一个input.conf解析器，它首先将命令字符串分割成数个参数，然后为每个参数调用解析器。input.conf解析器通常处理引号和转义。上面提到的数组命令API直接将字符串传递给参数解析器，或者可以通过传递非字符串值的职能回避它们。

对于这些API，属性扩展默认是禁用的。这可以用 ``expand-properties`` 前缀来改变。参见 `输入命令前缀`_

有时命令的参数是字符串，而这些参数实际上是由其它组件解析的（例如，用 ``vf add`` 的滤镜字符串） —— 在这些情况下，你不得不在input.conf中进行双击，但在数组API中则不必。

对于复杂的命令，可以考虑使用 `命名参数`_ 来代替，这样应该会更具兼容性。不过有些命令不支持命名参数，而是采用数组参数。

命名参数
--------

这适用于部分API，例如Lua脚本中的 ``mp.command_native()`` （有字符串键的表），或者C语言libmpv客户端API中的 ``mpv_command_node()`` （带有 MPV_FORMAT_NODE_MAP ）。

命令的名称是由 ``name`` 字符串字段提供的。每个命令的名称在 `输入命令列表`_ 中的每个命令描述内都有定义。 ``--input-cmdlist`` 也可以列出它们。参见 ``subprocess`` 命令为例。

有些命令不支持命名参数（例如 ``run`` 命令）。你需要使用以数组形式传递参数的API。

命名参数在 "flat" 的input.conf语法中不被支持，这意味着你根本无法在input.conf中使用它们作为按键的绑定。

对于这些API，属性扩展默认是禁用的。这可以通过 ``expand-properties`` 前缀来改变。参见 `输入命令前缀`_

输入命令列表
------------

带参数的命令中，参数名称用符号 ``<`` / ``>`` 括起来。不要在实际命令中加入这些符号。可选参数用 ``[`` / ``]`` 符号括起来。如果你不传递它们，它们将被设置为默认值。

记住在input.conf中引用字符串参数（参见 `Flat命令语法`_ ）

播放控制
~~~~~~~~

``seek <target> [<flags>]``
    变更播放位置。默认情况下，以相对的秒数来跳转。

    第二个参数是跳转模式：

    relative （默认）
        相对当前位置跳转（负值向前跳转）
    absolute
        跳转到一个指定的时间（负值从文件的末尾开始）
    absolute-percent
        跳转到一个指定的百分比位置
    relative-percent
        跳转到相对当前位置的百分比位置
    keyframes
        始终在关键帧处重新开始播放（快）
    exact
        始终做精确跳转（慢）

    多个标志可以合并，例如： ``absolute+keyframes``

    默认情况下， ``keyframes`` 用于 ``relative``, ``relative-percent`` 和 ``absolute-percent`` 跳转，而 ``exact`` 用于 ``absolute`` 跳转。

    在mpv 0.9之前， ``keyframes`` 和 ``exact`` 标志必须作为第3个参数传递（基本上是用空格代替 ``+``）。第3个参数仍然被解析，但被认为是过时的语法。

    这是一个可扩展命令。详见 `输入命令前缀`_ 中的 ``nonscalable`` 部分的文档。

``revert-seek [<flags>]``
    撤销 ``seek`` 命令，以及其他的跳转命令（但不一定是所有的）。调用这个命令一次会回到跳转前的播放位置。第二次调用它将撤销 ``revert-seek`` 命令本身。这只在同一个文件中有效。

    第一个参数是可选的，它可以改变行为：

    mark
        标记当前的时间位置。下一次正常的 ``revert-seek`` 命令将返回到这个时间点，不管上次之后发生了多少次搜索。
    mark-permanent
        如果设置，标记当前时间位置，在下一个设置了 ``mark`` 或 ``mark-permanent`` 的 ``revert-seek`` 命令之前（或当前文件的播放结束），不改变标记位置。在这之前, ``revert-seek`` 将一直跳转到被标记的时间点. 这个标志不能与 ``mark`` 结合使用。

    在没有任何参数的情况下使用默认行为。

``sub-seek <skip> [<flags>]``
    跳转视频和音频位置，以便显示 ``<skip>`` 字幕事件之后的字幕事件。例如， ``sub-seek 1`` 跳到下一个字幕， ``sub-seek -1`` 跳到上一个字幕， ``sub-seek 0`` 则跳到当前字幕的开头。

    这类似于 ``sub-step`` ，只是它跳转视频和音频，而不是调整字幕延迟。

    第二个参数：

    primary （默认）
        通过主字幕步进
    secondary
        通过次字幕步进

    对于嵌入式字幕（如Matroska），这只适用于已经显示过的字幕事件，或在一个短的预取范围内。有关如何控制可用预取范围的详细信息，详见 `缓存`_ 部分。

``frame-step [<frames>] [<flags>]``
    按给定的帧数前进或后退。如果省略了 ``<frames>`` ，则假定该值为 ``1`` 。

    第二个参数由控制frameskip模式的标志组成：

    play （默认）
        将视频播放到所需的帧数，然后暂停。这只适用于正值（即帧步进）。
    seek
        执行非常精确的跳转，尝试跳转所需的帧数。如果 ``<frames>`` 为 ``-1`` ，则会精确回到上一帧。
    mute
        与 ``play`` 相同，但会在帧步进期间静音音频流（如果存在）。

    请注意，默认的frameskip模式 play 更为精确，但速度可能较慢，这取决于跳转的帧数（例如，向前跳转 100 帧将播放 100 帧视频后才停止）。该模式仅在帧步进时有效。帧步退总是执行跳转。

    在使用 seek 模式时，它的运行速度仍然会很慢（它试图做到精确，而不是快速），有时还会出现与预期不符的情况。效果如何取决于精确跳转是否正确（例如，参见 ``--hr-seek-demuxer-offset`` 选项）。视频滤镜或其它修改帧timing的视频后处理（例如去隔行扫描）通常都能正常工作，但在某些情况下可能会使帧步进出现静默错误。使用 ``--hr-seek-framedrop=no`` 应该会有帮助，不过可能会降低精确跳转的速度。此外，如果视频是 VFR，帧步进使用seek可能无法正常工作，除非是在 ``-1`` 的情况下。

    这对纯音频播放无效。

``frame-back-step``
    Calls ``frame-step`` with a value of ``-1`` and the ``seek`` flag.

    这对纯音频播放无效。

``stop [<flags>]``
    停止播放并清除播放列表。在默认设置下，这基本上类似 ``quit`` 。对client API很有用：可以在不终止播放器的情况下停止播放。

    第一个参数是可选的，并支持以下标志：

    keep-playlist
        不清除播放列表。

属性操作
~~~~~~~~

``set <name> <value>``
    将指定的属性或选项设置为指定的值。

``del <name>``
    删除指定的属性。大多数属性不能被删除。

``add <name> [<value>]``
    向属性或选项添加指定的值。在上溢或下溢时，将属性钳制为最大值。如果省略了 ``<value>`` ，则假定为 ``1`` 。

    默认情况下是否启用key-repeat取决于属性。当前，具有连续值的属性默认为可重复（例如 ``volume`` ），具有离散值的属性默认为不可重复（例如 ``osd-level`` ）。

    这是一个可扩展命令。详见 `输入命令前缀`_ 中的 ``nonscalable`` 部分的文档。

``multiply <name> <value>``
    类似 ``add`` ，但将属性或选项与数值相乘。

``cycle <name> [<value>]``
    循环指定的属性或选项。第二个参数可以是 ``up`` 或 ``down`` 来设置循环方向。上溢时，将属性设回最小值，下溢时，将其设为最大值。如果省略了 ``up`` 或 ``down``  ，则假定为 ``up`` 。

    默认情况下是否启用按键可重复，取决于属性。目前具有连续性的值的属性默认是可重复的（如 ``volume`` ），而离散值则不是（如 ``osd-level`` ）。

    这是一个可扩展命令。详见 `输入命令前缀`_ 中的 ``nonscalable`` 部分的文档。

``cycle-values [<"!reverse">] <property> <value1> [<value2> [...]]``
    循环一系列值的列表。每次调用该命令将把指定的属性设置为列表中的下一个值。该命令将使用属性/选项的当前值，并利用它来确定当前在值列表中的位置。一旦找到它，将设置为列表中的下一个值（如果需要的话，将回到第一个项目）。

    这个命令的参数数量不定，不能与命名参数一起使用。

    特殊参数 ``!reverse`` 可以用来反向循环值列表。唯一的好处是，在添加第二个按键绑定的时候，你不需要自己反转值列表进行循环。

``change-list <name> <operation> <value>``
    该命令改变一系列的选项列表，如 `列表选项`_ 中所述。 ``<name>`` 参数是普通的选项名称，而 ``<operation>`` 是选项的后缀或操作。

    有些操作不取值，但命令仍然需要值参数。在这些情况下，值必须是一个空字符串。

    .. admonition:: 示例

        ``change-list glsl-shaders append file.glsl``

        将一个文件添加到 ``glsl-shaders`` 列表中。在命令行中相当于 ``--glsl-shaders-append=file.glsl`` 或者 ``--glsl-shader=file.glsl``

播放列表操作
~~~~~~~~~~~~

``playlist-next [<flags>]``
    转到播放列表的下一个条目。

    第一个参数：

    weak （默认）
        如果播放列表的最后一个文件是当前播放的文件，则无操作
    force
        如果播放列表没有更多的文件，就终止播放

``playlist-prev [<flags>]``
    转到播放列表的上一个条目。

    第一个参数：

    weak （默认）
        如果播放列表的第一个文件是当前播放的文件，则无操作
    force
        如果第一个文件正在播放，就终止播放

``playlist-next-playlist``
    以不同的 ``playlist-path`` 转到播放列表上的下一个条目。

``playlist-prev-playlist``
    以不同的 ``playlist-path`` 转到播放列表上的上一个条目。

``playlist-play-index <integer|current|none>``
    开始（或重新开始）播放指定的播放列表索引。除了基于0的播放列表条目索引外，它还支持以下值：

    <current>
        当前的播放列表条目（如 ``playlist-current-pos`` ）将被再次播放（卸载和重新加载）。如果没有设置，播放就会停止。(在边缘情况下， ``playlist-current-pos`` 可以指向一个播放列表条目，即使当前的播放状态未激活。

    <none>
        播放被停止。如果空闲模式（ ``--idle`` ）被启用，播放器将进入空闲模式，否则将退出。

    该命令和 ``loadfile`` 类似，它只操作下一个将播放文件的状态，而不等待当前文件被退出，或下一个文件被加载。

    设置 ``playlist-pos`` 或类似的属性可以产生与此命令近似的效果。然而它更明确，例如，新的播放列表条目与旧的相同，它将保证重启播放。

``loadfile <url> [<flags> [<index> [<options>]]]``
    加载指定的文件或URL并播放它。从技术上讲，这只是一个播放列表的操作命令（它要么替换播放列表，要么添加一个条目）。实际的文件加载是独立发生的。例如，一个用新文件替换当前文件的 ``loadfile`` 命令会在当前文件停止之前返回，而后才开始加载新文件。

    第二个参数：

    <replace> （默认）
        停止播放当前文件，并立即播放新文件
    <append>
        将文件追加到播放列表中
    <append-play>
        添加文件，如果当前没有文件播放，则开始播放（始终从添加的文件开始播放，即使在运行这个命令之前的播放列表不是空的）
    <insert-next>
        将文件直接插入播放列表的当前条目之后。
    <insert-next-play>
        将文件插入下一个，如果当前没有播放，则开始播放。(总是从添加的文件开始播放，即使运行此命令前播放列表不是空的也是如此）。
    <insert-at>
        在第三个参数给定的索引处将文件插入播放列表。
    <insert-at-play>
        在第三个参数给定的索引处插入文件，如果当前没有播放，则开始播放。(总是从添加的文件开始播放，即使播放列表在运行此命令前不是空的）。

    第三个参数是插入索引，仅用于 ``insert-at`` 和 ``insert-at-play`` 操作。与这些操作一起使用时，新项目将被插入播放列表中的索引位置，如果索引小于 0 或大于播放列表的大小，则会被追加到末尾。所有其他操作都将忽略此参数。此参数自mpv0.38.0版本起加入。

    第四个参数是一个选项和值的列表，应该在文件播放时设置。它的形式是 ``opt1=value1,opt2=value2,..`` 。当使用client API时，这可以是一个 ``MPV_FORMAT_NODE_MAP`` （或一个Lua表），但当前的值本身必须是字符串。这些选项在播放过程中设置，并在播放结束时恢复到之前的值（参见 `单文件选项`_ ）。

    .. warning::

        自 mpv 0.38.0 起，插入索引参数被添加为第三个参数。这就破坏了该命令的所有现有用法，即在播放文件时使用该参数包含要设置的选项列表。为了解决这个问题，如果需要使用第四个参数，现在需要将第三个参数设置为-1。

``loadlist <url> [<flags> [<index>]]``
    加载指定的列表文件或URL（类似 ``--playlist`` ）。

    第二个参数：

    <replace> （默认）
        停止播放，用新的列表替换播放器内部的播放列表
    <append>
        在当前的内部播放列表的末尾追加新的播放列表
    <append-play>
        追加新的播放列表，如果当前没有文件播放，则开始播放（始终从新的列表开始播放，即使在运行这个命令之前的内部播放列表不是空的）
    <insert-next>
        将新播放列表直接插入当前内部播放列表的当前条目之后。
    <insert-next-play>
        插入新的播放列表，如果当前没有播放列表，则开始播放。(总是从新的播放列表开始播放，即使运行此命令前内部播放列表不是空的也是如此）。
    <insert-at>
        在第三个参数给定的索引处插入新的播放列表。
    <insert-at-play>
        在第三个参数给定的索引处插入新的播放列表，如果当前没有播放列表，则开始播放。(总是从新的播放列表开始播放，即使运行此命令前内部播放列表不是空的）。

    第三个参数是插入索引，仅用于 ``insert-at`` 和 ``insert-at-play`` 操作。与这些操作一起使用时，新的播放列表将插入到内部播放列表中的索引位置，如果索引小于 0 或大于内部播放列表的大小，则附加到末尾。所有其他操作都将忽略此参数。

``playlist-clear``
    清除播放列表，除了当前播放的文件。

``playlist-remove <index>``
    移除指定索引的播放列表条目。索引值从0开始计算。 特殊值 ``current`` 移除当前的条目。注意，移除当前条目也会停止播放并开始播放下一个条目。

``playlist-move <index1> <index2>``
    移动索引1的播放列表条目，使其取代索引2的条目（矛盾的是，如果index1低于index2，移动后的播放列表条目将没有index2的索引值，因为index2指的是目标条目，而不是该条目移动后的索引）。

``playlist-shuffle``
    随机洗牌播放列表。这与使用 ``--shuffle`` 选项时启动的情况类似。

``playlist-unshuffle``
    尝试恢复之前的 ``playlist-shuffle`` 命令。这只起一次作用（对多个连续的 ``playlist-unshuffle`` 命令无效）。如果在 ``playlist-shuffle`` 命令之后，有新的递归播放列表被打开，可能无法正常起效。

轨道操作
~~~~~~~~

``sub-add <url> [<flags> [<title> [<lang>]]]``
    加载指定的字幕文件或流。默认情况下，加载后它被选为当前字幕。

     ``flags`` 参数是以下值之一：

    <select>

        立即选择字幕（默认）

    <auto>

        不选择字幕（或者在某些特殊情况下，让默认的流选择机制决定）

    <cached>

        选择字幕。如果已经添加了一个相同文件名的字幕，则选择该字幕，而不是加载一个重复的条目（在这种情况下，标题/语言被忽略，如果在加载后发生了变化，这些变化将不会被反映出来）

    此外，还可以用 ``+`` 添加以下flag：

    <hearing-impaired>

        将轨道标记为适合听障人士使用。

    <visual-impaired>

        将轨道标记为适合视障人士使用。

    <forced>

        将轨道标记为强制轨道。

    <default>

        将轨道标记为默认轨道。

    <attached-picture> （仅适用于 ``video-add`` ）

        将轨道标记为附加图片，与 ``video-add`` 的 ``albumart`` 参数相同。

    ``title`` 参数设置UI中的曲轨道标题。

    ``lang`` 参数设置轨道语言，如果 ``flags`` 设置为 ``auto`` ，也会影响流的选择。

``sub-remove [<id>]``
    移除指定的字幕轨。如果缺少 ``id`` 参数，则移除当前轨道。（只对外部字幕文件有效）

``sub-reload [<id>]``
    重新加载指定的字幕轨。如果缺少 ``id`` 参数，则重新加载当前轨道。（只对外部字幕文件有效）

    这通过卸载和重新添加字幕轨道来工作。

``sub-step <skip> [<flags>]``
    改变字幕时间，使下一个 ``<skip>`` 字幕事件之后的字幕事件被显示。 ``<skip>`` 可以是负数以便后退。

    第二个参数：

    primary （默认）
        在主字幕中步进
    secondary
        在次字幕中步进

``audio-add <url> [<flags> [<title> [<lang>]]]``
    加载指定的音频文件。参见 ``sub-add`` 命令。

``audio-remove [<id>]``
    移除指定的音轨。参见 ``sub-remove`` 命令。

``audio-reload [<id>]``
    重新加载指定的音轨。参见 ``sub-reload`` 命令。

``video-add <url> [<flags> [<title> [<lang> [<albumart>]]]]``
    加载指定的视频文件。常见选项参见 ``sub-add`` 命令。

    ``albumart`` (``MPV_FORMAT_FLAG``)
        如果启用，mpv将加载指定视频作为专辑封面。

``video-remove [<id>]``
    移除指定的视频轨道。参见 ``sub-remove`` 命令。

``video-reload [<id>]``
    重新加载指定的视频轨道。参见 ``sub-reload`` 命令。

``rescan-external-files [<mode>]``
    根据当前的 ``--sub-auto``, ``--audio-file-auto`` 和 ``--cover-art-auto`` 设置重新扫描外部文件。这可以用来自动加载外部文件，在文件被加载 *之后* 。

    ``mode`` 参数是以下之一：

    <reselect> （默认）
        选择默认的音频和字幕流，这通常会选择具有最高优先级的外部文件（这个实现并不完美，可以根据要求进行改进）

    <keep-selection>
        不改变当前的音轨选择

文本操作
~~~~~~~~

``print-text <text>``
    输出文本到stdout。字符串可以包含属性（参见 `属性扩展`_ ）。注意把参数放在引号里。

``expand-text <text>``
    对参数进行属性扩展，并返回扩展后的字符串。这只能通过client API或脚本中的 ``mp.command_native`` 来使用。（见 `属性扩展`_ ）

``expand-path <text>``
    将一个路径的double-tilde占位符扩展为一个特定平台的路径。与 ``expand-text`` 一样，这只能通过client API或脚本中的 ``mp.command_native`` 来使用。

    .. admonition:: 示例

        ``mp.osd_message(mp.command_native({"expand-path", "~~home/"}))``

        这一行Lua将在OSD上显示用户的mpv设置目录的位置。

``normalize-path <filename>``
    通过将路径 ``filename`` 转换为绝对路径、删除连续的斜线、删除 ``.`` 部分、解析 ``..`` 组件以及在 Windows 上将斜线转换为反斜线，返回路径 ``filename`` 的规范表示。除非平台是 Unix-like，且路径组件之一是 ``..``，否则不会解析符号链接。如果 ``filename`` 是一个 URL，则会原封不动地返回。只能通过client API 或使用 ``mp.command_native`` 的脚本使用。

    .. admonition:: 示例

        ``mp.osd_message(mp.command_native({"normalize-path", "/foo//./bar"}))``

        这行Lua在OSD上输出 "/foo/bar"

``escape-ass <text>``
    修改 ``text`` 以便解析 ASS 标记的命令和函数，如 ``osd-overlay`` 和 ``mp.create_osd_overlay`` 会逐字显示并返回。只能通过client API 或使用 ``mp.command_native`` 的脚本使用。

    .. admonition:: 示例

        ``mp.osd_message(mp.command_native({"escape-ass", "foo {bar}"}))``

        这行Lua在OSD上输出 "foo \\{bar}"

设置文件类命令
~~~~~~~~~~~~~~

``apply-profile <name> [<mode>]``
    应用一个已命名的配置预设的内容。这就像在设置文件中使用 ``profile=name`` ，你除了可以把它映射到一个按键绑定，也可在运行时更改它。

    模式参数：

    ``apply``
        应用该配置文件。如果省略该参数，则为默认。

    ``restore``
        恢复执行 ``apply-profile`` 命令应用该配置预设之前的选项。只有当配置预设的 ``profile-restore`` 设置为相关的模式时才有效。如果没有操作执行，则输出一个警告。详情参见 `运行时的配置预设`_

``load-config-file <filename>``
    加载配置文件，类似于 ``--include`` 选项。如果文件已经包含，则在重新解析前不会重置其先前的选项。

``write-watch-later-config``
    写入 ``quit-watch-later`` 命令所写的恢复设置文件，但继续正常播放。

``delete-watch-later-config [<filename>]``
    删除任何由 ``quit-watch-later`` 或 ``write-watch-later-config`` 写入的现有恢复设置文件。如果指定了文件名，那么删除的是该文件的设置；否则，就是在当前情况下由 ``quit-watch-later`` 或 ``write-watch-later-config`` 写入的设置。

OSD类命令
~~~~~~~~~

``show-text <text> [<duration>|-1 [<level>]]``
    在OSD上显示文本。字符串可以包含属性，如 `属性扩展`_ 中所述。这可以用来显示播放时间、文件名，等等。 ``no-osd`` 对该命令无效。

    <duration>
        显示信息的时间，单位是ms。默认情况下，它使用与 ``--osd-duration`` 相同的值

    <level>
        显示文本的最小OSD层级（参见 ``--osd-level`` ）

``show-progress``
    在OSD上显示进度条、已用时间和文件的总时间。 ``no-osd`` 对该命令无效

``overlay-add <id> <x> <y> <file> <offset> <fmt> <w> <h> <stride> <dw> <dh>``
    添加一个来自原始数据的OSD叠加层。这对控制mpv的脚本和应用程序可能很有用，它们想在视频窗口上面显示内容。

    叠加层通常是以屏幕分辨率显示的，但对于某些视频输出驱动来说，分辨率会降低到视频的分辨率。你可以阅读 ``osd-width`` 和 ``osd-height`` 属性。至少对于 ``--vo-xv`` 和变形视频（如DVD）， ``osd-par`` 也应该被读取，并且覆盖层应该遵循是宽高比补偿的。

    这有以下命名参数。它们的顺序是不被保证的，所以你应该始终用命名参数来调用它们，参见 `命名参数`_

    ``id`` 是一个介于0到63之间的整数，用于识别叠加元素。这个ID可以用来添加多个覆盖部分，通过使用这个命令更新一个已经存在的ID的部分，或者用 ``overlay-remove`` 来移除一个部分。使用一个先前未使用的ID将添加一个新的覆盖层，而重复使用一个ID将更新它。

    ``x`` 和 ``y`` 指定OSD应该显示的位置。

    ``file`` 指定从原始图像数据读取的文件。它可以是以 ``@`` 为前缀的数字UNIX文件描述符（例如： ``@4`` ），也可以是文件名。文件将被 ``mmap()`` 映射到内存中，被复制，并在命令返回前解除映射（在mpv 0.18.1中已改变）。

    也可以通过传递内存地址作为整数前缀的 ``&`` 字符来传递原始内存地址作为位图内存使用。在这里传递错误的东西会使播放器崩溃。这种模式在与libmpv一起使用时可能很有用。 ``offset`` 参数被简单地添加到内存地址中（从mpv 0.8.0开始，之前被忽略）。

    ``offset`` 是源文件中第一个像素的字节偏移（目前的实现总是将整个文件从位置0到图像的末端进行mmap，所以应该避免大的偏移量。在mpv 0.8.0之前，偏移量实际上是直接传递给 ``mmap`` 的，但为了使用更方便，它被改变了）。

    ``fmt`` 是一个标识图像格式的字符串。目前，只有 ``bgra`` 被定义。这种格式每个像素有4个字节，每个部分有8位。最不重要的8位是蓝色，最重要的8位是alpha（在little endian中，组成是B-G-R-A，B是第一个字节）。这使用了预乘alpha：每个颜色分量都已经与alpha分量相乘。这意味着每个分量的数值都等于或小于alpha分量（违反这个规则会导致不同视频输出驱动的不同结果：由于混合损坏的alpha值而导致的数值溢出被认为是不应该发生的事情，因此，在这种情况下，该实现并不能确保你得到可预测的行为）。

    ``w`` , `h`` 和 ``stride`` 指定覆盖层的尺寸。 ``w`` 是覆盖层的可见宽度，而 ``stride`` 给出的是内存中的字节宽度。在简单的情况下，使用 ``bgra`` 格式， ``stride==4*w`` 。一般来说，访问的内存总量是 ``stride * h`` （从技术上讲，最小的尺寸是 ``stride * (h - 1) + w * 4`` ，但是为了简单起见，播放器将访问所有 ``stride * h`` 的字节）。

    ``dw`` 和 ``dh`` （可选）指定叠加层的显示尺寸。叠加层的可见部分（ ``w`` 和 ``h`` ）在显示时会根据 ``dw`` 和 ``dh`` 按比例缩放。 如果没有参数，则使用 ``w`` 和 ``h`` 的值。

    .. note::

        在mpv 0.18.1之前，当更新一个覆盖层时，你必须手动进行“双重缓冲”，用一个不同的内存缓冲区来替换它。从mpv 0.18.1开始，内存被简单地复制，并且在提交返回后不引用任何由命令参数指示的内存。如果你想在mpv 0.18.1之前使用这个命令，请阅读旧的文档，看看如何正确处理这个问题。

``overlay-remove <id>``
    移除用 ``overlay-add`` 添加的相同ID的覆盖层。如果没有这个ID的覆盖层，则不做任何处理。

``osd-overlay``
    添加/更新/移除一个OSD覆盖层。

    （尽管这听起来与 ``overlay-add`` 相似， ``osd-overlay`` 是用于文本覆盖，而 ``overlay-add`` 是用于位图。也许 ``overlay-add`` 将被合并到 ``osd-overlay`` 中，以消除这种奇怪的现象。）

    你可以用它来添加ASS格式的文本覆盖层。ASS有高级的定位和渲染标签，可以用来渲染几乎所有种类的矢量图形。

    这个命令接受以下参数：

    ``id``
        识别覆盖层的任意整数。用不同的 ``id`` 参数调用此命令，可以添加多个覆盖层。用相同的 ``id`` 调用这个命令，会替换之前设置的覆盖层。

        每个libmpv客户端（即IPC连接、脚本）都有一个单独的命名空间，所以ID可以由API用户编排和分配，而不会与其他API用户冲突。

        如果libmpv客户端被销毁，所有与之相关的覆盖层也会被移除。特别是，通过 ``--input-ipc-server`` 连接，添加一个覆盖层，然后断开连接，将再次立即移除该覆盖层。

    ``format``
        给出覆盖层类型的字符串。接受以下值（HTML渲染已损坏，请查看生成的手册，或原始RST源）：

        ``ass-events``
            参数 ``data`` 是一个字符串。该字符串在换行符上被分隔。每一行都被转化为 ``Dialogue`` ASS事件的 ``Text`` 部分。计时是不使用的（但依赖计时的ASS标签的行为可能会在未来的mpv版本中改变）。

            注意，最好把多行放入 ``data`` ，而不是添加多个OSD覆盖。

            这提供了2个ASS的 ``Styles`` 。 ``OSD`` 包含由当前 ``--OSD-...`` 选项定义的文本样式。 ``Default`` 也是类似的，包含 ``OSD`` 在所有选项都设置为默认情况下的风格。

            此外， ``res_x`` 和 ``res_y`` 选项指定 ASS ``PlayResX`` 和 ``PlayResY`` 头部域的值。如果 ``res_y`` 被设置为0， ``PlayResY`` 将被初始化为一个任意的默认值（但注意这个命令的默认值是720，不是0）。如果 ``res_x`` 被设置为0， ``PlayResX`` 将根据 ``res_y`` 来设置，这样虚拟的ASS像素就有一个方形的像素宽高比。

        ``none``
            特殊值，导致覆盖层被移除。除了 ``id`` 和 ``format`` 以外的大多数参数都被忽略。

    ``data``
        根据 ``format`` 参数，定义覆盖内容的字符串。

    ``res_x`` , ``res_y``
        如果 ``format`` 被设置为 ``ass-events`` （参见那部分的描述），则使用。这是可选的，默认为0/720。

    ``z``
        叠加的Z顺序。这是可选的，默认为0。

        注意，不同格式的覆盖层之间的Z顺序是静态的，不能改变（目前，这意味着由 ``overlay-add`` 添加的位图覆盖层总是在由 ``osd-overlay`` 添加的ASS覆盖层之上）。此外，内置的OSD组件总是在任何自定义OSD的下方（这包括任何形式的字幕以及由 ``show-text`` 渲染的文本）。

        未来的mpv版本可能会随机改变不同OSD格式和内置OSD之间的Z顺序的处理方式。

    ``hidden``
        如果设置为 true，就不显示它（默认： false）。

    ``compute_bounds``
        如果设置为 true，尝试确定边界并将其作为 ``x0``, ``x1``, ``y0``, ``y1`` 的矩形写入命令的结果值（默认： false）。如果矩形是空的，未知的，或者某种程度上是退化的，则不设置。 ``x1``/``y1`` 是矩形的底端独占角的坐标。

        结果值可能取决于视频输出驱动窗口的大小，并且是基于调用时最后已知的窗口大小。这意味着结果可能与实际渲染的内容不同。

        对于 ``ass-events`` ，结果矩形被重新计算为 ``PlayRes`` 坐标（ ``res_x`` / ``res_y`` ）。如果窗口尺寸未知，就会选择一个回退值。

        你应该意识到这个机制是非常低效的，因为它渲染了全部的结果，然后使用渲染的位图列表的边界框（即使 ``hidden`` 被设置）。它将刷新各种缓存。它的结果也取决于所使用的libass版本。

        该功能是实验性的，可能会以某种方式再次改变。

    .. note::

        始终使用命名参数（ ``mpv_command_node()`` ）。Lua脚本应该使用 ``mp.create_osd_overlay()`` 帮助器，而不是直接调用这个命令。

输入和按键绑定类命令
~~~~~~~~~~~~~~~~~~~~

``mouse <x> <y> [<button> [<mode>]]``
    向指定的坐标（ ``<x>``, ``<y>`` ）发送一个鼠标事件。

    第二个参数：

    <button>
        被点击的鼠标按钮的按钮编号。这应该是0-19中的一个。如果 ``<button>`` 被省略，只有位置会被更新

    第三个参数：

    <single> （默认）
        鼠标事件代表常规的单击

    <double>
        鼠标事件代表双击

``keypress <name> [<scale>]``
    通过mpv的输入处理程序发送一个key event，触发为该按键设置的任何行为。 ``name`` 使用 ``input.conf`` 的命名方案来命名按键和修饰键。 ``scale`` 用于缩放由绑定命令引起的数值变化（与精确滚动机制相同）。对client API 非常有用：key events可以发送到 libmpv，由 libmpv 在内部处理。

``keydown <name>``
    类似于 ``keypress`` ，但设置了 ``KEYDOWN`` 标志，因此，如果按键被绑定到一个可重复的命令，它将随着mpv的按键重复计时重复运行，直到 ``keyup`` 命令被再次调用。

``keyup [<name>]``
    设置 ``KEYUP`` 标志，停止任何已经触发的重复行为。 ``name`` 是可选的。如果 ``name`` 没有指定或为空字符串， ``KEYUP`` 将被设置在所有按键上。否则， ``KEYUP`` 将只设置在 ``name`` 指定的键上。

``keybind <name> <command>``
    将一个键与一个输入命令绑定。 ``command`` 必须是一个完整的命令，包含所有需要的参数和标志。 ``name`` 和 ``command`` 都使用 ``input.conf`` 的命名方式。这主要对client API有用。

``enable-section <name> [<flags>]``
    除mpv内部使用外，此命令已过时。

    启用命名的输入部分的所有按键绑定。

    启用的输入部分形成一个堆栈。在堆栈顶部的部分的绑定比下部的部分优先。这条命令将该部分放在堆栈的顶部。如果该部分已经在堆栈上，它将被事先隐式地移除（一个部分不能在堆栈中出现多次）。

    参数 ``flags`` 可以是下列标志的组合（用 ``+`` 分隔）：

    <exclusive>
        在新启用的部分之前启用的所有部分都被禁用。一旦它们上面的所有独占部分被移除，它们将被重新启用。换句话说，新的部分会影射所有之前的部分。
    <allow-hide-cursor>
        此功能不能通过公开API使用。
    <allow-vo-dragging>
        同上。

``disable-section <name>``
    除mpv内部使用外，此命令已过时。

    禁用命名的输入部分。撤销 ``enable-section`` 。

``define-section <name> <contents> [<flags>]``
    除mpv内部使用外，此命令已过时。

    创建一个命名的输入部分，或者替换一个已经存在的输入部分的内容。 ``contents`` 参数使用与 ``input.conf`` 文件相同的语法（除了不允许在其中使用section的语法），包括需要用换行符来分隔绑定的内容。

    如果 ``contents`` 参数是一个空字符串，则该部分被移除。

    名为 ``default`` 的部分是正常的输入部分。

    一般来说，输入部分必须用 ``enable-section`` 命令启用，否则会被忽略。

    最后一个参数有如下含义：

    <default> （如果省略了该参数也可）
        只有当用户还没有把这个键绑定到一个命令时，才使用这个部分定义的按键绑定。
    <force>
        始终绑定一个按键（如果有歧义，则使用最近被激活的输入部分）。

    这个命令可以用来给脚本或客户端API用户分配任意的键。如果输入部分定义了 ``script-binding`` 的命令，也可以获得单独的按键up/down事件，以及相对详细的按键状态信息。特殊的键名 ``unmapped`` 可以用来匹配任何未映射的按键。

``load-input-conf <filename>``
    加载输入配置文件，类似于 ``--input-conf`` 选项。如果该文件已被包含，则在重新解析前不会重置其先前的绑定。

运行类命令
~~~~~~~~~~

``run <command> [<arg1> [<arg2> [...]]]``
    运行指定的命令。与MPlayer/mplayer2和mpv的早期版本（0.2.x和更早的版本）不同，这不会调用shell。相反，命令被直接运行，每个参数单独传递。每个参数都如 `属性扩展`_ 中那样被扩展。

    此命令具有可变数量的参数，也不能与命名参数一起使用。

    程序以分离的方式运行，mpv不会等待命令完成，但会在生成命令后立即继续播放。

    要获得旧版的行为，使用 ``/bin/sh`` 和 ``-c`` 作为前两个参数。

    .. admonition:: 示例

        ``run "/bin/sh" "-c" "echo ${title} > /tmp/playing"``

        这不是一个特别好的例子，因为它没有处理转义，而一个特别准备的文件可能允许攻击者执行任意的shell命令。建议编写一个小的shell脚本，然后用 ``run`` 来调用。

``subprocess``
    类似 ``run`` ，但给予调用者更多关于进程执行的控制权，并且不分离进程。

    你可以通过异步运行这个命令来避免阻塞，直到进程终止（例如Lua脚本中的 ``mp.command_native_async()`` ）。

    这个命令有以下命名参数。它们的顺序是不保证的，所以你应该始终用命名参数来调用它们，参见 `命名参数`_

    ``args`` (``MPV_FORMAT_NODE_ARRAY[MPV_FORMAT_STRING]``)
        字符串的数组，命令是第一个参数，后接的是后续的命令行参数。这就像 ``run`` 命令的参数列表。

        第一个数组条目是可执行文件的绝对路径，或者是没有路径成分的文件名，在这种情况下，可执行文件会在环境变量 ``PATH`` 的目录中搜索。在Unix上，这相当于 ``posix_spawnp`` 和 ``execvp`` 的行为。

    ``playback_only`` (``MPV_FORMAT_FLAG``)
        布尔值，表示当播放结束时，进程是否应该被终止（可选，默认： yes）。如果启用，停止播放将自动结束该进程，且你不能在播放之外启动它。

    ``capture_size`` (``MPV_FORMAT_INT64``)
        整数，设置可以捕获的最大stdout加stderr字节数（可选，默认： 64MB）。如果字节数超过该数，捕获将被停止。此限制是针对每个被捕获的流。

    ``capture_stdout`` (``MPV_FORMAT_FLAG``)
        捕获进程输出到stdout的所有数据，并在进程结束后返回（可选，默认： no）。

    ``capture_stderr`` (``MPV_FORMAT_FLAG``)
        与 ``capture_stdout`` 相同，但针对stderr 。

    ``detach`` (``MPV_FORMAT_FLAG``)
        是否以分离模式运行进程（可选，默认： no）。在这种模式下，进程会在一个新的进程会话中运行，命令不会等待进程终止。如果 ``capture_stdout`` 和 ``capture_stderr`` 都没有设置为 yes ，命令在新进程启动后立即返回，否则，只要管道开启，命令就会读取。

    ``env`` (``MPV_FORMAT_NODE_ARRAY[MPV_FORMAT_STRING]``)
        为新进程设置一个环境变量的列表（默认为空）。如果传递了一个空列表，则使用mpv进程的环境来代替（不同于底层操作系统的机制，mpv命令不能以空环境启动一个进程。幸运的是那完全无用）。列表的格式和 ``execle()`` 系统调用中的一样。每个字符串项都定义了一个环境变量，比如 ``NAME=VALUE``

        在Lua上，你可以使用 ``utils.get_env_list()`` 来检索当前环境，比如假设你想添加一个新的变量。

    ``stdin_data`` (``MPV_FORMAT_STRING``)
        向新进程的stdin输入给定的字符串。由于这是一个字符串，你不能传递任意的二进制数据。如果进程在所有数据写入前终止或关闭管道，剩余的数据将被默默地丢弃。可能在win32上不起效。

    ``passthrough_stdin`` (``MPV_FORMAT_FLAG``)
        如果启用，将新进程的stdin连接到mpv的stdin（默认： no）。在mpv 0.33.0之前，这个参数不存在，但其行为类似于被设置为 yes 。

    该命令返回以下结果（作为 ``MPV_FORMAT_NODE_MAP`` ）。

    ``status`` (``MPV_FORMAT_INT64``)
        通常情况下，如果进程正常结束，这就是进程的退出代码（0或正数），如果出现其它错误（启动失败、被mpv中止等），则为负数。负值的意义未被定义，除了表示错误（不对应操作系统的低级别退出状态值）。

        在Windows上，即使进程优雅地退出，也可能会返回一个负值，因为win32的 ``UINT`` 退出代码在被设置为结果集中的 ``int64_t`` 字段之前被分配给了一个``int`` 变量。这个问题以后可能会被修复。

    ``stdout`` (``MPV_FORMAT_BYTE_ARRAY``)
        被捕获的stdout流，受限于 ``capture_size``

    ``stderr`` (``MPV_FORMAT_BYTE_ARRAY``)
        与 ``stdout`` 相同，但用于stderr 。

    ``error_string`` (``MPV_FORMAT_STRING``)
        如果进程正常退出，则为空字符串。如果进程以不寻常的方式终止，则为字符串 ``killed`` . 如果进程不能被启动，则为字符串  ``init`` 。

        在Windows系统中，只有当进程被mpv杀死时， ``killed`` 才会被返回，因为 ``playback_only`` 被设置为true

    ``killed_by_us`` (``MPV_FORMAT_FLAG``)
        进程是否被mpv杀死，例如由于 ``playback_only`` 被设置为true，中止命令（比如通过 ``mp.abort_async_command()`` ），或者播放器即将退出。

    注意，只要参数正确，命令本身将总是返回success。进程是否可以被生成，或者是否以某种方式被杀死或返回错误状态，必须从结果值中查询。

    这个命令可以通过API异步中止。另参见 `异步命令详情`_ 。只有 ``run`` 命令可以以真正分离的方式启动进程。

    .. note:: 如果子进程不是以分离模式启动的，即使 ``playback_only`` 为false，它也会在播放器退出时被终止。

    .. warning::

        如果你想在播放器处于空闲状态时运行命令，或者你不想让播放结束时终结命令，不要忘记设置 ``playback_only`` 的字段为false

    .. admonition:: 示例

        ::

            local r = mp.command_native({
                name = "subprocess",
                playback_only = false,
                capture_stdout = true,
                args = {"cat", "/proc/cpuinfo"},
            })
            if r.status == 0 then
                print("result: " .. r.stdout)
            end

        这是一个相当无用的Lua例子，它演示了如何以阻塞的方式运行一个进程，并检索其stdout输出。

``quit [<code>]``
    退出播放器。如果给出了一个参数，它将作为进程的退出代码。

``quit-watch-later [<code>]``
    退出播放器，并存储当前的播放位置。以后播放该文件时，将跳转到先前的位置。（可选的）参数与 ``quit`` 命令完全一样。参见 `恢复播放`_

脚本类命令
~~~~~~~~~~

``script-message [<arg1> [<arg2> [...]]]``
    向所有clients发送一条消息，并把以下参数列表传递给它。这个消息是什么意思，它需要多少个参数，以及这些参数是什么意思，完全由接收方和发送方决定。每个client都会收到这个消息，所以要注意命名的冲突（或者使用 ``script-message-to`` ）。

    这个命令的参数数量不定，不能与命名参数一起使用。

``script-message-to <target> [<arg1> [<arg2> [...]]]``
    与 ``script-message`` 相同，但只发送给名为 ``<target>`` 的client。每个client（脚本等）都有一个唯一的名字。例如，Lua脚本可以通过 ``mp.get_script_name()`` 获得其名称。注意，clients名只能由字母数字字符和 ``_`` 组成。

    这个命令的参数数量不定，不能与命名参数一起使用。

``script-binding <name> [<arg>]``
    调用一个脚本提供的按键绑定。这可以用来重新映射由外部Lua脚本提供的按键绑定。

    ``<name>`` 是绑定的名称。 ``<arg>`` 是用户提供的任意字符串，可用于提供额外信息。

    它可以选择以脚本的名称为前缀，使用 ``/`` 作为分隔符，例如 ``script-binding scriptname/bindingname`` 。注意，脚本名称只能由字母数字字符和 ``_`` 组成。

    为了完整起见，这里是这个命令的内部工作方式。细节可能随时改变。在任何匹配的按键事件中， ``script-message-to`` 或 ``script-message`` 被调用（取决于是否包含脚本名称），使用以下字符串格式的参数：

    1. 字符串 ``key-binding`` 。
    2. 绑定的名称（如上所述）。
    3. 作为字符串的按键状态（见下文）。
    4. 按键名称（从mpv0.15.0开始）。
    5. 该键将产生的文本，如果不适用，则为空字符串。
    6. 该键的缩放，例如由 ``WHEEL_*`` 键产生的缩放。如果按键不可缩放，则缩放值为 1。
    7. 用户提供的字符串 ``<arg>`` 或空字符串（如果未使用该参数）。

    第5个参数只有在没有修饰键的情况下才会被设置（将shift键与字母一起使用通常不会发出带有修饰键的消息，而是会生成大写文本，但某些后端可能会出错）。

    按键状态由3个字符组成：

    1. ``d``（键被按下）， ``u`` （被释放）， ``r`` （键仍然在下，并且被重复；只有当此绑定的键重复被启用时）， ``p`` （键被按下；如果上/下不能被追踪，则发生）
    2. 事件是否来自鼠标， ``m`` （鼠标按钮）或 ``-`` （其它）
    3. 事件是否由取消引起（例如，键在逻辑上被释放，但在物理上未被释放），可以是 ``c`` （取消）或 ``-`` （其它）。并非所有类型的取消都会设置此标记。

    未来的版本可能增加更多的参数和更多的按键状态字符，以支持更多的输入特性。

    这是一个可扩展命令。详见 `输入命令前缀`_ 中的 ``nonscalable`` 部分的文档。

``load-script <filename>``
    加载一个脚本，类似于 ``--script`` 选项。这是否等待脚本完成初始化已被改变了多次，未来的行为未被定义。

    成功后，返回一个 ``mpv_node`` ，其 ``client_id`` 字段设置为新创建的脚本句柄的 ``mpv_client_id()`` API调用的返回值。

截图类命令
~~~~~~~~~~

``screenshot [<flags>]``
    拍摄屏幕截图。

    有多个标志可供选择（有些可与 ``+`` 组合）：

    <subtitles> （默认）
        以原始分辨率保存视频图像，带有字幕。在某些情况下，一些视频输出可能仍然包括OSD。
    <video>
        类似 ``subtitles`` ，但通常没有OSD或字幕。具体行为取决于所选的视频输出。
    <window>
        保存mpv窗口的内容。通常视频是缩放过的，有OSD和字幕。具体行为取决于所选的视频输出。
    <each-frame>
        每一帧截一次屏。再次发出这个命令可以停止截图。注意，使用这种模式时，你应该禁用frame-dropping功能 —— 否则在丢帧的情况下，你可能会收到重复的图像。这个标志可以和其他标志结合使用，例如 ``video+each-frame``

    旧版本mpv需要把 ``single`` 和 ``each-frame`` 作为第二个参数传递（且无标志）。这种语法仍然可以被解析，但已经过时，将来可能会被移除。

    如果你使用 ``;`` 把这个命令和另一个命令结合起来，你可以使用 ``async`` 标志来使编码/写入图像文件成为异步的。对于普通的独立命令，它总是异步的，这个标志没有影响。（该行为在mpv0.29.0中被更改）

    成功后，将返回一个带有 ``filename`` 字段，设为保存的屏幕截图位置的 ``mpv_node`` 。

``screenshot-to-file <filename> [<flags>]``
    截图并保存到一个指定的文件。文件的格式将由扩展名来猜测（并且 ``--screenshot-format`` 被忽略 —— 当扩展名丢失或未知时，行为是随机的）。

    第二个参数和 ``screenshot`` 的第一个参数一样，支持 ``subtitles`` ``video`` ``window``

    如果文件已存在，它将被覆盖写入。

    像所有的输入命令参数一样，文件名符合属性扩展，如 `属性扩展`_ 中所述。

``screenshot-raw [<flags> [<format>]]``
    在内存中返回一个屏幕截图。这只能通过client API使用。这个命令返回的MPV_FORMAT_NODE_MAP的 ``w`` , ``h`` , ``stride`` 字段被设置为明显的内容。

    ``format`` 字段设置为截图图像数据格式。这可以由 ``format`` 参数控制。格式可以是以下之一：

    bgr0 （默认）
        该格式的组织形式为 ``B8G8R8X8`` （其中 ``B`` 为 LSB）。填充 ``X`` 的内容未定义。
    bgra
        该格式的组织形式为 ``B8G8R8A8`` （其中 ``B`` 为 LSB）。
    rgba
        该格式的组织形式为 ``R8G8B8A8`` （其中 ``R`` 为 LSB）。
    rgba64
        该格式的组织形式为 ``R16G16B16A16`` （其中 ``R`` 为 LSB）。每个分量占用每个像素 2 个字节。使用此格式时，图像数据将是高位深数据， ``--screenshot-high-bit-depth`` 将被忽略。

    ``data`` 字段的类型为 MPV_FORMAT_BYTE_ARRAY ，包含实际图像数据。结果 mpv_node 释放后，图像也随之释放。与client API 语义一样，不允许写入图像数据。

    ``stride`` 是从位于 ``(x0, y0)`` 的像素到位于 ``(x0, y0 + 1)`` 的像素的字节数。如果图像被裁剪或有填充，这个数字可能大于 ``w * bpp`` 。这个数字也可以是负数。可以使用 ``byte_index = y * stride + x * bpp`` 访问像素。这里， ``bpp`` 是每个像素的字节数， ``rgba64`` 格式为 8 ，其他格式为 4 。

    ``flags`` 参数与 ``screenshot`` 的第一个参数一样，支持 ``subtitles`` , ``video`` , ``window``

滤镜类命令
~~~~~~~~~~

``af <operation> <value>``
    变更音频滤镜链。参见 ``vf`` 命令。

``vf <operation> <value>``
    变更视频滤镜链。

    其语义与选项解析完全相同（参见 `视频滤镜`_ ）。因此，下面的文字是一个多余的、不完整的总结。

    第一个参数决定发生什么：

    <set>
        用新的滤镜链覆盖之前的滤镜链

    <add>
        将新的滤镜链追加到之前的滤镜链后方

    <toggle>
        检查指定的滤镜（有准确的参数）是否已经存在视频滤镜链中。如果存在，移除该滤镜。如果不存在，则追加该滤镜（如果多个滤镜被传递到命令中，逐个滤镜执行）

        一个特殊的变量是把它和标签结合起来，用 ``@name`` 不带滤镜名称和参数作为滤镜条目。这样就可以切换启用/禁用标志。

    <remove>
        类似 ``toggle`` ，但始终移除滤镜链上的指定滤镜

    <clr>
        移除所有滤镜。注意，和其他子命令一样，这并不能控制自动插入的滤镜

    参数总是需要的。例如，如果 ``clr`` ，使用 ``vf clr ""``

    你可以通过在滤镜前加上 ``@name:`` （其中 ``name`` 是用户选择的任意标识符）为滤镜指定标签。标签可以用来在所有的滤镜链修改命令中用名字来指代滤镜。对于 ``add`` 来说，使用一个已经使用过的标签将取代现有的滤镜。

    ``vf`` 命令在修改滤镜链后在OSD上显示所请求的滤镜列表。这大致相当于 ``show-text ${vf}`` 。注意，用于格式转换的自动插入的滤镜不显示在列表中，只显示用户请求的内容。

    通常情况下，命令会检查视频链是否重新创建成功，失败时将撤销操作。如果命令在视频设置之前运行（如果命令在打开文件后，在视频帧被解码之前立即运行，就可能发生），这个检查就不能运行。那么就可能发生创建视频链失败的情况。

    .. admonition:: input.conf的示例

        - ``a vf set vflip`` ``a`` 键把视频上下颠倒
        - ``b vf set ""`` ``b`` 键移除所有视频滤镜
        - ``c vf toggle gradfun`` ``c`` 键切换去色带

    .. admonition:: 如何在运行时切换禁用的滤镜的示例

        - 在 ``mpv.conf`` 中加入类似 ``vf-add=@deband:!gradfun`` 的内容。 ``@deband:`` 是标签，是用户为这个滤镜条目任意起的名字。滤镜名称前的 ``!`` 默认情况下禁用该过滤器。之后的内容是正常的滤镜名称和可能的滤镜参数，就像正常的 ``--vf`` 语法一样。
        - 在 ``input.conf`` 中添加 ``a vf toggle @deband`` 。当按下 ``a`` 键时，这将切换标签为 ``deband`` 的过滤器的 "disable" 标志。

``vf-command <label> <command> <argument> [<target>]``
    向滤镜发送命令。请注意，目前这只适用于 ``lavfi`` 滤镜。有关每个滤镜支持的命令列表，请参阅 libavfilter 文档。

    ``<label>`` 是 mpv 滤镜的标签，使用 ``all`` 一次发送到所有滤镜。

    ``<command>`` 和 ``<argument>`` 是滤镜指定的字符串。

    ``<target>`` 是滤镜或滤镜实例名称，默认为 ``all`` 。请注意，对于支持目标的过滤器（如复杂的 ``lavfi`` 过滤器链），目标是一个额外的指定符。

``af-command <label> <command> <argument> [<target>]``
    与 ``vf-command`` 相同，但用于音频滤镜。

杂项类命令
~~~~~~~~~~

``ignore``
    用它来“屏蔽”应该被取消绑定的按键，不触发任何命令。对禁用部分默认绑定很有用，而不必用 ``--input-default-bindings=no`` 禁用所有绑定。

``drop-buffers``
    删除音频/视频/解复用器的缓存，并从新开始刷新。这可能有助于处理无法同步的流。这个命令在将来可能会被修改或移除。

``dump-cache <start> <end> <filename>``
    将当前的缓存转储到指定的文件名。如果名为 ``<filename>`` 的文件已经存在，它将被覆盖。 ``<start>`` 和 ``<end>`` 给出要转储的时间范围。如果在给定的时间范围内没有数据被缓存，则可能没有数据被转储（创建一个没有数据包的文件）。

    转储较大部分的缓存将冻结播放器。我们没有努力去解决这个问题，因为这个功能主要是为了创建小的摘录。

    请参见 ``--stream-record`` 的各种注意事项，这些注意事项大多也适用于这个命令，因为两者都使用相同的底层代码来编写输出文件。

    如果 ``<filename>`` 是一个空字符串，正在进行的 ``dump-cache`` 将被停止。

    如果 ``<end>`` 是 ``no`` ，则启用连续转储。然后，在转储现有的缓存部分后，从网络上读取的任何内容也会被追加到缓存中。这与 ``--stream-record`` 相似（尽管它与该选项不冲突，而且它们可以同时激活）。

    如果 ``<end>`` 时间在缓存之后，该命令将 _不_ 等待并将新收到的数据写入缓存。

    结果文件的结尾处可能会有轻微的损坏或不完整（没有做出足够的努力来保证末端的正确对齐）。

    注意，这个命令只有在转储结束后才会结束。这意味着它的工作原理与 ``screenshot`` 命令类似，只是它可以阻挡更长的时间。如果使用连续转储，该命令将不会结束，直到停止播放、发生错误、运行另一个 ``dump-cache`` 命令，或者调用 ``mp.abort_async_command`` 这样的API来明确停止该命令。请看 `同步与异步`_

    .. note::

        这主要是为网络流创建的。对于本地文件，可能有更好的方法来创建摘录之类的。有很多更友好的Lua脚本，通过催生一个单独的 ``ffmpeg`` 实例来重新编码文件的一部分。对于网络流，这不是那么容易做到的，因为流必须再次被下载。即使使用 ``--stream-record`` 将流记录到本地文件系统，也可能会有问题，因为记录的文件仍然被写入。

    这个命令是实验性的，关于它的所有细节在将来可能会改变。

``ab-loop``
    在A-B循环状态中循环。第一次命令将设置 ``A`` 点（ ``ab-loop-a`` 属性）；第二次是 ``B`` 点，第三次将清除两个点。

``ab-loop-dump-cache <filename>``
    本质上是调用``dump-cache``，以当前AB循环点为参数。与 ``dump-cache`` 一样，这将覆盖名为 ``<filename>`` 的文件。同样地，如果B点被设置为 ``no`` ，它将在现有的缓存被转储后进入连续转储。

    如果发现有足够的动力将这个功能转移到一个微不足道的Lua脚本中，作者保留删除这个命令的权利。

``ab-loop-align-cache``
    在 ``ab-loop-dump-cache`` 命令将（可能）转储的缓存内，重新调整A/B循环点的起点和终点。基本上，它将关键帧上的时间对齐。猜测可能会有偏差，特别是在结尾处（由于重新转换带来的精度问题）。如果缓存在此期间缩小了，该命令设置的点也不会是有效参数。

    这个命令的未来比 ``ab-loop-dump-cache`` 更不确定，如果作者认为它没有用，可能会消失而不被替换。

``begin-vo-dragging``
    如果当前 VO 支持，则开始拖动窗口。该命令只能在按下鼠标键时调用，否则将被忽略。该命令的具体效果取决于 VO 对窗口拖动的实现。例如，在 Windows 和 macOS 中，只有鼠标左键可以开始拖动窗口，而 X11 和 Wayland 则允许使用其他鼠标键。

``context-menu``
    在视频窗口上显示上下文菜单。详见 `上下文菜单`_ 部分。

未记录的命令： ``ao-reload`` （实验性的/内部的）。

事件列表
--------

这是一个部分的事件列表。本节描述了 ``mpv_event_to_node()`` 返回的内容，也就是脚本API和JSON IPC看到的内容。注意，C语言API有单独的C语言级别的声明与 ``mpv_event`` ，可能略有不同。

请注意，事件是异步的：当事件被传递给脚本和其他它户端时，播放器核心继续运行。在某些情况下，你可以用hooks来强制执行同步执行。

所有的事件都可以有以下字段：

``event``
    事件的名称（如由 ``mpv_event_name()`` 返回）。

``id``
    ``reply_userdata`` 字段（不透明的用户值）。如果 ``reply_userdata`` 是0，该字段不被添加。

``error``
    设置为一个错误字符串（如由 ``mpv_error_string()`` 返回）。如果没有发生错误，或者事件类型不报告错误，这个字段就会丢失。大多数事件不设置这个字段。

这个列表使用事件名称字段的值，以及括号中的C API符号：

``start-file`` ( ``MPV_EVENT_START_FILE`` )
    发生在一个新文件被加载之前。当你收到它时，播放器正在加载文件（或者可能已经完成）。

    它有以下字段：

    ``playlist_entry_id``
        现在正在加载的文件的播放列表条目ID。

``end-file`` ( ``MPV_EVENT_END_FILE`` )
    发生在一个文件被卸载后。通常情况下，播放器将立即加载下一个文件，如果这是最后一个文件，则退出。

    该事件有以下字段：

    ``reason``
        有这些值之一：

        ``eof``
            该文件已经结束。这可以（但不一定）包括不完整的文件或网络连接中断的情况。

        ``stop``
            播放被一个命令结束。

        ``quit``
            播放是通过发送退出命令结束的。

        ``error``
            发生了一个错误。在这种情况下，有一个 ``error`` 字段和错误字符串。

        ``redirect``
            发生在播放列表和类似的情况。详情见C API中的 ``MPV_END_FILE_REASON_REDIRECT``

        ``unknown``
            未知。通常不会发生，除非Lua的API与C的API不同步（同样，也可能发生你的脚本得到的原因字符串在你写入脚本的时候还不存在）。

    ``playlist_entry_id``
        正在播放或试图播放的文件的播放列表条目ID。这个值与相应的 ``start-file`` 事件中的 ``playlist_entry_id`` 字段相同。

    ``file_error``
        设置为mpv错误字符串，描述播放失败的大致原因。如果不知道错误，就不设置（在Lua脚本中，这个值是直接设置在 ``error`` 字段上。从mpv 0.33.0开始，这已经被废弃了。在未来，这个 ``error`` 字段对于这个特定事件将被取消设置）。

    ``playlist_insert_id``
        如果加载结束，因为要播放的播放列表条目是例如一个播放列表，而当前的播放列表条目被一些其它条目所取代。这种情况至少在 MPV_END_FILE_REASON_REDIRECT 中可能发生（其它事件类型将来可能出于类似但不同的目的使用这个）。在这种情况下， playlist_insert_id 将被设置为第一个插入条目的播放列表条目ID，而 playlist_insert_num_entries 则是插入的播放列表条目的总数。注意，在这种特定情况下，最后插入的条目的ID是 playlist_insert_id+num-1 。请注意，根据情况，你可能会在看到事件之前观察到新的播放列表条目（例如，在收到事件之前读取 "playlist" 属性或获得属性变化通知）。如果在C API中为0，这个字段就不会被添加。

    ``playlist_insert_num_entries``
        参见 playlist_insert_id 。只有当 playlist_insert_id 存在时才会出现。

``file-loaded``  ( ``MPV_EVENT_FILE_LOADED`` )
    发生在一个文件被加载并开始播放之后。

``seek`` ( ``MPV_EVENT_SEEK`` )
    发生在跳转时（这可能包括播放器内部跳转的情况，即使没有用户交互。这包括例如播放有序章节的Matroska文件时的片段变化）。

``playback-restart`` ( ``MPV_EVENT_PLAYBACK_RESTART`` )
    在跳转后或文件被加载后的开始播放。

``shutdown`` ( ``MPV_EVENT_SHUTDOWN`` )
    当播放器退出时发送，脚本应该终止。通常是自动处理。参见 `Details on the script initialization and lifecycle`_

``log-message`` (``MPV_EVENT_LOG_MESSAGE``)
    接收用 ``mpv_request_log_messages()`` 启用的信息（Lua:  ``mp.enable_messages`` ）。

    除了默认的事件字段外，它还包含以下字段：

    ``prefix``
        模块前缀，识别消息的发件人。当使用 ``--v`` 选项时，这是终端播放器放在消息文本前面的东西，也是用于 ``--msg-level`` 的东西。

    ``level``
        日志级别为字符串。参见 ``msg.log`` 了解可能的日志级别名称。请注意，mpv的后续版本可能会增加新的级别或移除（未记录的）现有级别。

    ``text``
        日志信息。该文本将以换行符结束。有时它可能包含多行。

    请记住，这些信息是为了提供人性化的提示。你不应该解析它们，而且信息的前缀/级别/文本可能随时改变。

``hook``
    该事件有以下字段：

    ``hook_id``
        要传递给 ``mpv_hook_continue()`` 的ID。Lua脚本包装器通过 ``mp.add_hook()`` 提供了一个更好的API。

``get-property-reply`` ( ``MPV_EVENT_GET_PROPERTY_REPLY`` )
    参见C API.

``set-property-reply`` ( ``MPV_EVENT_SET_PROPERTY_REPLY`` )
    参见C API.

``command-reply`` ( ``MPV_EVENT_COMMAND_REPLY`` )
    这是 ``error`` 字段有意义的命令之一。

    JSON IPC和Lua以及可能的其它后端会特别处理这个问题，可能不会将实际的事件传递给用户。参见C API。

    该事件有以下字段：

    ``result``
        任何 ``mpv_node`` 类型的结果（成功时），如果有的话。

``client-message`` ( ``MPV_EVENT_CLIENT_MESSAGE`` )
    Lua和可能的其它后端对其进行特殊处理，可能不会将实际事件传递给用户。

    该事件有以下字段：

    ``args``
        包含信息数据的字符串数组。

``video-reconfig`` ( ``MPV_EVENT_VIDEO_RECONFIG`` )
    发生在视频输出或过滤器的重新配置上。

``audio-reconfig`` ( ``MPV_EVENT_AUDIO_RECONFIG`` )
    发生在音频输出或过滤器的重新配置上。

``property-change`` ( ``MPV_EVENT_PROPERTY_CHANGE`` )
    当被观察的属性改变值时发生。

    该事件有以下字段：

    ``name``
        属性的名称。

    ``data``
        该属性的新值。

以下事件也会发生，但已过时。 ``idle`` , ``tick`` 使用 ``mpv_observe_property()`` (Lua: ``mp.observe_property()`` ) 来替代。

Hooks
~~~~~

Hooks是播放器核心和脚本或类似的东西之间的同步事件。这适用于客户端API（包括Lua脚本接口）。通常情况下，事件应该是异步的，而hook API提供了一种笨拙而不明显的方式来处理需要更严格协调的事件。没有做出任何API稳定性的保证。不完全遵循协议会使播放器随机冻结。基本上，没有人应该使用这个API。

C API在头文件里有描述。Lua API在Lua部分有描述。

在对API客户端实际调用hook之前，它将尝试为所有在hook之前被改变的观察到的属性返回新的值。这可能使应用程序更容易通过注册hook在属性变化通知之间设置定义的“障碍”（这意味着这些hooks会有效果，即使您什么也不做并使它们立即继续）。

目前定义了以下hooks：

``on_load``
    当一个文件要被打开时，在实际做任何事情之前被调用。例如，你可以读写 ``stream-open-filename`` 属性来重定向一个URL到其它地方（考虑支持很少给用户一个直接的媒体URL的流媒体网站），或者你可以通过设置 ``file-local-options/<option name>`` 属性来设置每个文件选项。播放器将等待，直到所有hooks都运行。

    排序在 ``start-file`` 之后和 ``playback-restart`` 之前。

``on_load_fail``
    在文件被打开后调用但失败时。这可以用来在本地解复用器无法识别文件的情况下提供一个回退，而不是像 ``on_load`` 那样总是在本地解复用器之前运行。只有当 ``stream-open-filename`` 被改变时，才会重试解复用。如果它再次失败，这个hook就不会再被调用，并且加载肯定会失败。

    排序在 ``on_load`` 之后， ``playback-restart`` 和 ``end-file`` 之前。

``on_preloaded``
    在文件被打开后，在轨道被选择和解码器被创建前被调用。如果API用户想根据可用的音轨集手动选择音轨，这有一定的用处。这对于通过API以特定方式初始化 ``--lavfi-complex`` 也很有用，而不必一开始就“探测”可用的流。

    注意，这还没有应用默认的轨道选择。究竟哪些操作可以做，哪些不可以做，哪些信息可以用，哪些还不能用，都有待于改变。

    排序在 ``on_load_fail`` 等之后， ``playback-restart`` 之前。

``on_unload``
    在关闭文件之前运行，在实际取消一切初始化之前。在这种状态下不可能恢复播放。

    排序在 ``end-file`` 之前。在错误的情况下也会发生（那就在 ``on_load_fail`` 之后）。

``on_before_start_file``
    在发送 ``start-file`` 事件之前运行（如果任何客户端改变了当前的播放列表条目，或者向播放器发送了退出命令，相应的事件在hook返回后将不会实际发生）。在加载新的文件之前，对排出属性的变化很有用。

``on_after_end_file``
    在 ``end-file`` 事件后运行。有助于在文件结束后排出属性变化。

输入命令前缀
------------

这些前缀放在按键名和实际命令之间。可以指定多个前缀。它们之间用空格隔开。

``osd-auto``
    使用该命令的默认行为。这是 ``input.conf`` 中命令的默认值。一些libmpv/scripting/IPC APIs不使用它作为默认，而是使用 ``no-osd``
``no-osd``
    不要为该命令使用任何OSD。
``osd-bar``
    如果可能的话，为该命令显示一个条状图。跳转命令会显示进度条，改变属性的命令可能会显示新设定的值。
``osd-msg``
    如果可能的话，为该命令显示一个OSD信息。跳转命令会显示当前的播放时间，改变属性的命令会以文本形式显示新设定的值。
``osd-msg-bar``
    结合osd-bar和osd-msg。
``raw``
    不在字符串参数中展开属性（如 ``"${property-name}"`` ）。这是一些libmpv/scripting/IPC APIs的默认设置。
``expand-properties``
    所有的字符串参数都按照 `属性扩展`_ 中的描述进行扩展。这是 ``input.conf`` 中命令的默认设置。
``repeatable``
    对于某些命令来说，一直按着一个按键不会重复运行命令。这个前缀在任何情况下都强制启用按键重复。对于一个命令列表：第一个命令决定了整个列表的可重复性（到0.33版本为止 —— 一个列表总是可重复的）。
``nonrepeatable``
    对于某些命令，按住一个键会重复运行该命令。在任何情况下，该前缀都会强制禁用按键重复。
``nonscalable``
    当某些命令（如 ``add`` ）绑定到与触摸板等高精度输入设备相关联的可缩放按键（如 ``WHEEL_UP`` ）时，命令中指定的值会根据可用的高分辨率输入数据缩放为更小的步长。此前缀会强制禁用此行为，因此数值始终以按键绑定中指定的离散单位进行更改。
``async``
    允许异步执行（如果可能）。注意，只有少数命令会支持这一点（通常这一点有明确的记录）。有些命令默认是异步的（或者说，它们的效果可能会在命令完成后表现出来）。这个标志的语义在未来可能会改变。只有当你不依赖这个命令的效果在它返回时完全实现时才设置它。参见 `同步与异步`_
``sync``
    允许同步执行（如果可能）。通常情况下，所有的命令默认都是同步的，但有些命令默认是异步的，以便与旧版的行为兼容。

所有的osd前缀仍然被全局的 ``--osd-level`` 设置所覆盖。

同步与异步
----------

``async`` 和 ``sync`` 的前缀只关系到命令发出方如何等待命令的完成。通常情况下，它不会影响命令本身的表现方式。有以下几种情况：

- 正常的input.conf命令总是以异步方式运行。慢速运行的命令排队或并行运行。
- “多个” input.conf命令（1个按键绑定，用 ``;`` 串联）将被依次执行，但那些异步的命令除外（要么以 ``async`` 为前缀，要么某些命令默认为异步）。这些异步命令会以分离的方式运行，可能与列表中其余的同步命令并行。
- 普通的Lua和libmpv命令（例如 ``mpv_command()`` ）是以阻塞方式运行的，除非使用了 ``async`` 前缀，或者该命令默认为异步的。这意味着在同步的情况下，调用者会阻塞，即使核心继续播放。异步模式是以分离的方式运行命令。
- 异步libmpv命令API（例如 ``mpv_command_async()`` ）永远不会阻塞调用者，并且总是用消息通知他们完成。 ``sync`` 和 ``async`` 的前缀没有区别。
- Lua还提供了运行异步命令的API，其行为类似于C语言的对应命令。
- 在所有情况下，异步模式仍然可以以同步的方式运行命令，甚至在分离模式下。例如，当一个命令没有异步实现的时候，就会发生这种情况。在这种情况下，异步libmpv API仍然不会阻塞调用者。

在mpv 0.29.0之前， ``async`` 前缀只被截图命令使用，并使它们以分离的方式运行文件保存代码。现在这是默认的， ``async`` 只在上面提到的方面改变行为。

目前，以下命令在同步与异步下有不同的等待特性：sub-add, audio-add, sub-reload, audio-reload, rescan-external-files, screenshot, screenshot-to-file, dump-cache, ab-loop-dump-cache

异步命令详情
------------

在API层面上，每个异步命令都与启动它的上下文绑定。例如，由 ``mpv_command_async`` 启动的异步命令被绑定到传递给函数的 ``mpv_handle`` 。只有这个 ``mpv_handle`` 能收到完成通知（ ``MPV_EVENT_COMMAND_REPLY`` ），而且只有这个句柄能直接中止仍在运行的命令。如果 ``mpv_handle`` 被销毁，由它启动的任何仍在运行的异步命令都会被终止。

脚本API和JSON IPC给每个脚本/连接提供了自己的隐式 ``mpv_handle``

如果播放器被关闭，核心可能会自行中止所有悬而未决的异步命令（就像代表API用户对每个悬而未决的命令强制调用 ``mpv_abort_async_command()`` 。这发生在发送 ``MPV_EVENT_SHUTDOWN`` 的同时，而且没有办法阻止它。

输入区
------

输入区将一套绑定分组，并一次性启用或禁用它们。在 ``input.conf`` 中，每个按键的绑定都被分配到一个输入区，而不是实际有明确的文本区。

另参见： ``enable-section`` 和 ``disable-section`` 命令。

预定义的绑定：

``default``
    没有输入区的绑定被隐含地分配给这个区。它在正常播放时默认是启用的。
``encode``
    在编码模式下激活的区。它被独立启用，所以在 ``default`` 区的绑定被忽略。

属性
----

属性被用于在运行时设置mpv选项，或者查询任意信息。它们可以用 ``set``/``add``/``cycle`` 命令操作，用 ``show-text`` 检索，或者其它任何使用属性扩展的方法。(参见 `属性扩展`_ ）。

如果一个选项被引用，该属性通常会采取/返回与该选项完全相同的值。在这些情况下，属性只是一种在运行时改变选项的方法。

注意许多属性在启动时不可用。参见 `Details on the script initialization and lifecycle`_

属性列表
--------

.. note::

    大多数选项也可以通过属性在运行时设置。只需从选项名称中移除前面的 ``--`` 。下面没有记录这些内容，参见 `选项`_ 。只有那些不存在同名的选项的属性，或者与选项有非常不同的行为的属性才会在下面记录。

    标记为(RW)的属性是可写的，而那些没有标记的是只读的。

``audio-speed-correction`` ``video-speed-correction``
    与播放器尝试播放文件的 ``speed`` 相乘的系数。通常情况下，它正好是1。（显示同步模式将使其有用）

    OSD格式将以 ``+1.23456%`` 的形式显示，数字是 ``(raw - 1) * 100`` ，用于给定的原始属性值。

``display-sync-active``
    ``--video-sync=display`` 是否实际激活。

``filename``
    当前播放的文件，路径已剥离。如果这是一个URL，也尝试取消百分比编码。（结果不一定正确，但看起来更适合显示。使用 ``path`` 属性来获取未修改的文件名）

    这有一个子属性：

    ``filename/no-ext``
        类似 ``filename`` 属性，但如果文本中包含 ``.`` ，则剥离最后一个 ``.`` 后的所有文本。通常这将移除文件扩展名。

``file-size``
    源文件/流的长度，以字节为单位。（这与 ``${stream-end}`` 相同。对于分段/多段的文件，这将返回主文件或清单文件的大小，无视它的格式）

``estimated-frame-count``
    当前文件中的总帧数。

    .. note:: 这只是一个估计值。（它是由两个不可靠的数量计算出来的：帧数和流长度）

``estimated-frame-number``
    当前数据流中的当前帧数。

    .. note:: 这只是一个估计值。（它是由两个不可靠的数量计算出来的：帧数和可能是取整的时间戳）

``pid``
    mpv的进程ID。

``path``
    当前播放文件的完整绝对路径。

``stream-open-filename``
    当前播放的媒体的完整路径。这只在特殊情况下与 ``path`` 不同。特别是，如果使用了 ``--ytdl=yes`` ，并且URL是由 ``youtube-dl`` 检测的，那么脚本将把这个属性设置为实际的媒体URL。这个属性应该只在 ``on_load`` 或 ``on_load_fail`` hook期间设置，否则它将没有效果（或者可能在未来做一些实现定义的事情）。如果当前媒体播放结束，该属性将被重置。

``media-title``
    如果当前播放的文件有一个 ``title`` 标签，则使用该标签。

    否则，返回 ``filename`` 属性。

``file-format``
    文件格式的符号名称。在某些情况下，这是一个用逗号分隔的格式名称列表，例如mp4是 ``mov,mp4,m4a,3gp,3g2,mj2`` （对于任何格式，这个列表在将来可能会增加）

``current-demuxer``
    当前解复用器的名称。（这个没有用处）

    （由 ``demuxer`` 重命名而来）

``stream-path``
    流层面的文件名（完整路径）。（这可能没有用处，几乎不会与 ``path`` 不同）

``stream-pos``
    源流中的原始字节位置。从技术上讲，它返回传递给解码器的最新数据包的位置。

``stream-end``
    源流中的原始结束位置，以字节为单位。

``duration``
    当前文件的持续时间，以秒为单位。如果持续时间未知，该属性不可用。注意，文件的持续时间并不总是准确的，所以这是一个估计值。

    它取代了 ``length`` 属性，该属性在mpv0.9发布后已过时。（语义是一样的）


    它有一个子属性：

    ``duration/full``
        即 ``duration`` 附带毫秒数

``avsync``
    最近的A/V同步差异。如果音频或视频被禁用，则不可用。

``total-avsync-change``
    已完成的总A-V同步校正。如果音频或视频被禁用，则不可用。

``decoder-frame-drop-count``
    解码器的丢帧数，由于视频进度远落后于音频（当使用 ``--framedrop=decoder`` 时）。有时，在其它情况下，例如视频封装损坏，或解码器不遵循通常的规则，这可能会增加丢帧数。如果视频被禁用，则不可用。

``frame-drop-count``
    视频输出驱动的丢帧数（当使用 ``--framedrop=vo`` 时）。

``mistimed-frame-count``
    为了保持A/V同步，在显示同步模式下没有正确计时的视频帧数。这不包括外部情况，例如视频渲染太慢或图形驱动程序以某种方式跳过垂直同步。它也不包括取整的错误（特别是在源时间戳不正常的情况下可能发生）。例如，使用 ``display-desync`` 模式时，不应该把这个值从0改变。

``vsync-ratio``
    对于一个帧平均显示多少个垂直同步。这只在display-sync被激活时可用。对于60Hz屏幕上的30FPS视频，这将是2。这是实际预定的动态平均数，所以60Hz时的24FPS不会永远精确地保持在2.5，而是根据最后显示的帧抖动。

``vo-delayed-frame-count``
    在显示同步模式下，由于外部条件造成的延迟帧数的估计值。注意一般来说，mpv不得不猜测这种情况的发生，而且猜测的结果可能不准确。

``percent-pos`` (RW)
    当前文件中的位置（0-100）。使用它而不是从其它属性中计算的好处是，如果文件的持续时间未知，它可以正确地退回从字节位置到估计的播放位置。

``time-pos`` (RW)
    当前文件中的位置，以秒为单位。

    它有一个子属性：

    ``time-pos/full``
        即 ``time-pos`` 附带毫秒数

``time-start``
    已过时。在mpv0.14之前，它用于返回文件的开始时间（可能影响例如传输流）。参见 ``--rebase-start-time`` 选项。

``time-remaining``
    文件的剩余长度，以秒为单位。注意，文件的持续时间并不总是准确已知的，所以这是一个估计值。

    它有一个子属性：

    ``time-remaining/full``
        即 ``time-remaining`` 附带毫秒数

``audio-pts``
    当前文件中的音频播放位置（秒）。与 ``time-pos`` 不同，它的更新频率高于每帧一次。这在很大程度上等同于纯音频文件的 ``time-pos`` ，但它也考虑了音频驱动程序的延迟。在某些情况下，这可能会导致负值，因此一般情况下，您可能只想使用 ``time-pos`` 。

    它有一个子属性：

    ``audio-pts/full``
        即 ``audio-pts`` 附带毫秒数

``playtime-remaining``
    ``time-remaining`` 与当前的 ``speed`` 相乘。

    它有一个子属性：

    ``playtime-remaining/full``
        即 ``playtime-remaining`` 附带毫秒数

``playback-time`` (RW)
    ``time-pos``的别名。

    在 mpv 0.39.0 之前， ``time-pos`` 和 ``playback-time`` 在某些边缘情况下可能报告不同的值。

    它有一个子属性：

    ``playback-time/full``
        即 ``playback-time`` 附带毫秒数

``remaining-file-loops``
    当前文件即将进行循环的次数。该值由 ``--loop-file`` 的值初始化而来。它会计算文件从头开始播放的次数，因此在最后一次播放时为 0。-1 对应无限。

``remaining-ab-loops``
    当前 A-B 循环即将进行的次数（如果有的话）。该值由 ``--ab-loop-count`` 的值初始化而来。这个值计算的是播放器跳转到 ``--ab-loop-a`` 的次数，因此在最后一次循环播放时它为 0。-1 对应无限。

``chapter`` (RW)
    当前的章节编号。第一章的编号是0。值为 -1 表示当前播放位置在第一章开始之前。

    设置该属性会导致absolute seek到该章的开始位置。但是，如果使用 ``add`` 或 ``cycle`` 命令更改该属性以导致值减小，则可能会跳转到当前章节的开头，而不是前一章的开头。详见 ``--chapter-seek-threshold``

``edition`` (RW)
    当前的edition编号。将此属性设置为一个不同的值将重新开始播放。第一个edition的号码是0。

    对于 Matroska 文件，这是版本。对于DVD/蓝光镜像，这是标题。

    在mpv0.31.0之前，如果你没有手动设置选项或属性，这显示的是在运行时选择的实际版本。在mpv0.31.0及以后的版本中，这严格地返回用户设置的选项或属性值，并且增加了 ``current-edition`` 属性来返回运行时选择的版本（默认情况下这与 ``--edition=auto`` 有关）。

``current-edition``
    当前选择的edition。如果没有加载文件，或者文件没有版本，该属性就不可用。（Matroska文件在没有editions和单一edition之间有区别，这将反映在该属性中，尽管在实际中并不重要）

``chapters``
    章节的数量。

``editions``
    edition的数量。

``edition-list``
    editions的列表，当前条目被标记。

    这有一系列子属性。用基于0来取代 ``N`` 的edition索引

    ``edition-list/count``
        edition的数量。如果没有edition，它可以是0或1（如果有一个无用的伪版本，就是1）

    ``edition-list/N/id``
        edition ID为整数。目前，这与edition索引相同

    ``edition-list/N/default``
        这是否是默认的edition

    ``edition-list/N/title``
        存储在文件中的edition标题。不总是可获取的

    当用client API使用 ``MPV_FORMAT_NODE`` 查询该属性时，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each edition)
                "id"                MPV_FORMAT_INT64
                "title"             MPV_FORMAT_STRING
                "default"           MPV_FORMAT_FLAG

``metadata``
    元数据键/值对。

    如果用Lua的 ``mp.get_property_native`` 访问该属性，这将返回一个元数据键与元数据值映射的表。如果是通过client API访问，则返回一个 ``MPV_FORMAT_NODE_MAP`` ，其中标签键映射到标签值。

    对于OSD，它返回一个格式化的列表。尝试以原始字符串的形式检索这个属性是无效的。

    这有一系列子属性：

    ``metadata/by-key/<key>``
        元数据条目 ``<key>`` 的值

    ``metadata/list/count``
        元数据条目的数量

    ``metadata/list/N/key``
        第N个元数据条目的键名（第一个条目是 ``0`` ）

    ``metadata/list/N/value``
        第N个元数据条目的值

    ``metadata/<key>``
        旧版本的 ``metadata/by-key/<key>`` 。不鼓励使用，因为元数据的关键字符串可能与其他子属性冲突

    这个属性的布局可能会有变化。欢迎提出建议，这个属性到底应该如何工作。

    当使用client API使用 ``MPV_FORMAT_NODE`` 查询该属性时，或使用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_MAP
            (key and string value for each metadata entry)

``filtered-metadata``
    类似 ``metadata`` ，但只包括 ``--display-tags`` 选项中列出的字段。这也是输出到终端的标签集。

``chapter-metadata``
    当前章节的元数据。作用类似于 ``metadata`` 属性。它也允许同样的访问方法（使用子属性）。

    每一章的元数据是非常罕见的。通常情况下，只有章节名称（ ``title`` ）被设置。

    为了访问其它信息，如章节的开始，参见 ``chapter-list`` 属性。

``vf-metadata/<filter-label>``
    由视频滤镜添加的元数据。通过滤镜标签获取，如果没有使用 ``@filter-label:`` 语法明确指定，将是 ``<filter-name>.NN``

    工作原理类似于 ``metadata`` 属性。它允许同样的访问方法（使用子属性）。

    这种元数据的一个例子是由 ``--vf=lavfi=cropdetect`` 添加的剪裁参数。

``af-metadata/<filter-label>``
    相当于 ``vf-metadata/<filter-label>`` ，但用于音频滤镜。

``deinterlace-active``
    如果 mpv 的去隔行扫描滤波器处于活动状态，则返回 ``yes``/true 。请注意，它不会检测任何通过 ``--vf`` 手动插入的隔行扫描滤波器。

``idle-active``
    如果没有文件被加载，但由于 ``--idle`` 选项，播放器在附近驻留，返回 ``yes`` /true。

    （由 ``idle`` 改名而来）

``core-idle``
    播放核心是否暂停。在特殊情况下，这可能与 ``pause`` 不同，例如当播放器由于网络缓存不足而自行暂停。

    如果播放正在重启或根本没有播放，这也会返回 ``yes`` /true。换句话说，只有在真正有视频播放的情况下，才会返回 ``no`` /false。（从mpv0.7.0开始的行为）

``cache-speed``
    缓存和下层（如网络）之间的当前I/O读取速度。这给出了1秒内的字节数（使用client API的 ``MPV_FORMAT_INT64`` 类型）

    这与 ``demuxer-cache-state/raw-input-rate`` 相同

``demuxer-cache-duration``
    视频在解复用器中缓存的大致持续时间，以秒为单位。这个猜测非常不可靠，通常无法获取这个属性，即使数据已缓存。

``demuxer-cache-time``
    视频在解复用器中缓存的大致时间，以秒为单位。与 ``demuxer-cache-duration`` 相同，但返回解复用器中缓冲数据的最后时间戳。

``demuxer-cache-idle``
    解复用器是否处于空闲状态，这意味着解复用器的缓存已经填充到要求的数量，目前没有读取更多数据。

``demuxer-cache-state``
    ``seekable-ranges`` 中的每个条目代表了解复用器缓存中可以被搜索到的区域，其中的 ``start`` 和 ``end`` 字段包含各自的时间戳。如果有多个解复用器在运行，这只返回关于“主”解复用器的信息，但将来可能会改变为返回所有解复用器的统一信息。这些范围的顺序是任意的。通常情况下，范围在被合并之前会有一些重叠。在边缘情况下，范围可能多处重叠。

    跳转范围的末端通常比 ``demuxer-cache-time`` 属性返回的值小，因为该属性返回的是猜测的缓冲量，而跳转范围代表的是实际可用于缓冲跳转的缓冲数据。

    ``bof-cached`` 表示具有最低时间戳的跳转范围是否指向流的开始（BOF）。这意味着你完全不能在这个位置之前跳转。 ``eof-cached`` 表示具有最高时间戳的跳转范围是否指向流的末端（EOF）。如果 ``bof-cached`` 和 ``eof-cached`` 都为true，并且只有一个缓存范围，则整个数据流都被缓存。

    ``fw-bytes`` 是在当前解码位置开始的范围内缓冲的数据包的字节数。这是一个粗略的估计（可能没有正确考虑到各种开销），并在解复用器的位置停止（它忽略了之后的跳转范围）。

    ``file-cache-bytes`` 是存储在文件缓存中的字节数。这包括所有的开销，以及可能的未使用的数据（如修剪的数据）。如果文件缓存没有和 ``--cache-on-disk=yes`` 一起启用，就缺失这个数据。

    ``cache-end`` 是 ``demuxer-cache-time`` 。如果不可用则缺失。

    ``reader-pts`` 是缓冲范围开始的大致时间戳。如果不可用则缺失。

    ``cache-duration``是`demuxer-cache-duration`` 。如果不可用则缺失。

    ``raw-input-rate`` 是网络层（或任何其他层级向字节的输入层）的估计输入率，单位是字节每秒。可能不准确或丢失。

    ``ts-per-stream`` 是一个数组，包含视频、音频和字幕等每种流类型的条目。对于每种数据流类型，该数据流类型的解串器缓存详情可作为 ``cache-duration`` 、``reader-pts`` 和 ``cache-end`` 提供。

    当用client API用 ``MPV_FORMAT_NODE`` 查询该属性时，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_MAP
            "seekable-ranges"   MPV_FORMAT_NODE_ARRAY
                MPV_FORMAT_NODE_MAP
                    "start"             MPV_FORMAT_DOUBLE
                    "end"               MPV_FORMAT_DOUBLE
            "bof-cached"        MPV_FORMAT_FLAG
            "eof-cached"        MPV_FORMAT_FLAG
            "fw-bytes"          MPV_FORMAT_INT64
            "file-cache-bytes"  MPV_FORMAT_INT64
            "cache-end"         MPV_FORMAT_DOUBLE
            "reader-pts"        MPV_FORMAT_DOUBLE
            "cache-duration"    MPV_FORMAT_DOUBLE
            "raw-input-rate"    MPV_FORMAT_INT64
            "ts-per-stream"     MPV_FORMAT_NODE_ARRAY
                MPV_FORMAT_NODE_MAP
                      "type"            MPV_FORMAT_STRING
                      "cache-duration"  MPV_FORMAT_DOUBLE
                      "reader-pts"      MPV_FORMAT_DOUBLE
                      "cache-end"       MPV_FORMAT_DOUBLE

    其他字段（将来可能被改变或删除）：

    ``eof``
        读取器线程是否达到了文件的末端

    ``underrun``
        读者器线程是否不能满足解码器对新数据包的请求

    ``idle``
        线程是否目前没有在被读取

    ``total-bytes``
        整个数据包队列的数据包字节数之和（加上一些开销的估计），包括缓存的可跳转范围

``demuxer-via-network``
    通过主解复用器解复用的流是否最可能通过网络播放。构成“网络”的部分并不总是清楚的，可能用于其他类型的不可信任的流，在某些情况下可能是错误的，而且它的定义可能正在改变。另外，外部文件（如独立的音频文件或流）并不影响这个属性的值（目前）。

``demuxer-start-time``
    解复用器报告的开始时间，以带小数的秒为单位。

``paused-for-cache``
    播放是否因等待缓存而暂停。

``cache-buffering-state``
    缓存填充状态的百分比（0-100），直到播放器取消暂停（与 ``paused-for-cache`` 有关）。

``eof-reached``
    是否到达播放进度的结束。注意通常只有当 ``--keep-open`` 被启用时，这才有意义，因为否则播放器会立即播放下一个文件（或退出或进入空闲模式），在这些情况下， ``eof-reach`` 属性被设置后，在逻辑上将立即被清除。

``seeking``
    播放器目前是否正在跳转，或以其他方式尝试重新开始播放（有可能在文件加载时返回 ``yes`` /true。这是因为相同的底层代码被用于跳转和重新同步）。

``mixer-active``
    音频混音器是否激活。

    这个选项相对来说是无用的。在mpv0.18.1之前，它可以用来推断 ``volume`` 属性的行为。

``ao-volume`` (RW)
    系统音量。这个属性只有在mpv音频输出当前处于激活状态时才可用，并且只有在底层实现支持音量控制时才可用。该选项的作用或如何解析该值取决于 API。例如，在 ALSA 上，它通常以线性曲线改变整个系统的音频音量，而在 PulseAudio 上，它则以立方曲线控制每个应用程序的音量。

``ao-mute`` (RW)
    与 ``ao-volume`` 相似，但控制静音状态。即使 ``ao-volume`` 起效，也可能未实现。

``audio-params``
    由音频解码器输出的音频格式。这有一系列子属性：

    ``audio-params/format``
        采样格式的字符串。这与mpv其它地方使用的名称相同

    ``audio-params/samplerate``
        采样率

    ``audio-params/channels``
        声道布局的字符串。这与 ``--audio-channels`` 接受的内容相似

    ``audio-params/hr-channels``
        类似 ``channels`` ，但不是发送至音频设备的可能的隐秘的实际布局，而是返回一个希望更容易被人阅读的形式（通常只有 ``audio-out-params/hr-channels`` 有意义）

    ``audio-params/channel-count``
        音频声道的数量。这与上面描述的 ``channels`` 字段是重复的

    当用client API的 ``MPV_FORMAT_NODE`` 查询该属性，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_MAP
            "format"            MPV_FORMAT_STRING
            "samplerate"        MPV_FORMAT_INT64
            "channels"          MPV_FORMAT_STRING
            "channel-count"     MPV_FORMAT_INT64
            "hr-channels"       MPV_FORMAT_STRING

``audio-out-params``
    和 ``audio-params`` 相同，但却是写入到音频API的数据格式。

``colormatrix``
    重定向到 ``video-params/colormatrix`` 。这个参数（以及类似的参数）可以被 ``format`` 视频滤镜覆盖。

``colormatrix-input-range``
    参见 ``colormatrix`` 。

`·colormatrix-primaries``
    参见 ``colormatrix`` 。

``hwdec`` (RW)
    反映 ``--hwdec`` 选项。

    如果可能的话，对它的写入可以改变当前使用的硬件解码器（在内部，播放器可能会重新初始化解码器，并将执行一次跳转以正确刷新视频）。你可以关注其他的hwdec属性来观察这是否成功。

    与mpv0.9.x及之前的版本不同的是，这并不返回当前激活的硬件解码器。从mpv0.18.0开始， ``hwdec-current`` 可用于此目的。

``hwdec-current``
    当前正在使用的硬件解码。如果解码是激活的，返回 ``hwdec`` 选项/属性所使用的值之一。 ``no`` 表示软件解码。如果没有加载解码器，该属性不可用。

``hwdec-interop``
    这将返回当前加载的硬件解码/输出interop驱动程序。这只有在视频输出程序被打开后才知道（也可能是后来）。对于某些视频输出（如 ``gpu`` ），这可能永远不会提前知道，而只在解码器成功尝试创建硬件解码器时才知道（使用 ``--gpu-hwdec-interop`` 可以加急加载）。如果有多个驱动程序被加载，它们将以 ``,`` 分隔。

    如果没有视频输出被激活或没有已知的interop驱动，这个属性就不可用。

    这不一定使用与 ``hwdec`` 相同的值。同一硬件解码器可以有多个interop驱动，这取决于平台和视频输出。

``width``, ``height``
    视频尺寸。这使用解码后的视频尺寸，或者如果还没有解码的视频帧，则使用（可能不正确的）容器显示的尺寸。

``video-params``
    视频参数，由解码器输出（和覆写的例如应用的长宽比等）。这有一系列子属性：

    ``video-params/pixelformat``
        像素格式的字符串。这与mpv的其它地方使用的名称相同

    ``video-params/hw-pixelformat``
        基本像素格式的字符串。这与某些硬件解码的情况有关，否则无法使用

    ``video-params/average-bpp``
        每像素的平均比特数，为整数。子采样的平面格式使用不同的分辨率，这就是这个值有时会很奇怪或令人困惑的原因。在某些格式中可能不可用

    ``video-params/w``, ``video-params/h``
        视频尺寸为整数，没有应用长宽比校正

    ``video-params/dw``, ``video-params/dh``
        视频尺寸为整数，按正确的长宽比进行缩放

    ``video-params/crop-x``, ``video-params/crop-y``
        源视频帧的裁切偏移量

    ``video-params/crop-w``, ``video-params/crop-h``
        视频裁切后的尺寸

    ``video-params/aspect``
        显示长宽比为双精度浮点数

    ``video-params/aspect-name``
        以字符串形式显示宽高比名称。该名称与特定宽高比的电影胶片格式名相对应。

    ``video-params/par``
        像素长宽比

    ``video-params/sar``
        存储长宽比

    ``video-params/sar-name``
        字符串形式的存储宽高比名称

    ``video-params/colormatrix``
        使用中的色彩矩阵的字符串（精确值可能会变化）

    ``video-params/colorlevels``
        动态范围的字符串（精确值可能会变化）

    ``video-params/primaries``
        使用中的色彩原色的字符串（精确值可能会变化）

    ``video-params/gamma``
        使用中的伽马函数的字符串（精确值可能会变化）

    ``video-params/sig-peak``
        视频文件标记的信号峰值，以浮点数表示（已过时）

    ``video-params/light``
        使用中的亮度类型的字符串（精确值可能会变化）

    ``video-params/chroma-location``
        色度采样的字符串（精确值可能会变化）

    ``video-params/rotate``
        预设的显示旋转度数（顺时针）

    ``video-params/stereo-in``
        源文件的立体3D模式（参见 ``format`` 视频滤镜的 ``stereo-in`` 选项）

    ``video-params/alpha``
        透明度类型。如果格式没有透明通道，这将是不可用的（但在未来的版本中，它可能变为 ``no`` ）。如果有，这将被设置为 ``straight`` 或 ``premul``

    ``video-params/min-luma``
        HDR10 元数据报告的最低亮度（单位：cd/m²）

    ``video-params/max-luma``
        HDR10 元数据报告的最高亮度（单位：cd/m²）

    ``video-params/max-cll``
        HDR10 元数据报告的最大内容亮度（单位：cd/m²）

    ``video-params/max-fall``
        HDR10 元数据报告的最大帧平均亮度（单位：cd/m²）

    ``video-params/scene-max-r``
        由 HDR10+ 元数据报告的场景 R 分量的最大 RGB 值（单位：cd/m²）

    ``video-params/scene-max-g``
        由 HDR10+ 元数据报告的场景 G 分量的最大 RGB 值（单位：cd/m²）

    ``video-params/scene-max-b``
        由 HDR10+ 元数据报告的场景 B 分量的最大 RGB 值（单位：cd/m²）

    ``video-params/max-pq-y``
        帧的最大 PQ 亮度，由峰值检测报告（单位 PQ，0-1）

    ``video-params/avg-pq-y``
        帧的平均 PQ 亮度，由峰值检测报告（单位 PQ，0-1）

    ``video-params/prim-red-x``, ``video-params/prim-red-y``
        红色主色度坐标，仅当与 ``video-params/primaries`` 不同时可用

    ``video-params/prim-green-x``, ``video-params/prim-green-y``
        绿色主色度坐标，仅当与 ``video-params/primaries`` 不同时可用

    ``video-params/prim-blue-x``, ``video-params/prim-blue-y``
        蓝色主色度坐标，仅当与 ``video-params/primaries`` 不同时可用

    ``video-params/prim-white-x``, ``video-params/prim-white-y``
        白点色度坐标，仅当与 ``video-params/primaries`` 不同时可用

    当使用client API的 ``MPV_FORMAT_NODE`` 查询该属性时，或者用Lua ``mp.get_property_native`` ，将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_MAP
            "pixelformat"       MPV_FORMAT_STRING
            "hw-pixelformat"    MPV_FORMAT_STRING
            "w"                 MPV_FORMAT_INT64
            "h"                 MPV_FORMAT_INT64
            "dw"                MPV_FORMAT_INT64
            "dh"                MPV_FORMAT_INT64
            "aspect"            MPV_FORMAT_DOUBLE
            "par"               MPV_FORMAT_DOUBLE
            "colormatrix"       MPV_FORMAT_STRING
            "colorlevels"       MPV_FORMAT_STRING
            "primaries"         MPV_FORMAT_STRING
            "gamma"             MPV_FORMAT_STRING
            "sig-peak"          MPV_FORMAT_DOUBLE
            "light"             MPV_FORMAT_STRING
            "chroma-location"   MPV_FORMAT_STRING
            "rotate"            MPV_FORMAT_INT64
            "stereo-in"         MPV_FORMAT_STRING
            "average-bpp"       MPV_FORMAT_INT64
            "alpha"             MPV_FORMAT_STRING
            "min-luma"          MPV_FORMAT_DOUBLE
            "max-luma"          MPV_FORMAT_DOUBLE
            "max-cll"           MPV_FORMAT_DOUBLE
            "max-fall"          MPV_FORMAT_DOUBLE
            "scene-max-r"       MPV_FORMAT_DOUBLE
            "scene-max-g"       MPV_FORMAT_DOUBLE
            "scene-max-b"       MPV_FORMAT_DOUBLE
            "max-pq-y"          MPV_FORMAT_DOUBLE
            "avg-pq-y"          MPV_FORMAT_DOUBLE
            "prim-red-x"        MPV_FORMAT_DOUBLE
            "prim-red-y"        MPV_FORMAT_DOUBLE
            "prim-green-x"      MPV_FORMAT_DOUBLE
            "prim-green-y"      MPV_FORMAT_DOUBLE
            "prim-blue-x"       MPV_FORMAT_DOUBLE
            "prim-blue-y"       MPV_FORMAT_DOUBLE
            "prim-white-x"      MPV_FORMAT_DOUBLE
            "prim-white-y"      MPV_FORMAT_DOUBLE

``dwidth``, ``dheight``
    视频显示尺寸。这是应用了滤镜和长宽比缩放之后的视频尺寸。实际的视频窗口大小仍可能与此不同，例如，如果用户手动调整视频窗口的大小。

    这些值与 ``video-out-params/dw`` 和 ``video-out-params/dh`` 相同。

``video-dec-params``
    非常类似 ``video-params`` ，但不应用覆写。

``video-out-params``
    与 ``video-params`` 相同，但在视频滤镜被应用后。如果没有使用视频滤镜，这将包含与 ``video-params`` 相同的值。请注意，这仍然不一定是视频窗口所使用的，因为用户可以改变窗口的大小，所有真正的视频输出驱动都独立于滤镜链而自行缩放。

    拥有与 ``video-params`` 相同的子属性。

``video-target-params``
    类似 ``video-params`` ，但与 VO 输出的目标属性有关。

    拥有与 ``video-params`` 相同的子属性。

``video-frame-info``
    当前帧的大致信息。请注意，如果在OSD上使用这些信息，由于OSD重绘和帧显示有些脱节，信息可能会有几帧的偏差，你可能不得不暂停并强制重绘。

    这有一系列子属性：

    ``video-frame-info/picture-type``
        图片的类型。它可以是 "I"（关键）、"P"（前向参考）、"B"（双向参考）或不可用

    ``video-frame-info/interlaced``
        帧的内容是否交错

    ``video-frame-info/tff``
        如果内容是隔行扫描，是否先显示顶场

    ``video-frame-info/repeat``
        解码时是否必须延迟帧数

    ``video-frame-info/gop-timecode``
        在帧中编码 GOP 时间码的字符串。

    ``video-frame-info/smpte-timecode``
        在帧中编码 SMPTE 时间码的字符串。

    ``video-frame-info/estimated-smpte-timecode``
        根据当前播放位置和帧数估算的时间码。

``container-fps``
    容器FPS。这很容易包含假的值。对于使用现代容器格式或视频编解码器的视频，这往往是不正确的。

    （由 ``fps`` 重命名）

``estimated-vf-fps``
    视频滤镜链输出的估计/测量的FPS（如果没有使用滤镜，这对应解码器输出）。这使用过去10帧的平均时间来计算FPS。如果涉及到丢帧，它将是不准确的（比如当明确的启用了framedrop，或在精确跳转之后）。具有不精确时间戳的文件（如Matroska）可能导致不稳定的结果。

``current-window-scale`` (RW)
    根据当前窗口大小计算的 ``window-scale`` 值。如果窗口大小在设置选项后没有改变，并且窗口大小没有受到其他方面的限制，那么这个值与 ``window-scale`` 相同。如果窗口是全屏的，这将返回从窗口的最后一次非全屏尺寸计算出来的比例值。如果没有视频被激活，该属性不可用。

    也可以写入该属性。这与写入 ``window-scale`` 的行为相同。请注意，写入 ``current-window-scale`` 不会影响 ``window-scale`` 的值。

``focused``
    窗口是否处于焦点。可能并非所有视频输出驱动都支持。

``ambient-light``
    环境照明条件，以lux为单位。（macOS 独占）

``display-names``
    mpv窗口所包含的显示器的名称。在X11上，这些是xrandr名称（LVDS1, HDMI1, DP1, VGA1, 等等）。在Windows上，这些是GDI名称（\\.\DISPLAY1，\\.\DISPLAY2，等等），列表中的第一个显示器将是Windows认为与该窗口相关的（由MonitorFromWindow API决定）。在 macOS 上，这些名称是系统信息中使用的显示产品名称，括号内为序列号，由于一个窗口只能在一个屏幕上显示，因此只返回一个显示名称。在 Wayland 上，如果使用的协议版本 >= 4（LVDS-1、HDMI-A-1、X11-1 等），这些是 wl_output 名称；如果使用的协议版本 <4，这些是 geometry 事件报告的 wl_output 模型。

``display-fps``
    当前显示器的刷新率。目前，这是视频涵盖的任何显示器的最低FPS，由底层系统API检索（例如X11的xrandr）。它不是测量的FPS。它不一定在所有平台上都可用。注意，任何列出的事实都可能在没有警告的情况下随时改变。

``estimated-display-fps``
    显示器刷新的实际速度，由系统时间测量。只有在display-sync模式（由 ``--video-sync`` 选择）激活时才可用。

``vsync-jitter``
    垂直同步持续时间的估计偏差系数。

``display-width``, ``display-height``
    当前显示器的水平和垂直分辨率，以像素为单位。这些值是否在mpv窗口改变显示时更新，取决于窗口化后端。它并非在所有平台上都可用。

``display-hidpi-scale``
    由窗口后端报告的HiDPI比例系数。如果没有视频输出程序被激活，或者视频输出没有报告一个值，这个属性是不可用的。报告一个绝对的DPI可能更合理，然而，这是大多数操作系统API实现HiDPI支持的方式。另参见 ``--hidpi-window-scale``

``osd-width``, ``osd-height``
    最近的已知的OSD宽度（可以是0）。如果你想使用 ``overlay-add`` 命令，就需要这个。它给你实际的OSD/窗口尺寸（不包括操作系统窗口管理器绘制的装饰）。

    是 ``osd-dimensions/w`` 和 ``osd-dimensions/h`` 的别名

``osd-par``
    最近的已知的OSD显示像素长宽比（可以是0）。

    是 ``osd-dimensions/osd-par`` 的别名

``osd-dimensions``
    最近的已知的OSD尺寸。

    有以下子属性（可以作为 ``MPV_FORMAT_NODE`` 或Lua表用 ``mp.get_property_native`` 读取）：

    ``osd-dimensions/w``
        OSD渲染单元中的视频输出驱动窗口的尺寸（通常是像素，但也可以用视频输出例如 ``xv`` 的缩放像素）

    ``osd-dimensions/h``
        OSD渲染单元中的视频输出驱动窗口的尺寸

    ``osd-dimensions/par``
        OSD的像素长宽比（通常为1）

    ``osd-dimensions/aspect``
        视频输出驱动窗口的显示长宽比（用上面的属性计算）

    ``osd-dimensions/mt``, ``osd-dimensions/mb``, ``osd-dimensions/ml``, ``osd-dimensions/mr``
        OSD到视频的（上、下、左、右）空白距离。这描述了视频被渲染的区域

    如果视频输出窗口没有被创建或不可见，这些属性中的任何一个都可能不可用或被设为伪值。

``term-size``
    当前终端尺寸。

    它有两个子属性。

    ``term-size/w``
        终端宽度，以单元格为单位
    ``term-size/h``
        终端高度，以单元格为单位

    此属性不可观测。响应尺寸变化需要轮询。

``window-id``
    只读的 - mpv的窗口ID。可能并不总是可用的，例如，由于窗口尚未被打开或不被视频输出驱动支持。

``display-swapchain``
    只读 —— Direct3D 11 交换链地址。返回一个 int64 类型的值，表示 D3D11 交换链的内存地址。该地址可能并非总是可用，例如当 d3d11-output-mode 未设置为 ``composition`` 或 VO 不支持该功能时。

``mouse-pos``
    只读 —— 最近的已知的鼠标位置，根据OSD尺寸常规化。

    有以下子属性（可以用 ``MPV_FORMAT_NODE`` 或 ``mp.get_property_native`` 读取Lua表）：

    ``mouse-pos/x``, ``mouse-pos/y``
        鼠标指针的最后已知坐标

    ``mouse-pos/hover``
        布尔值 —— 鼠标指针是否悬停在视频窗口上。当此值为false时，坐标应被忽略，因为视频后端只有在指针悬停窗口时才会更新坐标

``touch-pos``
    只读 —— 最后已知的触摸点位置，按 OSD 尺寸标准化。

    它有多个子属性。将 ``N`` 替换为基于 0 的触摸点索引。每当有新的手指触摸屏幕时，就会有一个新的触摸点被添加到触摸点列表中，其中可用的未使用的 ``N`` 最小。

    ``touch-pos/count``
        活动触摸点的数量。

    ``touch-pos/N/x`` , ``touch-pos/N/y``
        第 N 个触摸点的位置。

    ``touch-pos/N/id``
        触摸点的唯一标识符。当单个触摸点的索引发生变化时，该标识符可用于识别单个触摸点。

    在client API 中使用 ``MPV_FORMAT_NODE`` 或 Lua ``mp.get_property_native`` 查询属性时，将返回一个 mpv_node 并包含以下内容：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each touch point)
                "x"        MPV_FORMAT_INT64
                "y"        MPV_FORMAT_INT64
                "id"       MPV_FORMAT_INT64

``tablet-pos``
    只读 —— 笔（平板工具）的最后已知位置（归一化为OSD尺寸）及工具状态。

    有以下子属性：

    ``tablet-pos/x``, ``tablet-pos/y``
        平板工具的最后已知坐标。
    ``tablet-pos/tool-in-proximity``
        布尔值 - 表示平板工具是否当前位于平板表面附近或悬停于平板表面上方。
    ``tablet-pos/tool-tip``,
        平板工具提示的状态， ``up`` 或 ``down`` 。
    ``tablet-pos/tool-stylus-btn1``, ``tablet-pos/tool-stylus-btn2``, ``tablet-pos/tool-stylus-btn3``
        平板工具侧边按钮的状态， ``pressed`` 或 ``released`` 。
    ``tablet-pos/pad-focus``
        布尔值 - 当前是否聚焦于平板。
    ``tablet-pos/pad-btns/N``
        第N个平板垫按钮的状态， ``pressed`` 或 ``released`` 。

``sub-ass-extradata``
    当前 ASS 字幕轨道的额外数据。不进行格式化。额外数据将以字符串形式按原样返回。此属性不适用于非 ASS 类的字幕轨。

``sub-text``
    当前的字幕文本，不管字幕是否可见。格式被剥离。如果字幕不是基于文本的（例如DVD/BD字幕），将返回一个空字符串。

    它有不同格式的子属性：

    ``sub-text/ass``
        类似 ``sub-text`` ，但返回ASS格式的文本。其他格式的文本字幕会被转换。对于原生ASS字幕，不包含任何文本（但是矢量图等）的事件不会被过滤掉。如果多个事件与当前播放时间相匹配，它们会用换行符连接起来。只包含事件的“文本”部分。

    这个属性不足以正确渲染ASS字幕，因为ASS header和每个事件的元数据没有被返回。使用 ``/ass-full`` 作为取代方案。

    ``sub-text/ass-full``
        类似于 ``sub-text-ass`` ，但返回包含所有字段的完整事件，格式为 .ass 文本文件中的行。与 ``sub-ass-extradata`` 一起使用可获得样式信息。

``sub-text-ass`` （已过时）
    已过时的 ``sub-text/ass`` 的别名。

``secondary-sub-text``
    与 ``sub-text`` 相同（子属性也如此），但用于次字幕。

``sub-start``
    当前字幕的开始时间（以秒为单位）。如果有多个当前字幕，返回第一个的开始时间。如果没有当前的字幕被呈现，将返回null。

    它有一个子属性：

    ``sub-start/full``
        ``sub-start`` 以毫秒为单位

``secondary-sub-start``
    与 ``sub-start`` 相同，但用于次字幕。

``sub-end``
    当前字幕的结束时间（以秒为单位）。如果有多个当前字幕，返回最后的结束时间。如果没有当前的字幕被呈现，或者有呈现但持续时间未知或不正确，则返回null。

    它有一个子属性：

    ``sub-end/full``
        ``sub-end`` 以毫秒为单位

``secondary-sub-end``
    与 ``sub-end`` 相同，但用于次字幕。

``playlist-pos`` (RW)
    当前在播放列表中的位置。第一个条目是在0的位置。写入这个属性将在新位置开始播放。

    在某些情况下，这不必是当前播放的文件。参见  ``playlist`` 中的 ``current`` 和 ``playing``  标志的解释。

    如果播放列表是空的，或者如果它不是空的，但没有条目是 "current" 的，这个属性就会返回-1。同样，写入-1将使播放器进入空闲模式（如果没有启用空闲模式则退出播放）。（在mpv0.33.0之前，如果没有播放列表条目是“当前的”，这个属性就不可用）

    将当前值写回属性不会有任何影响。如果需要，可使用 ``playlist-play-index`` 重启当前条目的播放。

``playlist-pos-1`` (RW)
    与 ``playlist-pos`` 相同，但基于1。

``playlist-current-pos`` (RW)
    播放列表中的 "current" 项目的索引。这通常是，但不必是当前正在播放的项目（参见 ``playlist-playing-pos`` ）。根据播放器的确切内部状态，它可能指的是下一个要播放的播放列表项目，或者用于决定下一个播放内容的播放列表项目。

    对于读取，这与 ``playlist-pos`` 完全相同。

    对于写入，这 *只* 设置 "current" 项目的位置，而不停止当前文件的播放（或者开始播放，如果这是在空闲模式下进行的）。使用-1来移除当前标志。

    这个属性只是隐约有用。如果在播放过程中设置，它通常会导致播放列表中 *后* 的条目被接下来播放。另一个可能很奇怪的观察状态是，如果在播放过程中运行 ``playlist-next`` ，这个属性会被设置为下一个要播放的播放列表条目（与前面的情况不同）。有一个内部标志来决定是播放当前的播放列表条目还是下一个，这个标志目前对API用户来说是不可访问的（这种行为是否会被保留，可能会有变化）

``playlist-playing-pos``
    播放列表中 "正在播放" 的项目的索引。如果一个播放列表项目正在加载、实际播放或正在卸载，它就是 "playing" 。这个属性在 ``MPV_EVENT_START_FILE`` ( ``start-file`` ) 和 ``MPV_EVENT_START_END`` ( ``end-file`` ) 事件中被设置。除此以外，它返回-1。如果播放列表条目在播放过程中被移除，但播放还没有停止，或正在停止，它也会返回-1（这至少在状态转换时可能发生）。

    在“正在播放”状态下，这通常与 ``playlist-pos`` 相同，除了在状态转换时，或者如果 ``playlist-current-pos`` 被明确写入。

``playlist-count``
    总共的播放列表条目的数量。

``playlist-path``
    mpv展开条目之前，当前条目的原始播放列表路径。如果文件最初没有以某种方式与播放列表相关联，则不可用。

``playlist``
    播放列表，当前标记的条目。目前，原始属性值是无用的。

    这有一系列子属性。用基于0代替 ``N`` 的播放列表条目索引

    ``playlist/count``
        播放列表条目的数量（与 ``playlist-count`` 相同）

    ``playlist/N/filename``
        第N个条目的文件名

    ``playlist/N/playing``
        如果 ``playlist-playing-pos`` 属性指向此条目，则为 ``yes`` /true，否则为 ``no`` /false或不可用

    ``playlist/N/current``
        如果 ``playlist-current-pos`` 属性指向此条目，则为 ``yes`` /true，否则为 ``no`` /false或不可用

    ``playlist/N/title``
        第N个条目的名称。如果播放列表文件包含这样的字段，并且是受mpv解析器支持的播放列表格式，或者如果播放列表条目之前已被打开，并且已经获得了一个与文件名不同的媒体标题，则可用

    ``playlist/N/id``
        这个条目的唯一ID。这是一个自动分配的整数ID，在当前mpv核心实例的整个生命周期中是唯一的。其他命令、事件等使用它作为 ``playlist_entry_id`` 字段

    ``playlist/N/playlist-path``
        mpv展开此条目之前的播放列表的原始路径。如果文件最初没有以某种方式与播放列表相关联，则不可用

    当client API使用 ``MPV_FORMAT_NODE`` 查询该属性时，或者用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each playlist entry)
                "filename"  MPV_FORMAT_STRING
                "current"   MPV_FORMAT_FLAG (might be missing; since mpv 0.7.0)
                "playing"   MPV_FORMAT_FLAG (same)
                "title"     MPV_FORMAT_STRING (optional)
                "id"        MPV_FORMAT_INT64

``track-list``
    音频/视频/字幕的轨道列表，当前条目被标记。

    这有一系列子属性。用基于0代替 ``N`` 的轨道索引。

    ``track-list/count``
        轨道的总数

    ``track-list/video``
        视频轨列表。仅用于输出，其值无法检索。

    ``track-list/audio``
        音频轨列表。仅用于输出，其值无法检索。

    ``track-list/sub``
        字幕轨列表。仅用于输出，其值无法检索。

    ``track-list/N/id``
        用于 ``--sid``/``--aid``/``--vid`` 的ID。这在同一类型的轨道中是唯一的（字幕/音频/视频），但在其他方面不是

    ``track-list/N/type``
        描述媒体类型的字符串。 ``audio``, ``video``, ``sub`` 之一

    ``track-list/N/src-id``
        源文件中使用的轨道ID。不总是可用的（如果格式没有原生ID，如果轨道是一个伪轨道，在实际文件中不存在这种方式，或者如果格式由libavformat处理，而格式没有被列入有轨道ID的白名单，它就会丢失）

    ``track-list/N/title``
        储存在文件中的轨道标题。并非总是可用

    ``track-list/N/lang``
        文件中标识的轨道语言。并非总是可用

    ``track-list/N/image``
        如果这是一个由单一图片组成的视频轨道，则为 ``yes`` /true，否则为 ``no`` /false或不可用。用来确定一个流是否是图像的启发式方法并不尝试检测通常用于视频的编解码器中的图像。否则，它是可靠的

    ``track-list/N/albumart``
        如果这是一个嵌入音频文件或外部的封面图像，则为 ``yes`` /true，否则为 ``no`` /false或不可用

    ``track-list/N/default``
        如果该轨道在文件中设置了默认标志，则为 ``yes`` /true，否则为 ``no`` /false或不可用

    ``track-list/N/forced``
        如果文件中设置了force标志，则为 ``yes`` /true，否则为 ``no`` /false或不可用

    ``track-list/N/dependent``
        如果轨道在文件中设置了dependent标记，则 ``yes``/true，否则 ``no``/false 或不可用。

    ``track-list/N/visual-impaired``
        如果轨道在文件中设置了visual-impaired标记，则 ``yes``/true，否则 ``no``/false 或不可用。

    ``track-list/N/hearing-impaired``
        如果轨道在文件中设置了hearing-impaired标记，则 ``yes``/true，否则 ``no``/false 或不可用。

    ``track-list/N/hls-bitrate``
        HLS 流的比特率（如果有）。

    ``track-list/N/program-id``
        HLS 流的节目 ID（如果有）。

    ``track-list/N/codec``
        该轨道使用的编解码器名称，例如 ``h264`` 。在某些罕见情况下不可用

    ``track-list/N/codec-desc``
        此音轨使用的编解码器描述性名称

    ``track-list/N/codec-profile``
        此音轨使用的编解码器配置文件。仅在音轨已被解码的情况下可用

    ``track-list/N/external``
        如果该轨道是一个外部文件，则为 ``yes`` /true，否则为 ``no`` /false或不可用。这是为独立的字幕文件设置的

    ``track-list/N/external-filename``
        如果轨道来自外部文件的文件名，否则不可用

    ``track-list/N/selected``
        如果该轨道目前已被解码，则为 ``yes`` /true，否则为 ``no`` /false或不可用

    ``track-list/N/main-selection``
        它表示同一类型的轨道的选择顺序。如果一个轨道没有被选中，或被 ``--lavfi-complex`` 选中，它就不可用。对于字幕轨道， ``0`` 代表 ``sid`` ， ``1`` 代表 ``secondary-sid``

    ``track-list/N/ff-index``
        通常由FFmpeg工具使用的流索引。注意，如果使用libavformat（ ``--demuxer=lavf`` ）以外的解复用器，可能会出现错误。对于mkv文件，即使使用默认（内置）的解复用器，索引通常也会匹配，但并不能保证

    ``track-list/N/decoder``
        如果正在解码此轨道，则为简短的解码器名称

    ``track-list/N/decoder-desc``
        如果这个轨道正在被解码，则是人性化的可读的解码器名称

    ``track-list/N/demux-w``, ``track-list/N/demux-h``
        容器显示的视频尺寸提示（不总是准确）

    ``track-list/N/demux-crop-x``, ``track-list/N/demux-crop-y``
        源视频帧的裁切偏移量

    ``track-list/N/demux-crop-w``, ``track-list/N/demux-crop-h``
        裁切后的视频尺寸

    ``track-list/N/demux-channel-count``
        容器显示的音频声道数量（并不总是准确 —— 特别是音轨可能被解码为不同数量）

    ``track-list/N/demux-channels``
        容器显示的声道布局（不总是准确）

    ``track-list/N/demux-samplerate``
        容器显示的音频采样率（不总是准确）

    ``track-list/N/demux-fps``
        容器显示的视频FPS（不总是准确）

    ``track-list/N/demux-bitrate``
        音频平均比特率，以每秒比特为单位（不总是准确）

    ``track-list/N/demux-rotation``
        视频顺时针旋转元数据，以度为单位

    ``track-list/N/demux-par``
        像素长宽比

    ``track-list/N/format-name``
        ffmpeg 格式的简短名称。如果音轨是音频，这将是采样格式的名称。如果音轨是视频，这将是像素格式的名称。

    ``track-list/N/audio-channels`` （已过时）
        过时的 ``track-list/N/demux-channel-count`` 的别名

    ``track-list/N/replaygain-track-peak``, ``track-list/N/replaygain-track-gain``
        每条轨道的回放增益值。只适用于源文件中存储有相应信息的音轨

    ``track-list/N/replaygain-album-peak``, ``track-list/N/replaygain-album-gain``
        每张专辑的回放增益值。如果文件有每个音轨但没有每个专辑的信息，每个专辑的值将从目前的每个音轨的值中复制。在这种情况下，未来的mpv版本有可能使这些属性反而不可用。

    ``track-list/N/dolby-vision-profile``, ``track-list/N/dolby-vision-level``
        Dolby Vision 配置文件和级别。如果容器不提供此信息，则可能不可用。

    ``track-list/N/metadata``
        工作原理与 ``metadata`` 属性类似，但它访问的是按轨道/流设置的元数据，而不是整个文件的全局值。

    当用client API的 ``MPV_FORMAT_NODE`` 查询该属性时，或用Lua ``mp.get_property_native`` ，这将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each track)
                "id"                    MPV_FORMAT_INT64
                "type"                  MPV_FORMAT_STRING
                "src-id"                MPV_FORMAT_INT64
                "title"                 MPV_FORMAT_STRING
                "lang"                  MPV_FORMAT_STRING
                "image"                 MPV_FORMAT_FLAG
                "albumart"              MPV_FORMAT_FLAG
                "default"               MPV_FORMAT_FLAG
                "forced"                MPV_FORMAT_FLAG
                "dependent"             MPV_FORMAT_FLAG
                "visual-impaired"       MPV_FORMAT_FLAG
                "hearing-impaired"      MPV_FORMAT_FLAG
                "hls-bitrate"           MPV_FORMAT_INT64
                "program-id"            MPV_FORMAT_INT64
                "selected"              MPV_FORMAT_FLAG
                "main-selection"        MPV_FORMAT_INT64
                "external"              MPV_FORMAT_FLAG
                "external-filename"     MPV_FORMAT_STRING
                "codec"                 MPV_FORMAT_STRING
                "codec-desc"            MPV_FORMAT_STRING
                "codec-profile"         MPV_FORMAT_STRING
                "ff-index"              MPV_FORMAT_INT64
                "decoder"               MPV_FORMAT_STRING
                "decoder-desc"          MPV_FORMAT_STRING
                "demux-w"               MPV_FORMAT_INT64
                "demux-h"               MPV_FORMAT_INT64
                "demux-crop-x"          MPV_FORMAT_INT64
                "demux-crop-y"          MPV_FORMAT_INT64
                "demux-crop-w"          MPV_FORMAT_INT64
                "demux-crop-h"          MPV_FORMAT_INT64
                "demux-channel-count"   MPV_FORMAT_INT64
                "demux-channels"        MPV_FORMAT_STRING
                "demux-samplerate"      MPV_FORMAT_INT64
                "demux-fps"             MPV_FORMAT_DOUBLE
                "demux-bitrate"         MPV_FORMAT_INT64
                "demux-rotation"        MPV_FORMAT_INT64
                "demux-par"             MPV_FORMAT_DOUBLE
                "format-name"           MPV_FORMAT_STRING
                "audio-channels"        MPV_FORMAT_INT64
                "replaygain-track-peak" MPV_FORMAT_DOUBLE
                "replaygain-track-gain" MPV_FORMAT_DOUBLE
                "replaygain-album-peak" MPV_FORMAT_DOUBLE
                "replaygain-album-gain" MPV_FORMAT_DOUBLE
                "dolby-vision-profile"  MPV_FORMAT_INT64
                "dolby-vision-level"    MPV_FORMAT_INT64
                "metadata"              MPV_FORMAT_NODE_MAP
                    (key and string value for each metadata entry)

``current-tracks/...``
    这可以访问当前选择的轨道。它重定向到 ``track-list`` 中的正确条目。

    定义了以下子条目： ``video``, ``audio``, ``sub``, ``sub2``

    例如， ``current-tracks/audio/lang`` 返回当前音轨的语言字段（与 ``track-list/N/lang`` 的值相同）。

    如果通过 ``--lavfi-complex`` 选择了所要求的类型的轨道，将返回第一个。

``chapter-list`` (RW)
    章节列表，当前条目被标记。

    这有一系列子属性。用基于0代替 ``N`` 的章节索引。

    ``chapter-list/count``
        章节的数量

    ``chapter-list/N/title``
        存储在文件中的章节标题。并非总是可用

    ``chapter-list/N/time``
        章节的开始时间，单位是浮点数的秒

    当用client API的 ``MPV_FORMAT_NODE`` 查询该属性，或用Lua  ``mp.get_property_native`` ，将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each chapter)
                "title" MPV_FORMAT_STRING
                "time"  MPV_FORMAT_DOUBLE

``af``, ``vf`` (RW)
    参见 ``--vf`` / ``--af`` 和 ``vf`` / ``af`` 命令。

    当用client API的 ``MPV_FORMAT_NODE`` 查询该属性，或用Lua ``mp.get_property_native`` ，将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each filter entry)
                "name"      MPV_FORMAT_STRING
                "label"     MPV_FORMAT_STRING [optional]
                "enabled"   MPV_FORMAT_FLAG [optional]
                "params"    MPV_FORMAT_NODE_MAP [optional]
                    "key"   MPV_FORMAT_STRING
                    "value" MPV_FORMAT_STRING

    也可以用这种格式来写入属性。

``seekable``
    通常是否可以在当前文件中跳转。

``partially-seekable``
    当前文件是否被认为是跳转的，但只因为缓存是激活的。这意味着小的相对跳转可能是可行的，但较大的跳转可能会失败。跳转是否会成功，通常是不能预先知道的。

    如果这个属性返回 ``yes`` /true，那么 ``seekable`` 也会返回。

``playback-abort``
    播放是否已经停止或将要停止（在不明显的情况下很有用，比如在 ``on_load`` hook处理过程中，用户可以停止播放，但脚本必须明确结束处理）。

``cursor-autohide`` (RW)
    参见 ``--cursor-autohide`` 。将此设置为一个新的值将总是更新光标，并重置内部的计时器。

``term-clip-cc``
    插入符号以强制截断行至当前终端宽度。这可用于 ``show-text`` 和其它 OSD 信息。它必须是行中的第一个字符。它在行结束前一直有效。

``osd-sym-cc``
    将当前的OSD符号作为不透明的OSD控制代码（cc）插入。这只对 ``show-text`` 命令或设置OSD信息的选项有意义。控制代码是具体实施的，对其他事情没有用处。

``osd-ass-cc``
    ``${osd-ass-cc/0}`` 在OSD中禁止转义ASS序列的文本， ``${osd-ass-cc/1}`` 再次启用。默认情况下，ASS序列被转义以避免意外的格式化，该属性可以禁用这一行为。注意，这些属性会返回一个不透明的OSD控制代码，这只对 ``show-text`` 命令或设置OSD信息的选项有意义。

    .. admonition:: 示例

        - ``--osd-msg3='This is ${osd-ass-cc/0}{\\b1}bold text'``
        - ``show-text "This is ${osd-ass-cc/0}{\\b1}bold text"``

    任何由libass理解的ASS覆写标签都可以使用。

    注意，你需要转义 ``\`` 字符，因为字符串在传递给OSD代码之前会被处理为C转义序列。详见 `Flat命令语法`_

    标签的列表可以在这里找到：
    https://aegisub.org/docs/latest/ass_tags/

``vo-configured``
    当前视频输出驱动是否被配置了。通常这与视频窗口是否可见相对应。如果使用了 ``--force-window`` 选项，通常总是返回``yes`` /true。

``vo-passes``
    包含对视频输出的活动渲染传递及其执行时间的内省。并非所有的视频输出驱动都能实现。

    这被进一步细分为两种帧类型， ``vo-passes/fresh`` 用于刷新的帧（必须已被上传、缩放等）， ``vo-passes/redraw`` 用于重新绘制的帧（只需要已被重绘）。任何指定的子类型的传递次数可以从一帧到另一帧发生变化，因此不应依赖以上。

    每个帧类型都有一系列进一步的子属性。用帧类型代替 ``TYPE`` ， ``N`` 代替基于0的传递索引， ``M`` 代替基于0的采样索引。

    ``vo-passes/TYPE/count``
        传递的数量

    ``vo-passes/TYPE/N/desc``
        传递的人性化描述

    ``vo-passes/TYPE/N/last``
        最近的测量的执行时间，以纳秒为单位

    ``vo-passes/TYPE/N/avg``
        该传递的平均执行时间，以纳秒为单位。确切的时间范围是可变的，但一般应该是几秒钟

    ``vo-passes/TYPE/N/peak``
        该平均范围内的峰值执行时间（最高值），以纳秒为单位

    ``vo-passes/TYPE/N/count``
        该通道的采样

    ``vo-passes/TYPE/N/samples/M``
        该通道的特定采样的原始执行时间，以纳秒为单位

    当用client API的 ``MPV_FORMAT_NODE`` 查询该属性时，或用Lua ``mp.get_property_native`` ，将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_MAP
        "TYPE" MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP
                "desc"    MPV_FORMAT_STRING
                "last"    MPV_FORMAT_INT64
                "avg"     MPV_FORMAT_INT64
                "peak"    MPV_FORMAT_INT64
                "count"   MPV_FORMAT_INT64
                "samples" MPV_FORMAT_NODE_ARRAY
                     MP_FORMAT_INT64

    注意，不支持通过subkeys直接访问这个结构，唯一的访问方式是通过前面提到的 ``MPV_FORMAT_NODE``

``perf-info``
    进一步的性能数据。查询这个属性会触发一些数据的内部收集，可能会拖慢播放器。每次查询都会重置一些内部状态。属性变化通知没有也不会起作用。所有这些都可能在未来改变，所以不要使用这个。内置的 ``stats`` 脚本应该是唯一的用户；因为它是和源代码捆绑在一起的，它可以使用mpv内部的知识来正确渲染信息。一些细节参见 ``stats`` 脚本描述。

``video-bitrate``, ``audio-bitrate``, ``sub-bitrate``
    在数据包层面上计算的比特率值。它的工作原理是将两个关键帧之间的所有数据包的比特大小除以它们的演示时间戳距离（这使用时间戳存储在文件中，所以例如播放速度不会影响返回值）。特别是，视频比特率将只在每个关键帧更新，并显示 "past" 的比特率。为了使该属性对用户界面更友好，对这些属性的更新会以某种方式进行节制。

    单位是比特/秒。OSD格式将这些值变成千比特（或兆比特，如果合适的话），这可以通过使用原始属性值来防止，例如，用 ``${=video-bitrate}``

    请注意，这些属性的准确性受到一些因素的影响。如果底层的解复用器在解复用时重写了数据包（对某些文件格式做了重写），比特率可能略有偏差。如果时间戳不好或抖动（如在Matroska中），即使是恒定的比特率流也可能显示波动的比特率。

    这些值到底是如何计算的，将来可能会改变。

    在mpv的早期版本中，这些属性使用一个完全不同的方法返回一个静态（但不好）的猜测。

``audio-device-list``
    已发现的音频设备的列表。这主要用于client API，并反映了命令行播放器 ``--audio-device=help`` 返回的内容。

    当用client API的 ``MPV_FORMAT_NODE`` 查询属性时，或用Lua ``mp.get_property_native`` ，将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each device entry)
                "name"          MPV_FORMAT_STRING
                "description"   MPV_FORMAT_STRING

    ``name`` 是要传递给 ``--audio-device`` 选项的东西（通常是一个相当神秘的音频API特定ID），而 ``description`` 是人性化的可读的自由格式文本。如果没有描述，或者描述本来就是一个空字符串，那么描述将被设置为设备名称（减去mpv特有的 ``<driver>/`` 前缀）。

    名称设置为 ``auto`` 的特殊条目选择默认的音频输出驱动和默认设备。

    该属性可以通过client API和Lua脚本中的属性观察机制进行查看（从技术上讲，在第一次读取这个属性时就会启用变化通知）。

``audio-device`` (RW)
    设置音频设备。这直接读取/写入 ``--audio-device`` 选项，但在写入访问时，音频输出将被安排重新加载。

    在没有音频输出的情况下写入这个属性，不会自动启用音频（在先前写入访问 ``audio-device`` 后，由于重新初始化失败而禁用音频的情况下也是如此）。

    这个属性也不会告诉你哪个音频设备在被实际使用中。

    这些细节的处理方式在未来可能会改变。

``current-vo``
    当前的视频输出驱动（与 ``--vo`` 一起使用的名称）。

``current-gpu-context``
    VO的当前 GPU 上下文（与 ``--gpu-context`` 一起使用的名称）。对 ``--vo=gpu`` 和 ``--vo=gpu-next` 有效。

``current-ao``
    当前的音频输出驱动（与 ``--ao`` 一起使用的名称）。

``user-data`` (RW)
    这是一个在客户端之间共享的任意节点的递归按键/值图表，以供一般使用（即脚本、IPC客户端、主机应用程序等）。播放器自身不使用其中的任何数据（尽管一些内置脚本可能使用）。该属性在播放器重新启动后不会被保留。

    子路径可以被直接访问；例如， ``user-data/my-script/state/a`` 可被读取、写入或观测。

    top-level 对象本身不能被直接写入；而应写入子路径。

    将此属性或其子属性转换为字符串，这将得到一个JSON的呈现。如果转换一个 leaf-level 对象（即不是map或数组）并且不使用 raw mode，将给出底层内容（例如，字符串将被直接输出，而没有引号或JSON转义）。

    下列子路径保留给内部使用或具有特殊语义：
    ``user-data/osc``, ``user-data/mpv`` 除非另有说明，否则这些子路径下的任何属性的语义都可能随时发生变化，且不可依赖，写入这些属性可能会导致内置脚本无法正常工作。

    目前，以下属性定义了特殊语义：

    ``user-data/osc/margins``
        该属性由 OSC 实现写入，用于指示其占用的页边距。其子属性 ``l``、``r``、``t`` 和 ``b` 都应分别设置为左、右、上和下边距。值介于 0.0 和 1.0 之间，以窗口宽度/高度为基准。

    ``user-data/mpv/ytdl``
        内置 ytdl hook脚本共享的数据。

        ``user-data/mpv/ytdl/path``
            ytdl 可执行文件的路径（如果找到），否则为空字符串。在脚本尝试查找 ytdl 可执行文件之前，即在脚本加载 URL 之前，该属性不会被设置。

        ``user-data/mpv/ytdl/json-subprocess-result``
            执行 ytdl 以获取正在加载的 URL 的 JSON 数据的结果。格式与 ``subprocess`` 的结果相同，捕获 stdout 和 stderr。

    ``user-data/mpv/console/open``
        是否控制台已打开。

``menu-data`` (RW)
    此属性存储原始菜单定义。详情请参阅 `上下文菜单`_ 部分。

    ``type``
        菜单项类型。可以是 ``separator`` , ``submenu`` 或空。

    ``title``
        菜单项标题。如果类型不是 ``separator`` 则必须填写。

    ``cmd``
        点击菜单项时要执行的命令。

    ``shortcut``
        菜单项右侧显示的菜单项快捷键。
        快捷键不一定要有功能，它只是一个视觉提示。

    ``state``
        菜单项的状态。可以是 ``checked`` , ``disabled``, ``hidden`` 或空。

    ``submenu``
        子菜单项，类型为 ``submenu`` 时必须填写。

    使用client API ``MPV_FORMAT_NODE`` 或 Lua ``mp.get_property_native`` 查询属性时，将返回一个 mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (menu item)
                "type"           MPV_FORMAT_STRING
                "title"          MPV_FORMAT_STRING
                "cmd"            MPV_FORMAT_STRING
                "shortcut"       MPV_FORMAT_STRING
                "state"          MPV_FORMAT_NODE_ARRAY[MPV_FORMAT_STRING]
                "submenu"        MPV_FORMAT_NODE_ARRAY[menu item]

    如果 mpv 视频输出当前处于活动状态，则使用client API ``MPV_FORMAT_NODE`` 或 Lua ``mp.set_property_native`` 写入此属性将触发菜单的立即更新。您可以通过观察 ``current-vo`` 属性来检查情况。

``working-directory``
    mpv进程的工作目录。对JSON IPC用户可能有用，因为命令行播放器通常使用相对路径。

``current-watch-later-dir``
    存储 watch later 配置文件的目录。它返回 ``--watch-later-dir`` ，如果 ``--watch-later-dir`` 未被修改，则返回默认目录，并展开 tilde 占位符。

``protocol-list``
    可能被播放器识别的协议前缀列表。它们被返回，没有尾部的 ``://`` 后缀（但仍然总是需要）。在某些情况下，协议实际上是不被支持的（如果ffmpeg在编译时不支持TLS，可以考虑 ``https`` ）。

``decoder-list``
    支持的解码器的列表。这列出了可以传递给 ``--vd`` 和 ``--ad`` 的解码器。

    ``codec``
        典型的编解码器名称，用于识别解码器可以处理的格式

    ``driver``
        解码器本身的名称。通常，这与 ``codec`` 相同。有时它可能不同。它用于区分同一编解码器的多个解码器

    ``description``
        解码器和编解码器的人性化的可读描述

    当用client API的 ``MPV_FORMAT_NODE`` 查询该属性，或用Lua ``mp.get_property_native`` ，将返回一个mpv_node，内容如下：

    ::

        MPV_FORMAT_NODE_ARRAY
            MPV_FORMAT_NODE_MAP (for each decoder entry)
                "codec"         MPV_FORMAT_STRING
                "driver"        MPV_FORMAT_STRING
                "description"   MPV_FORMAT_STRING

``encoder-list``
    libavcodec编码器的列表。这与 ``decoder-list`` 的格式相同。编码器名称（ ``driver`` 条目）可以传递给 ``--ovc`` 和 ``--oac`` （没有 ``--vd`` 和 ``--ad`` 要求的 ``lavc:`` 前缀）。

``demuxer-lavf-list``
    可用的libavformat解复用器名称的列表。这可以用来检查对特定格式的支持或与 ``--demuxer-lavf-format`` 一起使用。

``input-key-list``
    `按键名称`_ 列表，与 ``--input-keylist`` 的输出相同。

``mpv-version``
    mpv版本/版权字符串。根据二进制文件的构建方式，它可能包含一个发布版本号，或者只是一个git哈希值。

``mpv-configuration``
    传递给构建系统的配置参数。如果用于编译mpv的meson版本低于1.1.0，那么就会显示一条由多个任意选项组成的硬编码字符串。

``ffmpeg-version``
    ``av_version_info()`` API调用的内容。这是一个以某种方式标识构建的字符串，可以是发布版本号，也可以是git哈希值。如果mpv与较早的FFmpeg版本链接，这个属性就不可用。

``libass-version``
    ``ass_library_version()`` 的值。这是一个整数，以有点奇怪的形式编码（显然是 "hex BCD"），表示链接到mpv的libass库的发布版本。

``platform``
    返回一个描述mpv的目标构建平台的字符串。该值取决于底层构建系统检测到的内容。一些最常见的值是： ``windows`` , ``darwin`` （macos或ios）, ``linux`` , ``android`` 和 ``freebsd`` 。请注意，这不是一个完整的列表。

``options/<name>`` (RW)
    选项 ``--<name>`` 的值。大多数选项可以在运行时通过写到这个属性来改变。请注意，许多选项需要重新加载文件以使更改生效。如果有同等的属性，最好设置该属性。

    应该没有任何理由访问 ``options/<name>`` 而不是 ``<name>`` ，除非这些属性有不同的行为或冲突的语义。

``file-local-options/<name>`` (RW)
    类似于 ``options/<name>`` ，但是当通过该属性设置一个选项时，一旦当前文件停止播放，该选项将被重置为旧值。当没有文件正在播放（或正在加载）时，尝试写入一个选项会导致错误。

    （注意，如果一个选项被标记为file-local，即使是 ``options/`` 也会访问本地值，而 ``old`` 值将在播放结束时被恢复，在播放结束前不能被读取或写入）

``option-info/<name>``
    每个选项的额外信息。

    这有一系列子属性。用顶层选项的名称替换 ``<name>`` 。不保证这些子属性的稳定性 —— 它们可能在将来发生根本性变化。

    ``option-info/<name>/name``
        选项的名称

    ``option-info/<name>/type``
        选项类型的名称，如 ``String`` 或 ``Integer`` 。对于许多复杂的类型，这并不是很准确

    ``option-info/<name>/set-from-commandline``
        该选项是否从mpv命令行设置。如果选项在运行时被改变，这个选项将被设置为undefined（意味着它可能在将来改变）

    ``option-info/<name>/set-locally``
        该选项是否按单文件设置。自动加载的设置文件、文件-目录的设置和其他情况都是如此。这意味着当播放结束时，选项的值将被恢复到播放开始前的值

    ``option-info/<name>/expects-file``
        选项是否将文件路径作为参数

    ``option-info/<name>/default-value``
        该选项的默认值。可能并非总是可用

    ``option-info/<name>/min``, ``option-info/<name>/max``
        选项允许的最小和最大整数值。只有在选项是数字的情况下才可用，并且最小/最大值已在内部设置。也有可能只设置了其中一个

    ``option-info/<name>/choices``
        如果该选项是一个可选择的选项，可能可选。整数的选择可能包括也可能不包括（它们可以由 ``min`` 和 ``max`` 暗示）。请注意，那些表现得像选项的选项，但内部不是实际的选项，可能没有这个信息

``property-list``
    顶层属性的列表

``profile-list``
    配置预设和其内容的列表。这是高度特定于此的实现，并可能随时改变。目前，它为每个配置预设返回一个选项数组。每个选项有一个名称和一个值，目前值总是一个字符串。请注意，选项数组不是一个表，因为顺序很重要，有可能出现重复的条目。递归的配置预设不被展开，并显示为特殊的 ``profile`` 选项。

    如果 ``profile restore`` 字段包含默认值（可能是因为它没有设置，或者显式设置为 ``default`` ），则当前缺少该字段，但将来可能会包含值 ``default`` 。

``command-list``
    输入命令的列表。这将返回一个数组表，其中每个表节点代表一个命令。这个表目前只有一个条目。 ``name`` 代表命令的名称（这个属性应该是对 ``--input-cmdlist`` 的替代。该选项转储了一些更多的信息，但如果需要的话，扩展这个属性是一个有效的功能请求）。

``input-bindings``
    当前输入按键键绑定的列表。这将返回一个数组，其中每个表节点代表一个单一的按键键/命令的绑定。这个表有以下条目：

    ``key``
        按键的名称。这是标准化的，可能与源文件中的指定方式略有不同（例如，在input.conf中）

    ``cmd``
        映射到按键上的命令（目前，这与源文件中指定的字符串完全相同，只是删除了空格和注释。将来有可能被规范化）

    ``is_weak``
        如果设置为 yes，任何现有的和激活的用户绑定将被优先考虑

    ``owner``
        如果此条目存在，则是添加此绑定的脚本（或类似）的名称

    ``section``
        该绑定属于某个部分的名称。这是一个很少使用的机制。这个条目可能会被删除或在将来改变含义

    ``priority``
        一个数字。数值高的绑定比数值低的绑定优先。如果该值为负数，这个绑定是未激活的，不会被输入触发。注意，mpv内部不使用这个值，在某些情况下，绑定的匹配工作可能略有不同。此外，这个值是动态的，可以在运行时改变。

    ``comment``
        如果存在的话，在同一行的命令后面的注释（例如，input.conf条目 ``f cycle bla # toggle bla`` 会产生一个条目 ``comment = "toggle bla", cmd = "cycle bla"`` ）

    这个属性是只读的，不支持更改提醒。目前，除了脚本添加或删除自己的绑定外，没有任何机制可以在运行时改变按键绑定。

``clipboard``
    剪贴板内容。只有在平台支持本地剪贴板时才有效。根据平台的不同，某些子属性、写入属性或更改通知目前无法使用。

    它有许多子属性：

    ``clipboard/text`` (RW)
        剪贴板中的文本内容（Windows, Wayland 和 macOS 独占）。写入此属性可设置剪贴板中的文本内容（Windows, Wayland 和 macOS 独占）

    ``clipboard/text-primary``
        primary selection 中的文本内容（Wayland 和 macOS 独占）。

    .. note::

        在使用 ``vo`` 剪贴板后端的 Wayland 上，剪贴板内容只有在合成器发送selection数据请求时才会更新（通常是在 VO 窗口被聚焦时）。而 ``wayland`` 后端通常没有这种限制。详见属性 ``current-clipboard-backend``

``current-clipboard-backend``
    包含当前活动剪贴板后端的字符串。有关可用的后端列表，参见选项 ``--clipboard-backends``

``clock``
    当前的本地时间，格式为 hour:minutes

选项和属性之间的不一致处
------------------------

你可以把（几乎）所有的选项作为属性来访问，尽管有些属性有一些注意事项（由于历史原因）。

``vid``, ``aid``, ``sid``
    当播放处于激活状态时，这些属性返回实际激活的轨道。例如，如果你设置了 ``aid=5`` ，而当前播放的文件不包含ID为5的音轨， ``aid`` 属性将返回 ``no``

    在mpv0.31.0之前，你只能在运行时设置存在的音轨。

``display-fps``
    这种不一致的行为已过时。弃用后，报告值和选项值被干净地分离开（选项值为 ``overrid-display-fps`` ）。

``vf``, ``af``
    如果你在播放过程中设置了这些属性，而滤镜链未能成功重新初始化，选项将被设置，但运行时的滤镜链不会改变。另一方面，下一个要播放的视频会失败，因为初始的滤镜链不能被创建。

    这种行为在mpv0.31.0中有所改变。在此之前， *如果* 一个视频（对于 ``vf`` ）或一个音频（对于 ``af`` ）轨道是激活的，新的值被拒绝。如果播放没有激活，行为与当前相同。

``playlist``
    该属性是只读的，返回当前的内部播放列表。该选项是为了在命令行解析时加载播放列表。对于client API的用户，你应该使用 ``loadlist`` 命令代替。

``profile``, ``include``
    这些都是只写入的，并将执行被写入的动作，就像在mpv CLI命令行上使用一样。它们唯一的用途是在 ``mpv_initialize()`` 之前使用libmpv，而这可能只在转码模式下有用。普通的libmpv用户应该使用其它机制，比如 ``apply-profile`` 命令，以及 ``mpv_load_config_file`` API函数。避免使用这些属性。

属性扩展
--------

所有输入命令的字符串参数以及某些选项（如 ``--term-playing-msg`` ）都要符合属性扩展。需要注意的是，属性扩展在一些地方不起作用，例如，数字参数是预期的（例如， ``add`` 命令不做属性扩展。 ``set`` 命令是一个例外，而非一般规则）。

.. admonition:: input.conf示例

    ``i show-text "Filename: ${filename}"``
        当按下 ``i`` 键时显示当前文件的文件名。

属性扩展是否默认启用取决于使用的哪种API（参见 `Flat命令语法`_ `指定为数组的命令`_ `命名参数`_ ），但它总是可以用  ``expand-properties`` 前缀启用，或用 ``raw`` 前缀禁用，如 `输入命令前缀`_ 所述。

支持以下扩展：

``${NAME}``
    展开到属性 ``NAME`` 的值。如果检索该属性失败，则扩展为错误字符串。（使用 ``${NAME:}`` 带尾巴的 ``:`` 来扩展到一个空字符串）。如果 ``NAME`` 前缀为 ``=`` ，则展开为该属性的原始值（见下文）
``${NAME:STR}``
    展开到属性 ``NAME`` 的值，如果不能检索到该属性，则展开到 ``STR`` 。 ``STR`` 是递归展开的
``${?NAME:STR}``
    如果有 ``NAME`` 属性，则扩展到 ``STR`` （递归）
``${!NAME:STR}``
    如果不能检索到 ``NAME`` 属性，则扩展为 ``STR`` （递归）
``${?NAME==VALUE:STR}``
    如果属性 ``NAME`` 扩展为等于 ``VALUE`` 的字符串，则扩展为 ``STR`` （递归）。你可以在 ``NAME`` 前加上 ``=`` ，以便比较一个属性的原始值（见下文）。如果该属性不可用，或者在检索时发生其他错误，该值永远不会被视为相等。注意， ``VALUE`` 不能包含任何 ``:`` 或 ``}`` 字符。另外，如果有需要，将来可能会增加用 ``"`` 或 ``%`` 转义的功能
``${!NAME==VALUE:STR}``
    与 ``?`` 变体相同，但是如果值不相等， ``STR`` 将被展开（使用与 ``?`` 相同的语义）
``$$``
    展开为 ``$``
``$}``
    展开为 ``}`` （要在递归扩展中产生这个字符）
``$>``
    禁用属性扩展和对字符串其余部分的 ``$`` 的特殊处理

在允许属性扩展的地方，通常也接受C-style转义。例如：

    - ``\n`` 成为一个换行符
    - ``\\`` 扩展为 ``\``

原始和格式化的属性
------------------

通常情况下，属性被格式化为人性化的可读文本，旨在显示在OSD或终端上。通过在属性名称前加上 ``=`` ，可以从一个属性中获取未格式化的（原始）值。这些原始值可以被其他程序解析，并遵循与属性相关的选项相同的惯例。此外，还有一个 ``>`` 前缀，用于格式化人类可读的文本，浮点数值采用固定精度。这对于输出需要恒定宽度的数值非常有用。

.. admonition:: 示例

    - ``${time-pos}`` 扩展为 ``00:14:23`` （如果播放位置在14分23秒）
    - ``${=time-pos}``扩展为 ``863.4`` （同样的时间，加上400毫秒 —— 在格式化的情况下通常不显示毫秒）

    - ``${avsync}`` 扩展为 ``+0.003``
    - ``${>avsync}`` 扩展为 ``+0.0030``
    - ``${=avsync}`` 扩展为 ``0.003028``

有时，原始属性值和格式化的属性值所携带的信息量的差异可能相当大。在某些情况下，原始值有更多的信息，比如比秒更精确的 ``time-pos`` 。有时情况正好相反，例如 ``aid`` 在格式化的情况下显示音轨标题和语言，但如果是原始值，则只显示音轨号码。
